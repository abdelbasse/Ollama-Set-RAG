{"ids": [["91038", "91643", "90680", "90871", "91730", "89391", "89998", "89610", "91738", "91162", "90925", "90050", "91069", "89885", "91761", "91570", "89987", "91755", "90699", "91594", "91569", "90267", "91739", "91750", "91741", "91598", "90295", "91040", "91072", "89690", "88817", "91753", "90302", "91016", "91749", "91752", "90105", "91609", "89237", "90298", "91046", "89819", "91252", "91763", "90726", "91766", "91166", "91803", "91980", "91774", "88816", "90381", "90808", "90098", "90078", "90385", "90389", "88821", "91768", "90486", "90296", "90114", "90387", "90391", "91757", "91025", "90116", "90120", "91740", "91630", "90006", "90271", "91847", "91206", "90727", "91629", "91055", "91722", "90117", "91846", "91011", "91425", "88610", "88635", "88694", "88720", "88782", "88853", "88892", "88905", "88918", "88952", "89605", "89616", "89629", "89677", "89683", "89695", "89703", "89711", "89739", "89748", "89754", "89771", "89796", "89815", "89830", "89842", "89854", "90126", "90139", "90145", "90155", "90165", "90453", "90533", "90561", "90578", "90583", "90593", "90611", "90640", "90665", "90707", "90721", "90738", "90745", "90761", "90772", "90780", "90794", "90837", "90885", "90900", "90905", "90931", "90939", "90948", "90963", "90984", "90990", "91005", "91009", "91020", "91078", "91087", "91108", "91126", "91238", "91248", "91288", "91320", "91342", "91361", "91373", "91392", "91447", "91471", "91483", "91488", "91496", "91506", "91514", "91533", "91537", "91565", "91615", "91626", "91636", "91653", "91681", "91691", "91744", "91782", "91806", "91824", "91832", "91843", "91853", "91863", "91883", "91891", "91895", "91908", "91928", "91935", "91943", "91954", "91979", "91983", "92006", "92023", "92049", "92313", "90786", "90528", "91765", "90774", "91212", "91834", "91258", "89901", "90077", "89268", "89294", "91756", "90730", "90083", "88793", "89775", "90269", "89946", "90811", "89010", "90283", "89370", "89708", "91762", "91897", "89478", "89960", "89923", "91498", "90686", "91736", "88985", "90941", "90822", "90677", "89120", "91814", "90951", "90489", "91117", "90110", "89975", "90810", "89959", "90896", "89122", "92073", "91617", "91758", "89688", "90710", "90804", "92052", "89077", "90121", "89834", "90834", "90512", "91155", "89704", "90025", "91728", "91036", "90087", "90118", "91491", "88922", "90129", "90967", "89821", "90851", "91163", "92017", "91017", "89151", "89692", "89888", "89759", "88973", "91160", "90813", "90115", "90700", "90094", "90500", "91873", "89781", "90675", "89691", "91725", "91764", "91178", "90119", "90058", "90805", "91316", "90481", "91286", "91318", "91390", "91481", "91486", "91494", "91504", "91512", "91531", "91535", "91563", "91613", "91624", "91634", "91651", "91679", "91689", "91742", "91780", "91804", "91822", "91830", "91841", "91851", "91861", "91881", "91889", "91893", "91906", "91926", "91933", "91941", "91952", "91977", "91981", "92004", "92021", "89765", "91326", "91406", "89980", "90775", "90492", "89933", "88721", "89617", "89756", "91047", "89121", "89229", "91116", "90303", "90498", "89669", "91037", "90645", "90180", "91161", "88835", "88608", "89852", "90163", "90638", "90663", "90835", "91003", "92047", "92311", "88855", "90516", "89957", "91723", "89757", "89720", "88972", "90806", "90219", "90704", "90089", "89449", "90945", "89631", "89900", "91597", "88633", "89675", "89693", "89709", "89746", "89794", "89840", "90137", "90143", "90451", "90531", "90559", "90576", "90736", "90898", "90929", "90982", "91085", "89782", "91209", "90803", "90688", "89595", "89729", "90819", "91751", "88950", "89737", "90609", "90705", "90759", "90770", "90778", "90946", "91076", "91124", "90135", "90088", "90682", "88792", "90807", "90753", "91734", "90084", "89964", "88903", "90153", "90581", "91236", "91340", "91371", "90029", "89107", "88989", "90258", "88718", "88780", "89614", "89752", "89813", "90124", "90792", "90903", "91359", "91445", "91469", "88980", "91192", "90112", "92255", "89350", "91770", "91610", "91880", "91925", "89833", "91395", "91772", "91111", "91251", "91358", "91418", "91110", "89766", "90206", "89963", "89884", "89878", "88956", "91015", "91114", "90696", "88947", "89269", "89295", "89577", "90683", "90889", "88692", "88851", "88916", "89627", "89681", "89701", "89769", "89828", "90591", "90883", "90937", "90961", "90988", "91007", "91018", "91106", "91246", "89983", "91243", "88893", "90558", "89612", "88859", "91217", "91588", "89085", "90809", "90277", "91551", "91667", "89007", "90487", "90037", "90791", "89784", "89309", "90099", "90863", "89515", "89418", "91049", "88705", "88711", "91466", "90007", "91136", "89308", "89897", "88857", "91501", "89349", "90546", "89783", "89000", "91075", "91324", "91039", "90286", "89793", "91737", "91291", "90491", "91612", "91351", "91382", "91439", "92050", "90636", "88866", "89357", "90237", "91082", "89436", "91464", "88613", "89337", "90215", "90723", "88695", "88854", "89630", "89903", "90513", "90529", "89997", "89926", "90497", "88890", "89603", "89667", "90719", "90743", "89002", "89881", "91388", "90957", "91010", "90009", "89902", "91571", "89958", "91993", "91169", "89818", "90108", "88636", "89644", "92000", "90265", "90278", "89883", "89764", "89225", "90396", "89780", "90378", "90676", "89371", "89413", "89760", "90942", "90230", "88838", "88697", "90263", "90001", "90799", "88882", "90257", "89743", "88908", "90826", "90490", "91357", "91595", "92197", "89705", "90090", "90831", "91474", "91109", "89723", "90729", "90379", "89223", "90171", "91328", "90004", "90374", "90556", "91579", "92270", "92315", "90717", "89906", "91104", "90573", "88960", "90526", "88729", "88986", "91777", "91070", "91649", "89785", "89872", "92241", "88976", "90825", "88794", "89749", "89356", "91123", "92338", "91185", "91208", "92231", "90897", "88889", "90800", "88710", "90344", "91648", "91467", "89974", "88937", "88944", "91463", "88834", "89856", "91957", "89927", "91253", "91611", "91462", "88963", "91581", "89932", "89657", "89648", "89652", "90673", "89209", "92013", "89645", "89835", "91775", "89791", "89103", "92263", "88906", "90454", "90167", "90820", "90544", "89925", "90146", "88725", "91048", "91353", "91433", "89860", "89113", "90545", "90111", "90185", "90005", "90495", "91053", "90552", "90739", "90734", "91363", "91473", "91250", "91118", "90178", "92221", "89909", "90107", "90551", "89003", "91767", "88984", "89473", "92245", "92010", "91905", "90012", "91322", "89999", "90827", "89591", "90563", "91394", "89112", "91074", "89981", "91712", "91475", "91230", "89296", "90355", "89125", "90991", "89589", "91600", "89857", "88953", "90888", "88888", "90250", "90554", "90186", "91995", "90722", "91409", "89633", "89619", "89224", "89928", "89106", "90838", "91732", "88912", "92236", "90953", "89276", "90839", "90776", "89014", "90082", "88949", "91400", "90175", "90457", "91145", "88994", "89417", "90814", "91628", "91733", "91437", "89762", "88964", "90290", "90909", "91168", "90690", "89800", "88808", "89892", "88806", "89618", "89071", "88730", "91137", "91845", "90494", "89364", "89811", "88983", "91389", "89110", "91940", "90661", "91646", "90521", "89712", "88715", "90829", "89354", "90276", "91748", "88939", "90742", "89544", "90458", "90797", "91211", "91344", "91375", "90668", "89696", "90231", "89812", "89202", "90166", "91132", "91465", "89804", "89803", "90992", "89250", "91186", "90740", "91573", "92316", "92249", "89945", "90877", "91170", "88681", "91645", "91006", "88946", "89877", "92274", "90493", "90234", "90525", "90220", "88979", "88894", "89844", "88611", "90828", "89699", "89226", "88896", "90447", "91308", "89559", "90013", "91747", "89820", "90079", "88921", "90672", "91604", "89001", "91204", "92007", "90502", "91683", "91810", "90130", "89777", "90540", "89684", "90940", "90444", "90335", "90356", "91364", "88876", "92027", "89004", "89875", "91290", "89606", "90634", "91866", "91150", "88878", "89661", "91239", "91403", "91552", "91668", "89590", "88639", "89271", "90483", "90176", "91807", "89832", "91173", "92230", "89984", "91784", "91080", "88919", "90901", "92188", "88810", "88975", "90091", "91068", "89571", "91584", "91640", "88886", "89801", "91485", "90590", "90309", "90047", "90812", "91083", "90208", "89969", "90103", "92319", "91904", "90557", "91797", "90681", "91130", "90876", "89303", "89655", "91139", "90584", "90282", "90093", "91962", "89278", "91189", "91561", "91677", "90689", "92282", "89190", "89355", "92326", "89707", "91769", "91996", "89855", "91945", "89942", "89613", "91399", "90549", "89416", "89790", "90366", "90762", "90773", "90442", "90134", "89123", "89620", "89935", "91119", "89273", "90887", "90708", "89772", "91021", "90224", "90127", "90641", "90817", "90279", "89678", "90010", "90534", "91254", "89553", "89563", "90123", "90667", "90555", "91587", "90612", "88924", "88941", "88988", "89348", "90671", "90724", "89347", "89189", "89041", "88990", "89929", "90823", "88957", "91052", "91001", "92259", "91829", "91888", "90443", "90654", "89807", "92009", "90365", "91590", "90781", "90225", "90687", "91305", "90170", "90642", "89758", "89956", "90488", "90142", "88843", "90456", "90268", "91987", "88722", "91436", "91435", "90305", "91127", "92016", "90872", "91044", "89366", "92237", "89924", "92051", "88837", "91133", "89365", "89976", "90140", "91990", "90746", "90496", "90326", "89663", "88955", "89215", "88958", "91568", "91796", "91759", "91223", "90795", "91622", "91839", "92226", "89740", "91079", "89698", "89823", "91586", "89206", "91090", "90964", "90944", "90866", "90184", "89792", "88967", "89009", "88844", "92314", "90695", "91207", "90790", "90270", "91089", "90193", "89412", "90976", "89538", "90785", "88870", "88814", "88978", "91022", "90016", "90191", "90536", "89128", "90097", "88993", "91081", "89908", "91773", "90213", "90100", "89083", "91339", "89556", "91115", "88943", "91503", "90161", "90194", "90238", "92215", "88987", "89954", "90397", "90233", "90965", "90472", "90222", "90109", "90168", "89017", "88707", "88699", "91167", "89249", "90198", "91582", "89074", "91216", "92297", "89797", "90187", "89035", "91203", "90747", "89011", "90981", "90464", "88664", "91214", "89862", "90429", "91911", "90777", "92305", "90095", "89602", "89008", "90535", "91056", "91510", "90177", "90789", "89228", "90782", "90357", "91113", "90784", "90212", "89191", "89446", "91855", "88703", "88864", "90538", "90174", "89728", "91327", "89081", "90398", "89301", "88839", "89876", "89713", "90650", "91387", "91596", "91735", "91754", "90080", "89653", "88798", "91460", "90229", "92078", "89685", "90874", "89825", "91449", "89755", "89816", "90886", "91059", "88726", "92233", "92337", "91012", "89277", "89118", "91013", "89890", "89221", "91529", "89611", "91343", "91374", "91448", "88769", "89227", "90336", "88749", "91715", "90148", "88708", "89686", "92177", "89374", "88739", "90666", "90476", "92149", "91985", "90052", "90519", "91574", "90949", "88679", "89527", "92340", "90511", "88981", "91986", "89360", "90594", "90364", "90890", "90371", "90802", "90460", "91705", "90024", "92290", "90969", "89642", "90692", "91415", "89664", "88626", "89030", "90299", "91867", "89574", "91706", "89962", "89415", "90289", "90128", "90354", "90906", "90840", "90046", "88868", "90709", "90141", "89373", "89798", "91073", "91918", "89879", "89788", "90394", "89700", "91515", "90106", "91698", "91461", "88923", "92248", "88723", "88676", "90182", "88999", "89660", "90756", "90595", "88638", "89472", "90162", "90635", "89870", "91000", "88850", "91034", "88618", "89558", "90579", "91337", "91165", "90694", "91974", "92251", "88895", "89649", "89431", "88945", "90204", "89025", "89845", "90956", "88809", "91500", "89716", "90821", "92267", "91450", "90455", "90169", "89201", "91709", "91430", "92146", "92343", "91545", "91661", "91356", "90548", "90351", "89448", "89304", "91240", "90196", "90228", "91102", "90156", "89982", "91141", "89252", "89265", "89291", "89722", "90527", "88712", "91304", "90986", "89253", "90613", "91700", "89658", "89593", "88682", "91858", "92145", "90485", "89843", "90562", "91088", "90469", "89774", "90735", "90183", "90209", "90339", "90360", "90518", "88961", "90873", "90566", "89012", "88982", "90085", "90287", "90893", "89455", "88640", "89996", "89155", "90322", "92211", "90409", "90918", "90550", "89332", "90316", "90218", "89636", "90980", "89936", "91714", "89013", "91912", "91900", "91606", "88772", "89641", "92281", "92308", "91179", "89065", "88909", "89401", "89889", "91153", "88911", "88915", "91196", "91631", "89863", "91249", "91147", "89947", "91323", "92053", "92139", "90637", "91686", "89836", "88932", "91809", "89979", "89887", "92011", "92154", "89817", "90002", "89192", "90243", "88936", "91776", "91314", "90363", "89282", "92242", "91721", "90575", "89353", "92135", "92234", "90605", "88907", "89916", "90624", "90459", "91154", "89978", "89358", "91718", "88689", "88874", "89600", "92189", "92207", "92216", "88898", "90537", "91955", "90304", "91045", "90122", "89822", "89730", "92301", "88628", "90179", "91477", "90564", "89934", "89205", "91798", "89670", "88714", "89779", "91370", "92271", "89831", "92200", "91060", "90027", "88728", "89331", "92097", "92120", "89362", "90202", "89665", "90927", "89767", "88773", "89172", "91292", "91972", "88716", "91156", "89861", "88612", "88920", "91325", "89378", "91971", "92100", "90741", "91438", "89382", "88617", "90018", "90223", "90392", "89130", "90565", "88913", "90214", "89255", "89322", "90932", "90950", "91210", "89111", "89893", "90924", "90830", "89882", "89392", "92293", "91903", "91746", "90310", "90313", "91398", "90993", "89238", "90262", "92202", "91693", "89135", "89609", "91241", "88995", "88954", "91599", "89914", "89763", "89334", "89424", "90522", "89105", "91659", "89930", "91760", "89858", "88966", "91608", "89905", "91567", "90998", "89182", "91507", "91369", "92260", "90570", "91576", "88783", "91949", "89726", "89539", "91682", "91854", "91637", "90317", "91816", "89279", "89951", "91414", "91172", "89948", "91440", "89059", "88615", "92024", "90643", "89991", "92015", "90236", "90569", "89938", "89361", "89248", "91892", "91560", "91676", "88992", "88622", "90895", "89152", "89339", "89465", "90465", "91401", "91502", "88702", "88863", "88875", "88672", "90669", "88925", "91218", "88654", "89513", "89023", "91638", "91490", "90428", "92194", "92212", "90758", "91694", "92124", "92222", "91242", "89006", "88965", "88942", "89042", "89768", "89608", "89626", "91027", "92285", "89864", "92075", "90352", "91966", "89359", "91134", "91480", "89647", "91901", "92184", "90188", "92227", "89063", "89548", "90854", "90748", "88768", "88784", "92032", "91002", "90471", "90599", "90520", "91585", "91593", "89054", "90053", "90275", "90923", "91707", "90764", "90173", "91572", "91092", "90850", "90933", "91164", "89806", "90023", "91195", "90040", "90716", "89139", "90832", "88637", "91121", "91129", "92238", "91704", "90656", "91975", "92026", "92332", "88998", "90274", "89846", "89697", "91771", "91607", "91878", "91923", "92031", "90386", "89363", "89917", "90985", "90061", "90844", "92020", "91128", "89161", "91944", "91939", "91029", "89565", "89579", "90081", "89566", "88948", "90912", "90314", "92169", "89420", "92092", "91311", "90478", "90913", "90907", "90031", "89212", "88900", "88624", "91122", "89910", "89287", "90147", "90467", "90474", "91745", "89689", "90711", "91697", "88776", "89200", "90670", "88997", "92035", "90388", "89266", "89292", "92320", "91791", "89076", "91221", "90975", "89536", "91244", "89596", "90030", "91402", "91063", "88974", "89545", "91870", "92214", "91182", "90035", "91820", "89199", "89075", "89651", "91140", "92278", "88897", "89451", "88698", "90221", "89588", "88883", "91644", "92294", "89904", "88643", "91028", "92193", "90333", "91660", "90239", "89261", "91726", "88657", "91650", "90475", "90960", "92206", "90383", "89965", "89267", "89293", "90157", "90585", "91492", "89372", "89761", "89519", "89953", "91914", "88929", "91315", "88727", "89262", "91497", "89245", "91692", "92264", "90841", "90655", "88785", "91148", "89164", "90380", "92025", "89179", "90916", "89166", "92239", "89058", "89594", "89805", "91177", "92317", "90608", "89027", "89570", "89127", "91871", "89719", "90131", "92086", "89460", "88704", "88865", "89421", "90370", "89305", "92133", "91042", "92173", "92240", "89789", "90657", "88938", "91174", "90968", "90861", "89133", "92095", "92118", "92141", "92152", "92155", "92183", "92244", "92266", "91708", "88959", "91091", "89718", "90249", "90614", "90390", "91984", "91713", "91779", "88779", "89307", "91190", "91674", "90086", "89298", "90978", "91710", "88836", "92256", "91176", "90974", "89235", "89462", "89623", "91538", "91654", "88791", "90092", "89330", "91701", "92105", "90505", "90539", "91289", "91321", "91362", "91393", "91472", "91616", "91833", "90973", "89086", "91181", "91946", "88609", "88634", "88693", "88719", "88781", "88852", "88891", "88904", "88917", "88951", "89604", "89615", "89628", "89668", "89676", "89682", "89694", "89702", "89710", "89738", "89747", "89753", "89770", "89795", "89814", "89829", "89841", "89853", "90125", "90138", "90144", "90154", "90164", "90452", "90532", "90560", "90577", "90582", "90592", "90610", "90639", "90664", "90706", "90720", "90737", "90744", "90760", "90771", "90779", "90793", "90836", "90884", "90899", "90904", "90930", "90938", "90947", "90962", "90983", "90989", "91004", "91008", "91019", "91077", "91086", "91107", "91125", "91237", "91247", "91287", "91319", "91341", "91360", "91372", "91391", "91446", "91470", "91482", "91487", "91495", "91505", "91513", "91532", "91536", "91564", "91614", "91625", "91635", "91652", "91680", "91690", "91743", "91781", "91805", "91823", "91831", "91842", "91852", "91862", "91882", "91890", "91894", "91907", "91927", "91934", "91942", "91953", "91978", "91982", "92005", "92022", "92048", "92312", "90284", "90306", "89919", "91522", "92252", "89662", "90674", "91580", "89310", "91641", "89141", "89851", "89093", "91601", "91396", "91566", "91191", "89476", "90751", "91489", "91199", "89680", "90750", "92083", "91030", "89407", "89379", "92181", "91419", "90468", "89580", "90241", "89257", "90783", "89452", "91367", "88933", "89731", "89634", "91175", "88928", "90713", "90860", "90071", "90132", "91657", "89607", "91869", "88803", "91432", "89097", "92300", "92309", "90151", "89949", "90616", "90568", "91550", "92198", "90702", "90473", "91999", "89109", "90260", "91151", "91302", "89873", "90653", "89300", "89064", "89108", "90096", "90032", "90542", "92304", "92325", "89894", "89336", "89419", "89475", "92106", "90818", "92334", "92342", "89977", "91790", "91812", "90235", "88741", "88649", "91916", "89993", "88750", "90232", "89091", "88740", "91627", "91844", "91896", "91936", "91479", "89333", "90261", "89234", "91348", "89016", "88869", "91544", "90382", "89479", "91868", "90285", "90019", "89256", "89638", "88690", "89486", "90845", "90658", "89022", "89621", "89671", "90197", "89138", "89624", "90567", "90216", "89477", "90189", "90484", "89214", "89039", "91484", "91064", "89824", "89776", "89321", "90506", "88899", "88627", "88991", "91301", "91410", "90101", "89239", "88881", "89281", "91138", "88790", "91084", "90479", "90315", "91825", "91864", "91884", "91909", "90955", "91352", "91811", "90264", "89168", "92172", "92196", "90768", "90450", "89474", "90543", "89328", "90571", "90754", "90003", "90020", "91558", "88684", "89522", "90393", "90395", "91041", "91997", "90586", "90373", "90995", "91720", "90246", "89859", "91702", "92339", "91397", "90247", "91098", "88826", "90523", "91219", "90419", "91215", "92128", "91354", "91817", "89048", "89433", "91442", "89160", "90499", "90580", "90113", "90718", "89150", "89868", "92288", "92160", "90433", "89203", "89156", "88770", "90045", "90226", "92080", "90547", "89915", "90073", "90892", "91994", "90852", "88931", "90971", "90630", "90815", "88751", "88786", "90328", "90288", "89560", "90068", "90312", "91915", "92153", "90369", "91808", "91655", "91233", "90329", "91639", "89921", "89471", "88811", "91860", "92201", "90060", "91557", "91673", "92003", "90190", "89045", "89311", "91295", "91405", "88614", "90251", "91345", "88971", "88619", "89406", "90788", "91961", "89988", "91224", "88845", "92076", "91194", "92093", "89246", "89193", "91131", "91097", "90966", "92335", "91346", "89456", "92318", "91385", "89020", "90816", "89643", "91967", "92018", "91543", "90377", "91642", "92081", "92084", "92087", "92090", "90301", "92327", "91695", "89995", "90266", "91313", "91958", "90510", "91526", "92322", "90920", "91885", "91666", "90509", "89826", "90376", "89425", "92187", "91149", "90952", "90731", "90954", "88623", "89939", "90217", "89940", "91711", "91523", "90255", "90133", "89488", "90765", "90678", "89592", "89525", "88680", "89104", "88758", "91989", "88660", "88647", "91534", "91426", "92331", "90384", "88648", "88652", "88653", "89457", "92176", "88930", "91416", "89724", "91180", "88940", "88807", "89635", "92119", "88797", "89088", "89847", "92162", "89434", "90000", "88646", "91583", "91828", "91688", "89286", "89931", "90732", "92277", "90698", "89432", "88910", "90644", "92034", "90448", "90136", "89159", "89428", "88884", "89913", "90199", "92246", "88815", "88673", "90649", "90587", "88871", "92180", "89453", "88914", "89129", "91539", "91377", "90338", "89827", "90858", "90021", "90195", "90318", "89240", "91222", "89546", "89066", "90331", "90648", "88724", "90725", "91112", "89149", "92123", "89586", "89523", "89099", "90855", "89414", "90715", "88887", "88629", "89124", "90662", "90427", "89078", "89098", "91061", "89598", "89220", "89654", "89494", "91105", "90227", "90102", "90039", "90461", "89742", "91423", "92296", "89142", "88789", "89134", "89992", "92275", "91528", "91902", "89891", "90859", "90891", "90011", "89966", "89247", "91719", "89147", "91213", "90438", "90049", "89197", "90028", "89315", "91913", "90158", "92329", "89568", "92055", "91298", "90297", "91255", "90936", "89144", "92071", "90008", "88812", "90036", "90679", "92074", "89176", "88873", "91519", "89955", "90323", "91386", "92165", "89994", "91051", "91541", "90172", "90362", "91499", "90979", "89251", "89263", "92126", "92158", "92175", "92283", "91879", "92110", "89072", "90618", "90401", "90104", "91103", "91332", "91965", "89786", "90462", "89895", "91229", "89318", "91656", "91578", "92132", "92130", "92186", "89778", "89990", "90553", "88787", "88625", "91826", "92101", "89376", "89167", "90749", "90959", "89714", "91202", "89050", "89313", "89338", "91411", "90321", "88662", "91093", "91575", "90864", "91785", "90430", "90970", "89809", "91144", "90375", "91493", "90065", "92179", "92224", "92229", "92307", "89162", "91057", "90181", "90482", "89622", "90703", "89034", "89557", "90070", "91658", "90847", "90757", "90623", "92156", "89024", "89194", "90935", "91297", "89874", "91549", "91350", "90604", "89136", "91256", "91540", "88671", "90343", "90248", "90620", "88860", "89244", "90921", "88616", "89084", "91778", "91546", "91662", "89518", "92168", "88717", "90712", "92166", "91956", "92142", "89562", "89911", "89447", "91665", "90300", "89866", "91338", "89733", "91589", "90342", "90026", "90291", "88683", "90404", "89543", "90075", "88621", "89659", "90337", "91187", "92014", "90280", "91815", "90463", "89165", "88819", "90041", "89461", "91887", "90504", "91848", "90972", "91201", "91468", "90597", "90908", "91331", "90842", "89810", "91184", "89283", "88824", "89869", "91379", "90508", "89377", "91220", "90684", "90477", "91675", "89087", "90466", "91454", "90211", "92077", "91819", "88696", "91508", "90879", "89329", "90958", "88771", "89323", "89148", "91542", "89896", "90055", "89146", "89408", "88620", "90399", "91874", "91058", "91960", "89021", "89886", "89381", "91899", "89534", "89195", "89285", "89898", "92114", "88879", "89679", "90833", "89114", "92062", "89496", "89912", "89422", "91303", "90894", "91143", "91380", "88677", "89015", "89561", "91031", "91456", "89342", "88970", "90767", "90697", "92072", "90445", "91349", "91685", "89687", "91555", "91671", "91157", "90926", "91976", "89188", "91727", "89454", "88661", "91095", "90406", "89217", "88630", "89398", "90441", "90503", "91992", "89210", "90440", "91605", "92091", "90652", "91335", "91235", "89198", "89985", "89259", "91455", "89727", "89528", "91554", "91670", "91973", "89503", "91559", "89388", "89918", "89666", "91014", "90480", "91521", "88877", "89242", "88713", "88872", "89640", "89880", "91453", "92150", "90647", "90022", "89325", "90367", "89288", "90446", "92115", "89506", "91783", "90254", "90910", "88799", "91647", "90589", "91330", "90038", "90033", "91451", "92030", "88927", "90470", "89380", "89599", "88632", "90798", "91043", "91857", "89116", "92284", "91959", "91384", "90902", "89335", "89163", "89046", "90192", "89501", "91951", "91310", "90353", "88788", "89033", "91924", "90846", "89230", "91591", "91799", "90434", "90358", "88977", "92232", "92235", "90244", "89345", "89850", "88962", "89583", "88822", "91794", "91516", "90435", "89299", "89715", "91948", "90515", "92137", "88757", "92127", "89967", "92253", "92257", "89153", "90541", "90685", "89632", "89972", "91035", "92321", "89101", "92185", "89637", "90824", "88642", "90051", "92287", "92298", "89185", "89241", "88858", "89316", "92111", "89578", "89100", "91257", "91859", "89922", "92033", "89656", "89326", "91146", "89511", "89867", "90524", "89402", "91458", "92292", "88880", "90422", "90507", "89551", "89260", "91300", "91307", "89973", "89312", "91457", "90311", "88645", "88651", "90067", "90787", "89751", "92250", "89463", "91383", "91517", "92054", "91158", "92079", "91988", "90066", "92067", "88678", "89950", "90862", "89520", "91478", "89157", "89233", "90432", "90514", "90752", "89038", "89526", "89369", "90044", "89258", "91381", "89469", "91937", "91365", "89650", "90259", "88968", "90574", "91293", "92174", "91800", "89871", "88667", "88801", "88848", "88709", "91801", "92109", "90307", "91603", "91716", "90330", "88885", "89284", "89320", "90072", "90633", "89584", "91033", "91120", "89541", "90015", "91333", "91159", "91821", "89340", "90987", "89549", "89582", "91964", "90659", "92225", "90425", "88926", "90057", "88669", "89970", "92328", "90849", "90934", "90341", "88663", "91872", "89920", "89031", "91929", "88996", "88674", "90201", "91802", "89367", "91366", "88691", "91577", "89207", "90062", "90766", "91424", "91334", "89944", "91427", "91687", "89542", "89143", "90159", "89576", "91417", "91729", "89036", "88856", "88823", "91898", "91317", "92262", "92161", "89055", "90256", "89484", "88706", "91968", "90632", "91562", "88847", "89324", "92138", "89270", "90928", "92008", "92002", "89937", "90069", "90914", "90413", "90856", "89773", "89306", "89865", "90733", "92330", "92102", "92125", "89443", "89297", "92190", "92208", "92217", "89952", "92323", "91530", "92143", "92157", "92268", "89849", "90572", "90728", "89092", "91135", "92170", "91309", "91429", "89137", "89208", "90977", "90922", "89346", "89060", "90056", "89550", "91836", "88818", "89272", "90607", "91245", "89426", "89799", "89907", "92289", "90319", "91421", "89218", "89236", "90014", "91096", "89409", "89186", "88804", "91838", "90646", "90919", "91294", "91837", "90252", "90437", "91188", "89389", "91452", "92096", "90853", "91511", "89056", "89989", "88656", "89213", "89429", "88969", "88934", "92336", "91620", "88631", "88777", "89052", "90501", "91678", "90149", "90714", "89837", "91917", "92116", "92129", "88849", "92254", "91099", "88820", "90530", "89848", "89744", "92056", "91434", "90598", "91062", "92302", "90651", "89264", "89290", "90994", "91818", "89204", "89344", "91619", "90517", "92012", "88685", "92089", "91200", "90769", "89169", "89068", "91404", "91329", "89706", "90421", "90203", "91556", "89435", "91518", "90431", "91633", "90410", "90763", "91621", "88805", "89625", "91672", "90207", "90346", "89231", "91197", "89483", "88675", "91376", "90308", "90205", "91101", "91793", "90400", "92205", "90332", "92279", "89533", "91856", "89498", "90426", "89343", "91602", "90245", "89047", "89537", "91412", "89073", "88670", "91193", "89319", "88687", "91347", "90865", "89289", "92291", "91296", "89968", "91299", "89450", "89005", "91792", "92247", "89317", "89717", "89196", "92258", "89351", "90034", "90325", "90340", "89745", "90347", "88867", "90424", "88668", "89069", "92220", "91991", "89061", "89437", "89043", "91787", "89540", "90361", "89302", "89184", "88700", "88861", "91684", "91699", "90042", "90693", "91930", "89082", "90359", "89079", "91938", "88753", "90596", "91592", "89787", "90063", "90843", "89587", "89314", "89062", "89390", "89646", "89427", "90348", "89067", "90294", "90691", "90588", "90281", "89555", "91547", "92029", "89070", "88813", "92001", "89445", "89507", "91152", "91205", "89243", "89117", "91443", "89802", "89530", "89154", "91312", "91441", "90882", "90074", "89219", "91459", "88767", "89102", "90292", "89535", "91963", "92028", "89131", "92057", "91632", "90660", "89126", "92223", "92228", "89181", "89095", "92164", "89532", "91336", "89721", "91910", "90293", "89145", "91171", "91548", "89341", "91663", "92203", "91066", "90801", "90796", "89029", "91840", "88641", "89132", "88701", "88862", "90372", "92324", "90350", "89482", "89404", "90755", "88644", "88650", "89430", "92265", "91183", "90210", "92333", "89750", "91795", "88935", "90606", "89327", "89573", "89899", "91054", "88659", "91368", "90701", "88763", "90878", "90600", "92286", "89352", "89211", "90273", "90436", "91970", "91413", "89502", "91865", "88761", "90059", "89080", "91696", "88775", "91408", "89094", "91623", "89490", "88901", "91717", "89411", "92276", "88800", "90320", "91520", "91227", "89096", "89410", "92269", "92159", "91850", "90999", "90603", "91355", "88802", "89173", "91378", "89470", "89232", "90621", "89581", "89175", "90402", "89032", "89639", "90601", "91827", "92066", "89524", "90242", "89564", "89458", "89057", "89467", "89090", "88686", "92341", "89053", "91886", "89274", "92243", "91100", "90423", "92082", "92088", "90334", "88774", "90076", "90043", "92019", "91813", "92163", "91306", "89732", "91032", "91724", "89736", "91232", "89572", "88829", "89521", "89961", "91998", "92104", "92148", "92273", "91664", "89180", "89444", "88796", "88833", "91023", "89440", "89216", "92085", "91731", "88746", "90631", "90408", "91228", "91071", "88743", "91198", "92310", "88832", "91444", "89177", "89493", "89941", "91142", "92280", "90625", "89499", "91420", "89512", "90626", "92261", "90416", "92195", "92213", "88742", "92171", "88733", "89089", "89575", "88752", "89368", "90272", "89516", "88756", "89396", "89464", "91476", "88759", "91786", "89423", "89492", "91428", "91527", "89280", "92131", "90917", "89037", "88666", "89275", "90324", "92182", "92306", "90943", "89808", "90414", "89741", "90403", "89442", "91094", "90412", "91231", "91950", "91226", "92344", "90411", "91703", "91524", "89395", "89222", "92167", "89838", "91509", "91877", "90449", "90048", "89044", "89394", "91931", "88762", "88688", "90017", "89943", "90857", "90996", "89485", "92178", "91919", "90880", "90150", "89481", "91849", "91553", "88658", "92112", "89725", "88841", "89839", "89508", "88766", "91876", "89489", "91065", "90327", "90602", "90867", "90240", "88842", "88748", "91669", "91050", "92070", "88831", "89480", "91922", "92272", "91932", "91067", "89517", "92065", "89026", "88765", "89140", "89569", "89585", "91407", "90054", "90200", "89735", "90997", "91969", "88846", "88731", "91431", "89400", "89459", "89487", "88737", "88840", "89554", "89254", "92299", "88747", "91789", "89040", "89734", "90415", "89971", "90417", "90064", "88738", "92144", "91525", "91947", "88736", "89174", "90152", "92060", "90160", "90629", "89441", "90617", "90875", "90628", "88830", "89497", "89438", "92192", "92219", "92303", "89439", "88734", "88744", "91026", "90439", "92136", "89529", "92108", "92210", "88755", "92107", "89986", "90349", "90911", "89466", "92099", "92122", "90848", "90615", "88902", "91921", "88778", "89384", "91788", "91875", "89509", "89115", "92094", "92147", "88732", "89504", "89028", "92199", "89170", "90418", "92059", "89049", "92058", "92064", "90868", "90407", "90619", "92151", "92191", "92209", "92218", "91234", "92113", "89514", "88655", "88735", "91024", "88795", "90345", "89158", "89019", "92295", "89187", "90622", "90627", "90915", "88828", "89183", "89171", "88665", "89119", "89500", "89505", "89018", "91920", "89403", "88745", "92098", "92134", "89468", "89387", "89397", "89597", "89385", "90420", "89567", "89393", "92121", "92204", "92140", "90405", "89178", "89375", "91618", "89383", "92061", "91835", "92069", "91225", "89552", "89491", "89386", "89051", "88825", "90253", "88754", "90881", "90869", "92068", "92117", "92103", "91422", "89510", "89495", "90368", "89531", "89399", "88760", "88827", "89405", "89547", "89601", "90870", "92063", "88764"]], "embeddings": null, "documents": [["            }\r\n        }\r\n    }\r\n\r\n    /**\r\n", "    }\r\n\r\n    /**\r\n     * Encode the extras.\r\n     *\r\n", "            }\r\n        };\r\n    }\r\n\r\n    /**\r\n", "        }\r\n    }\r\n\r\n    /**\r\n     * Takes ownership of passed envelope\r\n", "    }\r\n\r\n    /**\r\n     * Prepare for next decoding iteration.\r\n     */\r\n", "            }\r\n        }\r\n    }\r\n\r\n    @Test\r\n", "                }\r\n            };\r\n        }\r\n    }\r\n\r\n", "                // expected\r\n            }\r\n        }\r\n    }\r\n\r\n", "\r\n        /**\r\n         * Currently reading the extras portion (optional).\r\n         */\r\n        READ_EXTRAS,\r\n", "    }\r\n\r\n    /**\r\n     * Sets the cache for authoritative NS servers\r\n     *\r\n", "                    });\r\n                }\r\n            }\r\n        }\r\n\r\n", "                }\r\n            }\r\n            return;\r\n        }\r\n\r\n", "                } else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n", "    }\r\n\r\n    /**\r\n     * Creates a new context with the given parameters.\r\n     */\r\n", "    /**\r\n     * Returns the total body length.\r\n     * <p/>\r\n     * Note that this may be 0, since the body is optional.\r\n     *\r\n", "     * Contains the optional extras.\r\n     */\r\n    private ByteBuf extras;\r\n\r\n    private byte magic;\r\n", "                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n", "     * <p/>\r\n     * This may return 0, since the key is optional.\r\n     *\r\n     * @return the key length.\r\n     */\r\n", "        }\r\n\r\n        return list;\r\n    }\r\n\r\n", "\r\n    /**\r\n     * Set the extras length of the message.\r\n     * <p/>\r\n     * This may be 0, since the extras content is optional.\r\n", "     * Contains the optional key.\r\n     */\r\n    private ByteBuf key;\r\n\r\n    /**\r\n", "        }\r\n        return cached;\r\n    }\r\n\r\n    /**\r\n", "\r\n        /**\r\n         * Currently reading the key portion (optional).\r\n         */\r\n        READ_KEY,\r\n", "\r\n    /**\r\n     * Sets the magic byte.\r\n     *\r\n     * @param magic the magic byte to use.\r\n", "\r\n        /**\r\n         * Something went wrong while decoding the message or chunks.\r\n         */\r\n        BAD_MESSAGE\r\n", "     * <p/>\r\n     * This may be 0, since the key is optional.\r\n     *\r\n     * @param keyLength the key length to use.\r\n     */\r\n", "            return address;\r\n        }\r\n    }\r\n\r\n    /**\r\n", "    }\r\n\r\n    /**\r\n     * Returns all caches entries for the given hostname.\r\n     */\r\n", "            }\r\n\r\n            return true;\r\n        }\r\n\r\n", "\r\n    /**\r\n     * Clears all cached nameservers.\r\n     *\r\n     * @see #clear(String)\r\n", "                    out.write(buf);\r\n                }\r\n            };\r\n        }\r\n\r\n", "\r\n    /**\r\n     * Sets the opcode for the message.\r\n     *\r\n     * @param code the opcode to use.\r\n", "    }\r\n\r\n    /**\r\n     * Resolves the specified host name and port into a list of address.\r\n     *\r\n", "     * @see #clear(String)\r\n     */\r\n    void clear();\r\n\r\n    /**\r\n", "     * Returns the magic byte for the message.\r\n     *\r\n     * @return the magic byte.\r\n     */\r\n    byte magic();\r\n", "     * Returns the opcode for the message.\r\n     *\r\n     * @return the opcode.\r\n     */\r\n    byte opcode();\r\n", "                                nameServerCount++;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n", "            extras.touch(hint);\r\n        }\r\n        return this;\r\n    }\r\n\r\n", "                        return message;\r\n                    }\r\n                }\r\n                return message;\r\n            }\r\n", "\r\n    /**\r\n     * Resolves the specified name into an address.\r\n     *\r\n     * @param inetHost the name to resolve\r\n", "    }\r\n\r\n    /**\r\n     * Returns {@code true} if this entry should replace all other entries that are already cached for the hostname.\r\n     */\r\n", "     *\r\n     * @see #clear(String)\r\n     */\r\n    void clear();\r\n\r\n", "\r\n    private static final int INADDRSZ4 = 4;\r\n    private static final int INADDRSZ6 = 16;\r\n\r\n    /**\r\n", "     * Sets the total body length.\r\n     * <p/>\r\n     * Note that this may be 0, since the body length is optional.\r\n     *\r\n     * @param totalBodyLength the total body length.\r\n", "\r\n    /**\r\n     * The number of dots which must appear in a name before an initial absolute query is made.\r\n     * The default value is {@code 1}.\r\n     */\r\n", "    /**\r\n     * Sets the opaque value.\r\n     *\r\n     * @param opaque the opaque value to use.\r\n     */\r\n", "     *\r\n     * @param minTtl the minimum TTL\r\n     * @param maxTtl the maximum TTL\r\n     * @return {@code this}\r\n     */\r\n", "                            \" missing response(s)\"));\r\n                }\r\n            }\r\n        }\r\n    }\r\n", "\r\n/**\r\n * Common superset of ascii and binary classes.\r\n */\r\n@UnstableApi\r\n", "     * @return the optional extras.\r\n     */\r\n    ByteBuf extras();\r\n\r\n    /**\r\n", "                            }\r\n                        }\r\n                    }\r\n                    buf.flip();\r\n\r\n", "    }\r\n\r\n    /**\r\n     * Sends a DNS query with the specified question with additional records.\r\n     */\r\n", "    }\r\n\r\n    /**\r\n     * Returns the minimum TTL of the cached DNS resource records (in seconds).\r\n     *\r\n", "            }\r\n        }\r\n\r\n        // Now handle all AuthoritativeNameServer for which we had no ADDITIONAL record\r\n        void handleWithoutAdditionals(\r\n", "     */\r\n    private static final class AuthoritativeNameServerList {\r\n\r\n        private final String questionName;\r\n\r\n", "    }\r\n\r\n    /**\r\n     * Sends a DNS query with the specified question using the specified name server list.\r\n     */\r\n", "    }\r\n\r\n    /**\r\n     * Sends a DNS query with the specified question using the specified name server list.\r\n     */\r\n", "                    out.write(message);\r\n                }\r\n            };\r\n        }\r\n\r\n", "     * @return the CAS identifier.\r\n     */\r\n    long cas();\r\n\r\n    /**\r\n", "                    line = line.trim();\r\n                    try {\r\n                        char c;\r\n                        if (line.isEmpty() || (c = line.charAt(0)) == '#' || c == ';') {\r\n                            continue;\r\n", "     * Resolves the specified name into an address.\r\n     *\r\n     * @param inetHost the name to resolve\r\n     * @param additionals additional records ({@code OPT})\r\n     *\r\n", "            }\r\n            return addressList;\r\n        }\r\n    }\r\n\r\n", "    }\r\n\r\n    /**\r\n     * Sends a DNS query with the specified question with additional records using the specified name server list.\r\n     */\r\n", "    }\r\n\r\n    /**\r\n     * Sends a DNS query with the specified question with additional records using the specified name server list.\r\n     */\r\n", "     * This may be 0, since the extras content is optional.\r\n     *\r\n     * @return the extras length.\r\n     */\r\n    byte extrasLength();\r\n", "/**\r\n * Abstract cache that automatically removes entries for a hostname once the TTL for an entry is reached.\r\n *\r\n * @param <E>\r\n */\r\n", "\r\n        private long ttl;\r\n        private InetSocketAddress address;\r\n\r\n        AuthoritativeNameServer next;\r\n", "        }\r\n\r\n        /**\r\n         * Returns {@code true} if its a root server.\r\n         */\r\n", "\r\n        /**\r\n         * Currently reading the value chunks (optional).\r\n         */\r\n        READ_CONTENT,\r\n", "    short reserved();\r\n\r\n    /**\r\n     * Sets the reserved field value.\r\n     *\r\n", "                    break;\r\n                }\r\n            }\r\n\r\n            if (!matches) {\r\n", "     */\r\n    public AuthoritativeDnsServerCache authoritativeDnsServerCache() {\r\n        return authoritativeDnsServerCache;\r\n    }\r\n\r\n", "    short status();\r\n\r\n    /**\r\n     * Sets the status of the response.\r\n     *\r\n", "    }\r\n\r\n  /**\r\n   * Set the number of dots which must appear in a name before an initial absolute query is made.\r\n   * The default value is {@code 1}.\r\n", "    int ndots() {\r\n        return ndots;\r\n    }\r\n\r\n    /**\r\n", "    /**\r\n     * Returns the reserved field value.\r\n     *\r\n     * @return the reserved field value.\r\n     */\r\n", "                                // Need to try again as CAS failed\r\n                                continue;\r\n                            }\r\n                        }\r\n\r\n", "        }\r\n    }\r\n\r\n    /**\r\n     * Helper method to create a message indicating a invalid decoding result.\r\n", "\r\n        AuthoritativeNameServer(int dots, long ttl, String domainName, String nsName) {\r\n            this.dots = dots;\r\n            this.ttl = ttl;\r\n            this.nsName = nsName;\r\n", "    /**\r\n     * Returns the status of the response.\r\n     *\r\n     * @return the status of the response.\r\n     */\r\n", " * A cache for {@code CNAME}s.\r\n */\r\npublic interface DnsCnameCache {\r\n\r\n    /**\r\n", "    /**\r\n     * This test makes sure that even when more requests arrive in the same batch, they\r\n     * get emitted as separate messages.\r\n     */\r\n    @Test\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n", "        }\r\n        return next;\r\n    }\r\n\r\n    @Override\r\n", "                    }\r\n                }\r\n            }\r\n        } finally {\r\n            if (br == null) {\r\n", "     *\r\n     * @return the opaque value.\r\n     */\r\n    int opaque();\r\n\r\n", "/**\r\n * An infinite stream of DNS server addresses.\r\n */\r\npublic interface DnsServerAddressStream {\r\n    /**\r\n", "\r\n    /**\r\n     * Set if domain / host names should be decoded to unicode when received.\r\n     * See <a href=\"https://tools.ietf.org/html/rfc3492\">rfc3492</a>.\r\n     *\r\n", "\r\n/**\r\n * The decoder which takes care of decoding the response headers.\r\n */\r\n@UnstableApi\r\n", "            // Should never reach here.\r\n            throw new Error(e);\r\n        }\r\n    }\r\n\r\n", "        }\r\n    }\r\n\r\n    private boolean hasNDots() {\r\n        for (int idx = hostname.length() - 1, dots = 0; idx >= 0; idx--) {\r\n", "        }\r\n    }\r\n\r\n    /**\r\n     * Holds the closed DNS Servers for a domain.\r\n", "            }\r\n\r\n            @Override\r\n            public void clear() {\r\n                // NOOP\r\n", "            }\r\n\r\n            @Override\r\n            public void clear() {\r\n                // NOOP\r\n", "    short keyLength();\r\n\r\n    /**\r\n     * Return the extras length of the message.\r\n     * <p/>\r\n", "     */\r\n    int attempts() {\r\n        return attempts;\r\n    }\r\n\r\n", "\r\n            int dots = 0;\r\n            for (int a = recordName.length() - 1, b = questionName.length() - 1; a >= 0; a--, b--) {\r\n                char c = recordName.charAt(a);\r\n                if (questionName.charAt(b) != c) {\r\n", "        BYTES.put(\"0:0:0:0:0:1:1:1\", new byte[]{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1});\r\n        BYTES.put(\"0:0:0:0:1:1:1:1\", new byte[]{0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1});\r\n        BYTES.put(\"0:0:0:1:1:1:1:1\", new byte[]{0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1});\r\n        BYTES.put(\"0:0:1:1:1:1:1:1\", new byte[]{0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1});\r\n        BYTES.put(\"0:1:1:1:1:1:1:1\", new byte[]{0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1});\r\n", " */\r\npublic class DefaultAuthoritativeDnsServerCache implements AuthoritativeDnsServerCache {\r\n\r\n    private final int minTtl;\r\n    private final int maxTtl;\r\n", "\r\n    /**\r\n     * Returns the {@link DnsCnameCache}.\r\n     */\r\n    DnsCnameCache cnameCache() {\r\n", "                                       promise, queryCause);\r\n                }\r\n            }\r\n        });\r\n    }\r\n", "     */\r\n    public int maxTtl() {\r\n        return maxTtl;\r\n    }\r\n\r\n", "    }\r\n\r\n    /**\r\n     * The list of the domain names to exclude from {@link #testQueryMx()}.\r\n     */\r\n", "\r\n    /**\r\n     * Returns the maximum allowed number of DNS queries to send when resolving a host name.\r\n     * The default value is {@code 8}.\r\n     */\r\n", "            @Override\r\n            public void clear() {\r\n                // NOOP\r\n            }\r\n\r\n", "    @Override\r\n    public void clear() {\r\n        // NOOP\r\n    }\r\n\r\n", "     * @return the total body length.\r\n     */\r\n    int totalBodyLength();\r\n\r\n    /**\r\n", " * Represents all Opcodes that can occur in a {@link BinaryMemcacheMessage}.\r\n * <p/>\r\n * This class can be extended if a custom application needs to implement a superset of the normally supported\r\n * operations by a vanilla memcached protocol.\r\n */\r\n", "        }\r\n        return list;\r\n    }\r\n\r\n    @Test\r\n", "        RedirectAuthoritativeDnsServerCache(AuthoritativeDnsServerCache authoritativeDnsServerCache) {\r\n            this.wrapped = authoritativeDnsServerCache;\r\n        }\r\n\r\n        @Override\r\n", "            // Now flush everything we submitted before.\r\n            parent.flushQueries();\r\n        }\r\n    }\r\n\r\n", "/**\r\n * Combines {@link MemcacheMessage} and {@link LastMemcacheContent} into one\r\n * message. So it represent a <i>complete</i> memcache message.\r\n */\r\n@UnstableApi\r\n", "        };\r\n    }\r\n\r\n    /**\r\n     * Returns the {@link DnsServerAddresses} that yields the specified {@code addresses} in a rotational sequential\r\n", "     * <p/>\r\n     * Note that most of the states can be optional, the only one required is reading\r\n     * the header ({@link #READ_HEADER}. All other steps depend on the length fields\r\n     * in the header and will be executed conditionally.\r\n     */\r\n", "            \"bing.com\",\r\n            \"ok.ru\",\r\n            \"imgur.com\",\r\n            \"microsoft.com\",\r\n            \"mail.ru\",\r\n", "\r\n/**\r\n * A noop {@link AuthoritativeDnsServerCache} that actually never caches anything.\r\n */\r\npublic final class NoopAuthoritativeDnsServerCache implements AuthoritativeDnsServerCache {\r\n", "        checkNotNull(cause, \"cause\");\r\n        checkNotNull(loop, \"loop\");\r\n\r\n        DefaultDnsCacheEntry e = new DefaultDnsCacheEntry(hostname, cause);\r\n        if (negativeTtl == 0 || !emptyAdditionals(additionals)) {\r\n", "     * last address is yielded, it will start again from the first address.\r\n     */\r\n    public static DnsServerAddresses sequential(InetSocketAddress... addresses) {\r\n        return sequential0(sanitize(addresses));\r\n    }\r\n", "        }\r\n    }\r\n\r\n    @Test\r\n    public void testCNAMERecursiveResolveMultipleNameServersIPv4() throws IOException {\r\n", "        }\r\n\r\n        // Should not reach here.\r\n        throw new Error();\r\n    }\r\n", "\r\n    private final List<InetSocketAddress> addresses;\r\n    private int i;\r\n\r\n    /**\r\n", "                            int x = indexOfWhiteSpace(line, i);\r\n                            if (x == -1) {\r\n                                maybeIP = line.substring(i);\r\n                            } else {\r\n                                // ignore comments\r\n", "     * @param maxTtl the maximum TTL\r\n     */\r\n    public DefaultDnsCnameCache(int minTtl, int maxTtl) {\r\n        this.minTtl = Math.min(Cache.MAX_SUPPORTED_TTL_SECS, checkPositiveOrZero(minTtl, \"minTtl\"));\r\n        this.maxTtl = Math.min(Cache.MAX_SUPPORTED_TTL_SECS, checkPositive(maxTtl, \"maxTtl\"));\r\n", "\r\n        /**\r\n         * Returns {@code true} if empty, {@code false} otherwise.\r\n         */\r\n        boolean isEmpty() {\r\n", "                //\r\n                //                3               Name Error - Meaningful only for\r\n                //                                responses from an authoritative name\r\n                //                                server, this code signifies that the\r\n                //                                domain name referenced in the query does\r\n", "\r\n    /**\r\n     * Returns the maximum TTL of the cached DNS resource records (in seconds).\r\n     *\r\n     * @see #minTtl()\r\n", "    }\r\n\r\n    private static final class RedirectAuthoritativeDnsServerCache implements AuthoritativeDnsServerCache {\r\n        private final AuthoritativeDnsServerCache wrapped;\r\n\r\n", "        }\r\n    }\r\n\r\n    @Override\r\n    public void clear() {\r\n", "        testCNAMERecursiveResolveMultipleNameServers(false);\r\n    }\r\n\r\n    private static void testCNAMERecursiveResolveMultipleNameServers(boolean ipv4Preferred) throws IOException {\r\n        final String firstName = \"firstname.nettyfoo.com\";\r\n", "                }\r\n                buf.release();\r\n            }\r\n        }\r\n    }\r\n", "\r\n/**\r\n * The decoder part which takes care of decoding the request-specific headers.\r\n */\r\n@UnstableApi\r\n", "\r\n    /**\r\n     * Returns the data type of the message.\r\n     *\r\n     * @return the data type of the message.\r\n", "\r\n    /**\r\n     * Caches a nameserver that should be used to resolve the given hostname.\r\n     *\r\n     * @param hostname the hostname\r\n", " */\r\npublic class DnsNameResolverException extends RuntimeException {\r\n\r\n    private static final long serialVersionUID = -8826717909627131850L;\r\n\r\n", "     * and doesn't cache negative responses.\r\n     */\r\n    public DefaultDnsCache() {\r\n        this(0, Cache.MAX_SUPPORTED_TTL_SECS, 0);\r\n    }\r\n", "import java.util.Random;\r\n\r\nimport static io.netty.handler.codec.spdy.SpdyCodecUtil.SPDY_HEADER_SIZE;\r\nimport static org.junit.Assert.*;\r\nimport static org.mockito.Mockito.*;\r\n", "                    buf.append('\\t');\r\n                    buf.append(r.name());\r\n                    buf.append(' ');\r\n                    buf.append(r.type().name());\r\n                    buf.append(' ');\r\n", "        boolean isRootServer() {\r\n            return dots == 1;\r\n        }\r\n\r\n        /**\r\n", " * with the limitation that {@link InetSocketAddress#equals(Object)} will not result in the same return value as\r\n * {@link #compare(InetSocketAddress, InetSocketAddress)}. This is completely fine as this should only be used\r\n * to sort {@link List}s.\r\n */\r\npublic final class NameServerComparator implements Comparator<InetSocketAddress>, Serializable {\r\n", "            }\r\n        }\r\n    }\r\n\r\n    private static String appendDot(String hostname) {\r\n", "                    break;\r\n                }\r\n            }\r\n        } finally {\r\n            if (br == null) {\r\n", "    }\r\n\r\n    /**\r\n     * Sets the cache for {@code CNAME} mappings.\r\n     *\r\n", "package io.netty.resolver.dns;\r\n\r\nimport io.netty.channel.EventLoop;\r\n\r\npublic final class NoopDnsCnameCache implements DnsCnameCache {\r\n", "                break;\r\n            }\r\n        }\r\n\r\n        if (found) {\r\n", "     * When the channel goes inactive, release all frames to prevent data leaks.\r\n     *\r\n     * @param ctx handler context\r\n     * @throws Exception\r\n     */\r\n", "    /**\r\n     * Remove everything from the cache.\r\n     */\r\n    final void clear() {\r\n        while (!resolveCache.isEmpty()) {\r\n", "                // Could not be parsed, ignore.\r\n                return;\r\n            }\r\n\r\n            // We are only interested in preserving the nameservers which are the closest to our qName, so ensure\r\n", "            this.domainName = domainName;\r\n            isCopy = false;\r\n        }\r\n\r\n        AuthoritativeNameServer(AuthoritativeNameServer server) {\r\n", "\r\n    /**\r\n     * Increases the reference count by {@code 1}.\r\n     */\r\n    @Override\r\n", "import static org.junit.Assert.*;\r\n\r\n\r\npublic class NameServerComparatorTest {\r\n\r\n", "\r\nimport java.net.InetAddress;\r\nimport java.net.InetSocketAddress;\r\n\r\n/**\r\n", "\r\n    private final DnsCache resolveCache;\r\n    private final AuthoritativeDnsServerCache authoritativeDnsServerCache;\r\n    private final boolean completeEarlyIfPossible;\r\n\r\n", "     */\r\n    boolean clear(String hostname);\r\n\r\n    /**\r\n     * Return the cached entries for the given hostname.\r\n", "    }\r\n\r\n    InetSocketAddress nameServerAddr() {\r\n        return nameServerAddr;\r\n    }\r\n", "     * @param authoritativeDnsServerCache the authoritative NS servers cache\r\n     * @return {@code this}\r\n     */\r\n    public DnsNameResolverBuilder authoritativeDnsServerCache(AuthoritativeDnsServerCache authoritativeDnsServerCache) {\r\n        this.authoritativeDnsServerCache = authoritativeDnsServerCache;\r\n", "    }\r\n\r\n    @Override\r\n    protected boolean isContentLengthInvalid(H start, int maxContentLength) {\r\n        return false;\r\n", "     * Clears the cached nameservers for the specified hostname.\r\n     *\r\n     * @return {@code true} if and only if there was an entry for the specified host name in the cache and\r\n     *         it has been removed by this method\r\n     */\r\n", "\r\n                    buf.append(StringUtil.NEWLINE);\r\n                    buf.append('\\t');\r\n                    buf.append(r.name());\r\n                    buf.append(' ');\r\n", "     *\r\n     * @return {@code true} if and only if there was an entry for the specified host name in the cache and\r\n     *         it has been removed by this method\r\n     */\r\n    boolean clear(String hostname);\r\n", "\r\n    /**\r\n     * Returns a filtered list of results which should be the final result of DNS resolution. This must take into\r\n     * account JDK semantics such as {@link NetUtil#isIpV6AddressesPreferred()}.\r\n     */\r\n", "    }\r\n\r\n    @Override\r\n    public void clear() {\r\n    }\r\n", "import static org.hamcrest.Matchers.greaterThan;\r\nimport static org.hamcrest.Matchers.hasSize;\r\nimport static org.hamcrest.Matchers.instanceOf;\r\nimport static org.hamcrest.Matchers.is;\r\nimport static org.junit.Assert.*;\r\n", "     * Sets the cache for authoritative NS servers\r\n     *\r\n     * @param authoritativeDnsServerCache the authoritative NS servers cache\r\n     * @return {@code this}\r\n     * @deprecated Use {@link #authoritativeDnsServerCache(AuthoritativeDnsServerCache)}\r\n", "        return negativeTtl;\r\n    }\r\n\r\n    @Override\r\n    public void clear() {\r\n", "    private static final class AuthoritativeNameServer {\r\n        private final int dots;\r\n        private final String domainName;\r\n        final boolean isCopy;\r\n        final String nsName;\r\n", "    private static List<InetSocketAddress> sanitize(InetSocketAddress[] addresses) {\r\n        ObjectUtil.checkNotNull(addresses, \"addresses\");\r\n\r\n        List<InetSocketAddress> list = new ArrayList<InetSocketAddress>(addresses.length);\r\n        for (InetSocketAddress a: addresses) {\r\n", "                        // Search for the last we insert before and then append a new one.\r\n                        while (serverName.next != null && serverName.next.isCopy) {\r\n                            serverName = serverName.next;\r\n                        }\r\n                        AuthoritativeNameServer server = new AuthoritativeNameServer(serverName);\r\n", "                } else {\r\n                    br.close();\r\n                }\r\n            }\r\n        }\r\n", "    @Override\r\n    public short reserved() {\r\n        return reserved;\r\n    }\r\n\r\n", "     */\r\n    public DefaultAuthoritativeDnsServerCache() {\r\n        this(0, Cache.MAX_SUPPORTED_TTL_SECS, null);\r\n    }\r\n\r\n", "    /**\r\n     * Returns the {@link DnsServerAddresses} that yields the specified {@code addresses} sequentially. Once the\r\n     * last address is yielded, it will start again from the first address.\r\n     */\r\n    public static DnsServerAddresses sequential(Iterable<? extends InetSocketAddress> addresses) {\r\n", "     */\r\n    void clear();\r\n\r\n    /**\r\n     * Clears the cached nameservers for the specified hostname.\r\n", "\r\n    /**\r\n     * Helper method to create a content chunk indicating a invalid decoding result.\r\n     *\r\n     * @param cause the cause of the decoding failure.\r\n", "     */\r\n    BinaryMemcacheMessage setTotalBodyLength(int totalBodyLength);\r\n\r\n    /**\r\n     * Returns the opaque value.\r\n", "        }\r\n    }\r\n\r\n    /**\r\n     * Sets the list of the protocol families of the address resolved.\r\n", "            dots = server.dots;\r\n            ttl = server.ttl;\r\n            nsName = server.nsName;\r\n            domainName = server.domainName;\r\n            isCopy = true;\r\n", "        } finally {\r\n            in.resetReaderIndex();\r\n        }\r\n    }\r\n\r\n", "\r\n    /**\r\n     * Create a cache.\r\n     * @param minTtl the minimum TTL\r\n     * @param maxTtl the maximum TTL\r\n", "                is(\" Rocks!\")\r\n        );\r\n        written.release();\r\n    }\r\n\r\n", "        }\r\n    }\r\n\r\n    private boolean mayOverrideNameServers() {\r\n        return !domainToNameServerStreamMap.isEmpty() || defaultNameServerAddresses.stream().next() != null;\r\n", "/*\r\n * Copyright 2013 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2013 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2013 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2013 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2013 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2013 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2013 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2013 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2013 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2013 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2013 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2013 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2013 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2013 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2013 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2013 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2013 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2013 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2013 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2013 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2013 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2013 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2013 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2013 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2013 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2013 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2013 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2013 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2013 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2013 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2013 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2013 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2013 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2013 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2013 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2013 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2013 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "    }\r\n\r\n    private static final class NoopDnsCacheEntry implements DnsCacheEntry {\r\n        private final InetAddress address;\r\n\r\n", "        0x00, 0x00, 0x00, 0x0B,\r\n        0x00, 0x00, 0x00, 0x00,\r\n        0x00, 0x00, 0x00, 0x00,\r\n        0x00, 0x00, 0x00, 0x00,\r\n        0x66, 0x6f, 0x6f,\r\n", "\r\n    /**\r\n     * This tests a simple GET request with a key as the value.\r\n     */\r\n    @Test\r\n", "\r\n        // Check if we have answers, if not this may be an non authority NS and so redirects must be handled.\r\n        if (res.count(DnsSection.ANSWER) == 0) {\r\n            AuthoritativeNameServerList serverNames = extractAuthoritativeNameServers(question.name(), res);\r\n            if (serverNames != null) {\r\n", "     * Retrieves the next DNS server address from the stream.\r\n     */\r\n    InetSocketAddress next();\r\n\r\n    /**\r\n", "                                i = maybeIP.lastIndexOf('.');\r\n                                if (i + 1 >= maybeIP.length()) {\r\n                                    throw new IllegalArgumentException(\"error parsing label \" + NAMESERVER_ROW_LABEL +\r\n                                            \" in file \" + etcResolverFile + \". invalid IP value: \" + line);\r\n                                }\r\n", "                       final int nameServerAddrStreamIndex,\r\n                       final DnsQuestion question,\r\n                       final DnsQueryLifecycleObserver queryLifecycleObserver,\r\n                       final boolean flush,\r\n                       final Promise<List<T>> promise,\r\n", "package io.netty.resolver.dns;\r\n\r\nimport io.netty.channel.EventLoopGroup;\r\nimport io.netty.channel.nio.NioEventLoopGroup;\r\nimport io.netty.channel.socket.nio.NioDatagramChannel;\r\n", "package io.netty.resolver.dns;\r\n\r\nimport io.netty.channel.EventLoopGroup;\r\nimport io.netty.channel.nio.NioEventLoopGroup;\r\nimport io.netty.channel.socket.nio.NioDatagramChannel;\r\n", "import java.net.InetAddress;\r\nimport java.util.Collections;\r\nimport java.util.List;\r\n\r\n/**\r\n", "    protected abstract boolean shouldReplaceAll(E entry);\r\n\r\n    /**\r\n     * Sort the {@link List} for a {@code hostname} before caching these.\r\n     */\r\n", "        testCNAMERecursiveResolveMultipleNameServers(true);\r\n    }\r\n\r\n    @Test\r\n    public void testCNAMERecursiveResolveMultipleNameServersIPv6() throws IOException {\r\n", "        testFollowNsRedirects(new DefaultDnsCache(), new DefaultAuthoritativeDnsServerCache(), true);\r\n    }\r\n\r\n    private void testFollowNsRedirects(DnsCache cache, AuthoritativeDnsServerCache authoritativeDnsServerCache,\r\n            final boolean invalidNsFirst) throws Exception {\r\n", "\r\n    /**\r\n     * Create a cache.\r\n     *\r\n     * @param minTtl the minimum TTL\r\n", "     * @param inetHost the name to resolve\r\n     * @param additionals additional records ({@code OPT})\r\n     *\r\n     * @return the list of the address as the result of the resolution\r\n     */\r\n", "                    } catch (IllegalArgumentException e) {\r\n                        logger.warn(\"Could not parse entry. Ignoring line: {}\", line, e);\r\n                    }\r\n                }\r\n                if (!addresses.isEmpty()) {\r\n", " * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations\r\n * under the License.\r\n */package io.netty.resolver.dns;\r\n", "            for (Iterator<Entry<String, Entries>> i = resolveCache.entrySet().iterator(); i.hasNext();) {\r\n                Map.Entry<String, Entries> e = i.next();\r\n                i.remove();\r\n\r\n                e.getValue().clearAndCancel();\r\n", "\r\n/**\r\n * A {@link AddressResolverGroup} of {@link DnsNameResolver}s.\r\n */\r\npublic class DnsAddressResolverGroup extends AddressResolverGroup<InetSocketAddress> {\r\n", "\r\n/**\r\n * A DNS-based {@link InetNameResolver}.\r\n */\r\npublic class DnsNameResolver extends InetNameResolver {\r\n", "     */\r\n    @Deprecated\r\n    public DnsNameResolverBuilder authoritativeDnsServerCache(DnsCache authoritativeDnsServerCache) {\r\n        this.authoritativeDnsServerCache = new AuthoritativeDnsServerCacheAdapter(authoritativeDnsServerCache);\r\n        return this;\r\n", "            }\r\n\r\n            for (int i = 0; i < CHARS.length; i++) {\r\n                CHARS[i] = (char) ('a' + i);\r\n            }\r\n", "/*\r\n * Copyright 2014 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2014 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2014 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2014 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2014 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2014 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2014 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2014 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2014 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "import io.netty.channel.nio.NioEventLoopGroup;\r\nimport io.netty.util.NetUtil;\r\nimport org.junit.Test;\r\n\r\nimport java.net.InetAddress;\r\n", "        String[] opts = WHITESPACE_PATTERN.split(line);\r\n        for (String opt : opts) {\r\n            try {\r\n                if (opt.startsWith(\"ndots:\")) {\r\n                    builder.setNdots(parseResIntOption(opt, \"ndots:\"));\r\n", "    }\r\n\r\n    private static AuthoritativeDnsServerCache redirectAuthoritativeDnsServerCache(\r\n            AuthoritativeDnsServerCache authoritativeDnsServerCache) {\r\n        // Don't wrap again to prevent the possibility of an StackOverflowError when wrapping another\r\n", "     *\r\n     * @param cause the cause of the decoding failure.\r\n     * @return a valid message indicating failure.\r\n     */\r\n    private M invalidMessage(Exception cause) {\r\n", " * A noop DNS cache that actually never caches anything.\r\n */\r\npublic final class NoopDnsCache implements DnsCache {\r\n\r\n    public static final NoopDnsCache INSTANCE = new NoopDnsCache();\r\n", "                        }\r\n                    }\r\n                });\r\n                if (maybeProvider instanceof Class) {\r\n                    @SuppressWarnings(\"unchecked\")\r\n", "import static io.netty.handler.codec.dns.DnsRecordType.CNAME;\r\nimport static io.netty.handler.codec.dns.DnsRecordType.SRV;\r\nimport static io.netty.resolver.dns.DnsServerAddresses.sequential;\r\nimport static java.util.Collections.singletonList;\r\nimport static org.hamcrest.MatcherAssert.assertThat;\r\n", "     * @param negativeTtl the TTL for failed queries\r\n     */\r\n    public DefaultDnsCache(int minTtl, int maxTtl, int negativeTtl) {\r\n        this.minTtl = Math.min(Cache.MAX_SUPPORTED_TTL_SECS, checkPositiveOrZero(minTtl, \"minTtl\"));\r\n        this.maxTtl = Math.min(Cache.MAX_SUPPORTED_TTL_SECS, checkPositiveOrZero(maxTtl, \"maxTtl\"));\r\n", "     * @param searchDomains the list of search domain\r\n     *                      (can be null, if so, will try to default to the underlying platform ones)\r\n     * @param ndots the ndots value\r\n     * @param decodeIdn {@code true} if domain / host names should be decoded to unicode when received.\r\n     *                        See <a href=\"https://tools.ietf.org/html/rfc3492\">rfc3492</a>.\r\n", "\r\n    /**\r\n     * Starts a new infinite stream of DNS server addresses. This method is invoked by {@link DnsNameResolver} on every\r\n     * uncached {@link DnsNameResolver#resolve(String)}or {@link DnsNameResolver#resolveAll(String)}.\r\n     */\r\n", "                AuthoritativeNameServer serverName = head;\r\n                while (serverName.next != null) {\r\n                    serverName = serverName.next;\r\n                }\r\n                serverName.next = new AuthoritativeNameServer(dots, r.timeToLive(), recordName, domainName);\r\n", "                        public void clear() {\r\n                            // NOOP\r\n                        }\r\n\r\n                        @Override\r\n", "    public void clear() {\r\n        // NOOP\r\n    }\r\n\r\n    @Override\r\n", "\r\nimport io.netty.channel.nio.NioEventLoopGroup;\r\nimport io.netty.util.NetUtil;\r\nimport org.junit.Test;\r\n\r\n", "                        }\r\n                    }\r\n                }\r\n            });\r\n            doSearchDomainQuery(initialHostname, searchDomainPromise);\r\n", "        return keyLength;\r\n    }\r\n\r\n    /**\r\n     * Set the key length of the message.\r\n", "/*\r\n * Copyright 2017 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2017 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2017 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2017 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2017 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2017 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2017 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2017 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2017 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2017 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2017 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2017 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2017 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2017 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2017 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2017 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2017 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2017 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "    /**\r\n     * Create a cache.\r\n     *\r\n     * @param minTtl the minimum TTL\r\n     * @param maxTtl the maximum TTL\r\n", "        return new DefaultDnsCache(intValue(minTtl, 0), intValue(maxTtl, Integer.MAX_VALUE), intValue(negativeTtl, 0));\r\n    }\r\n\r\n    private AuthoritativeDnsServerCache newAuthoritativeDnsServerCache() {\r\n        return new DefaultAuthoritativeDnsServerCache(\r\n", "    private final int maxTtl;\r\n    private final int negativeTtl;\r\n\r\n    /**\r\n     * Create a cache that respects the TTL returned by the DNS server\r\n", "        return rotational0(sanitize(addresses));\r\n    }\r\n\r\n    /**\r\n     * Returns the {@link DnsServerAddresses} that yields the specified {@code addresses} in a rotational sequential\r\n", "                    rm.setDnsTtl(10);\r\n                    rm.setDnsType(RecordType.SRV);\r\n                    rm.put(DnsAttribute.DOMAIN_NAME, \"foo.service.netty.io\");\r\n                    rm.put(DnsAttribute.SERVICE_PORT, \"8080\");\r\n                    rm.put(DnsAttribute.SERVICE_PRIORITY, \"10\");\r\n", "            }\r\n        }\r\n        return unixDefault();\r\n    }\r\n\r\n", "                               InetAddress address, long originalTtl, EventLoop loop) {\r\n        checkNotNull(hostname, \"hostname\");\r\n        checkNotNull(address, \"address\");\r\n        checkNotNull(loop, \"loop\");\r\n        DefaultDnsCacheEntry e = new DefaultDnsCacheEntry(hostname, address);\r\n", "     * @see BinaryMemcacheOpcodes for typesafe opcodes.\r\n     */\r\n    BinaryMemcacheMessage setMagic(byte magic);\r\n\r\n    /**\r\n", "/*\r\n * Copyright 2015 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2015 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2015 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2015 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2015 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2015 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2015 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2015 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2015 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2015 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "     * because we need to eliminate possible caching of {@link io.netty.resolver.NameResolver#resolve}\r\n     * by {@link InflightNameResolver} created in\r\n     * {@link #newResolver(EventLoop, ChannelFactory, DnsServerAddressStreamProvider)}.\r\n     */\r\n    @Override\r\n", "            // we drop servers that have a smaller dots count.\r\n            if (head == null || head.dots < dots) {\r\n                nameServerCount = 1;\r\n                head = new AuthoritativeNameServer(dots, r.timeToLive(), recordName, domainName);\r\n            } else if (head.dots == dots) {\r\n", "    }\r\n\r\n    /**\r\n     * Returns the {@link DnsServerAddresses} that yields the specified {@code addresses} in a shuffled order. Once all\r\n     * addresses are yielded, the addresses are shuffled again.\r\n", "    private static final String[] IPV6_ADDRESSES;\r\n\r\n    static {\r\n        BYTES.put(\"::1\", new byte[]{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1});\r\n        BYTES.put(\"0:0:0:0:0:0:1:1\", new byte[]{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1});\r\n", "        if (minTtl > maxTtl) {\r\n            throw new IllegalArgumentException(\r\n                    \"minTtl: \" + minTtl + \", maxTtl: \" + maxTtl + \" (expected: 0 <= minTtl <= maxTtl)\");\r\n        }\r\n        this.negativeTtl = checkPositiveOrZero(negativeTtl, \"negativeTtl\");\r\n", "        this.level = checkAndConvertLevel(level);\r\n        logger = DEFAULT_LOGGER;\r\n    }\r\n\r\n    /**\r\n", "\r\n    /**\r\n     * Helper method to create a upstream message when the incoming parsing did fail.\r\n     *\r\n     * @return a message indicating a decoding failure.\r\n", "                    return;\r\n                }\r\n                if (c == '.') {\r\n                    dots++;\r\n                }\r\n", "\r\n        @Override\r\n        public boolean clear(String hostname) {\r\n            return wrapped.clear(hostname);\r\n        }\r\n", "/*\r\n * Copyright 2019 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2019 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2019 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2019 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2019 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2019 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "\r\n            if (!(r instanceof DnsRawRecord)) {\r\n                continue;\r\n            }\r\n\r\n", "        testCNAMERecursiveResolve(false);\r\n    }\r\n\r\n    private static void testCNAMERecursiveResolve(boolean ipv4Preferred) throws IOException {\r\n        final String firstName = \"firstname.com\";\r\n", "            \"paypal.com\",\r\n            \"google.com.tw\",\r\n            \"bongacams.com\",\r\n            \"popads.net\",\r\n            \"whatsapp.com\",\r\n", "            }\r\n        });\r\n    }\r\n\r\n    static InternetProtocolFamily preferredAddressType(ResolvedAddressTypes resolvedAddressTypes) {\r\n", "/*\r\n * Copyright 2016 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2016 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2016 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2016 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2016 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2016 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2016 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2016 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2016 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2016 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2016 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "            \"sina.com.cn\",\r\n            \"jd.com\",\r\n            \"weibo.com\",\r\n            \"360.cn\",\r\n            \"google.de\",\r\n", "     */\r\n    public DnsNameResolverBuilder maxPayloadSize(int maxPayloadSize) {\r\n        this.maxPayloadSize = maxPayloadSize;\r\n        return this;\r\n    }\r\n", "         */\r\n        List<InetSocketAddress> addressList() {\r\n            List<InetSocketAddress> addressList = new ArrayList<InetSocketAddress>(nameServerCount);\r\n\r\n            AuthoritativeNameServer server = head;\r\n", "    }\r\n\r\n    @Test\r\n    public void testUnknownSpdyGoAwayFrameFlags() throws Exception {\r\n        short type = 7;\r\n", "        }\r\n\r\n        @Override\r\n        public boolean clear(String hostname) {\r\n            return cache.clear(hostname);\r\n", "\r\n    /**\r\n     * Returns the optional key of the document.\r\n     *\r\n     * @return the key of the document.\r\n", "    /**\r\n     * Copies special metadata hold by this instance to the provided instance\r\n     *\r\n     * @param dst The instance where to copy the metadata of this instance to\r\n     */\r\n", "    /**\r\n     * Copies special metadata hold by this instance to the provided instance\r\n     *\r\n     * @param dst The instance where to copy the metadata of this instance to\r\n     */\r\n", "    /**\r\n     * Copies special metadata hold by this instance to the provided instance\r\n     *\r\n     * @param dst The instance where to copy the metadata of this instance to\r\n     */\r\n", "/**\r\n * Special {@link Comparator} implementation to sort the nameservers to use when follow redirects.\r\n *\r\n * This implementation follows all the semantics listed in the\r\n * <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html\">Comparator apidocs</a>\r\n", "import org.junit.Before;\r\nimport org.junit.Test;\r\n\r\nimport static org.hamcrest.CoreMatchers.*;\r\nimport static org.hamcrest.MatcherAssert.*;\r\n", "     * is transferred to this {@link BinaryMemcacheMessage}.\r\n     *\r\n     * @param key the key of the message. {@link ByteBuf#release()} ownership is transferred\r\n     *            to this {@link BinaryMemcacheMessage}.\r\n     */\r\n", " * Default implementation of a {@link DnsCnameCache}.\r\n */\r\npublic final class DefaultDnsCnameCache implements DnsCnameCache {\r\n    private final int minTtl;\r\n    private final int maxTtl;\r\n", "\r\n/**\r\n * Decodes an {@link InetAddress} from an A or AAAA {@link DnsRawRecord}.\r\n */\r\nfinal class DnsAddressDecoder {\r\n", "        assertEquals(expected.opcode(), actual.opcode());\r\n        assertEquals(expected.keyLength(), actual.keyLength());\r\n        assertEquals(expected.extrasLength(), actual.extrasLength());\r\n        assertEquals(expected.dataType(), actual.dataType());\r\n        assertEquals(expected.totalBodyLength(), actual.totalBodyLength());\r\n", "    }\r\n\r\n    /**\r\n     * This test makes sure that even when the decoder is confronted with various chunk\r\n     * sizes in the middle of decoding, it can recover and decode all the time eventually.\r\n", "import java.util.List;\r\n\r\nimport static io.netty.util.internal.ObjectUtil.*;\r\n\r\n/**\r\n", "        NoopDnsCacheEntry(InetAddress address) {\r\n            this.address = address;\r\n        }\r\n\r\n        @Override\r\n", "\r\n    final Future<Channel> channelFuture;\r\n    final Channel ch;\r\n\r\n    // Comparator that ensures we will try first to use the nameservers that use our preferred address type.\r\n", "\r\n        @Override\r\n        public void clear() {\r\n            wrapped.clear();\r\n        }\r\n", "    /**\r\n     * The {@link AuthoritativeDnsServerCache} to use while resolving.\r\n     */\r\n    AuthoritativeDnsServerCache authoritativeDnsServerCache() {\r\n        return parent.authoritativeDnsServerCache();\r\n", "        @Override\r\n        public Throwable fillInStackTrace() {\r\n            return this;\r\n        }\r\n\r\n", "import io.netty.channel.socket.InternetProtocolFamily;\r\nimport io.netty.channel.socket.nio.NioDatagramChannel;\r\nimport io.netty.channel.socket.nio.NioSocketChannel;\r\nimport io.netty.handler.codec.dns.DefaultDnsQuestion;\r\nimport io.netty.handler.codec.dns.DnsQuestion;\r\n", "    void cache(String hostname, String cname, long originalTtl, EventLoop loop);\r\n\r\n    /**\r\n     * Clears all cached nameservers.\r\n     *\r\n", "            return AsciiString.contentEqualsIgnoreCase(entry, otherEntry);\r\n        }\r\n    };\r\n\r\n    /**\r\n", "            list = new ArrayList<InetSocketAddress>(4);\r\n        }\r\n\r\n        for (InetSocketAddress a : addresses) {\r\n            if (a == null) {\r\n", "\r\n        assertEquals(expected, addresses);\r\n    }\r\n\r\n    @Test\r\n", "            }\r\n\r\n            @Override\r\n            public boolean clear(String hostname) {\r\n                return false;\r\n", "            }\r\n\r\n            @Override\r\n            public boolean clear(String hostname) {\r\n                return false;\r\n", "                rm.setDnsName(question.getDomainName());\r\n                rm.setDnsTtl(100);\r\n\r\n                rm.setDnsType(question.getRecordType());\r\n                rm.put(DnsAttribute.IP_ADDRESS, ipv4Addr);\r\n", "     */\r\n    public static DnsServerAddresses shuffled(InetSocketAddress... addresses) {\r\n        return shuffled0(sanitize(addresses));\r\n    }\r\n\r\n", " */\r\nfinal class AuthoritativeDnsServerCacheAdapter implements AuthoritativeDnsServerCache {\r\n\r\n    private static final DnsRecord[] EMPTY = new DnsRecord[0];\r\n    private final DnsCache cache;\r\n", "/*\r\n * Copyright 2018 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2018 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2018 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2018 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2018 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2018 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2018 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2018 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2018 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2018 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2018 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2018 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2018 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2018 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2018 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2018 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2018 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "\r\n                    // We may have multiple ADDITIONAL entries for the same nameserver name. For example one AAAA and\r\n                    // one A record.\r\n                    serverNames.handleWithAdditional(parent, r, authoritativeDnsServerCache);\r\n                }\r\n", "            default:\r\n                throw new IllegalArgumentException();\r\n        }\r\n    }\r\n\r\n", "package io.netty.resolver.dns;\r\n\r\nimport io.netty.channel.DefaultEventLoopGroup;\r\nimport io.netty.channel.EventLoop;\r\nimport io.netty.channel.nio.NioEventLoopGroup;\r\n", "     * </p>\r\n     */\r\n    public static DnsServerAddresses defaultAddresses() {\r\n        return DEFAULT_NAME_SERVERS;\r\n    }\r\n", "        } else {\r\n            String lastName = HOSTNAME;\r\n            for (int i = 1; i < chainLength; i++) {\r\n                String nextName = i + \".\" + lastName;\r\n                cache.cache(lastName, nextName, Long.MAX_VALUE, channel.eventLoop());\r\n", "        EventLoopGroup group = new DefaultEventLoopGroup(1);\r\n\r\n        try {\r\n            EventLoop loop = group.next();\r\n            final DefaultAuthoritativeDnsServerCache cache = new DefaultAuthoritativeDnsServerCache();\r\n", "        }\r\n\r\n        if (authoritativeDnsServerCache != null && (minTtl != null || maxTtl != null || negativeTtl != null)) {\r\n            throw new IllegalStateException(\"authoritativeDnsServerCache and TTLs are mutually exclusive\");\r\n        }\r\n", "        this.opaque = opaque;\r\n        return this;\r\n    }\r\n\r\n    @Override\r\n", "                    }\r\n                }\r\n            };\r\n\r\n            negativeLookupThread.start();\r\n", "     * @see #maxTtl()\r\n     */\r\n    public int minTtl() {\r\n        return minTtl;\r\n    }\r\n", "        return ndots;\r\n    }\r\n\r\n    final boolean supportsAAAARecords() {\r\n        return supportsAAAARecords;\r\n", "        super.touch(hint);\r\n        content.touch(hint);\r\n        return this;\r\n    }\r\n\r\n", "        super.touch(hint);\r\n        content.touch(hint);\r\n        return this;\r\n    }\r\n\r\n", "                \"google.ru\",\r\n                \"google.it\",\r\n                \"google.es\",\r\n                \"google.com.mx\",\r\n                \"xhamster.com\",\r\n", "                        }\r\n                        if (!rotate && line.startsWith(OPTIONS_ROW_LABEL)) {\r\n                            rotate = line.contains(OPTIONS_ROTATE_FLAG);\r\n                        } else if (line.startsWith(NAMESERVER_ROW_LABEL)) {\r\n                            int i = indexOfNonWhiteSpace(line, NAMESERVER_ROW_LABEL.length());\r\n", "\r\n            // There are still some queries in process, we will try to notify once the next one finishes until\r\n            // all are finished.\r\n            return;\r\n        }\r\n", "        }\r\n\r\n        buf.setLength(buf.length() - 2);\r\n        buf.append(\"))\");\r\n\r\n", "        this.maxTtl = Math.min(Cache.MAX_SUPPORTED_TTL_SECS, checkPositive(maxTtl, \"maxTtl\"));\r\n        if (minTtl > maxTtl) {\r\n            throw new IllegalArgumentException(\r\n                    \"minTtl: \" + minTtl + \", maxTtl: \" + maxTtl + \" (expected: 0 <= minTtl <= maxTtl)\");\r\n        }\r\n", "    public void testNsLoopFailsResolveWithoutAuthoritativeDnsServerCache() throws Exception {\r\n        testNsLoopFailsResolve(NoopAuthoritativeDnsServerCache.INSTANCE);\r\n    }\r\n\r\n    private void testNsLoopFailsResolve(AuthoritativeDnsServerCache authoritativeDnsServerCache) throws Exception {\r\n", "                DnsNameResolver parent, DnsCache cache, AuthoritativeDnsServerCache authoritativeCache) {\r\n            AuthoritativeNameServer serverName = head;\r\n\r\n            while (serverName != null) {\r\n                if (serverName.address == null) {\r\n", "            });\r\n        }\r\n    }\r\n\r\n    private void writeQuery(final DnsQuery query, final boolean flush, final ChannelPromise writePromise) {\r\n", "            }\r\n        }\r\n    }\r\n\r\n    @Test(timeout = 5000)\r\n", "                authoritativeLatch.countDown();\r\n            }\r\n\r\n            @Override\r\n            public boolean clear(String hostname) {\r\n", "    /**\r\n     * Returns {@code true} if both entries are equal.\r\n     */\r\n    protected abstract boolean equals(E entry, E otherEntry);\r\n\r\n", "        EventLoopGroup group = new DefaultEventLoopGroup(1);\r\n\r\n        try {\r\n            EventLoop loop = group.next();\r\n            final DefaultDnsCnameCache cache = new DefaultDnsCnameCache();\r\n", "        EventLoopGroup group = new DefaultEventLoopGroup(1);\r\n\r\n        try {\r\n            EventLoop loop = group.next();\r\n            final DefaultDnsCnameCache cache = new DefaultDnsCnameCache();\r\n", "            assertEquals(key2.readableBytes() + extras.readableBytes() + contentLength, message.totalBodyLength());\r\n\r\n            // Replace the previous extras\r\n            message.setExtras(extras2.retain());\r\n            assertEquals(key2.readableBytes(), message.keyLength());\r\n", "                continue;\r\n            }\r\n\r\n            final String questionName = question.name().toLowerCase(Locale.US);\r\n            final String recordName = r.name().toLowerCase(Locale.US);\r\n", "    private String[] searchDomains;\r\n    private int ndots = -1;\r\n    private boolean decodeIdn = true;\r\n\r\n    /**\r\n", "    public void testNsLoopFailsResolveWithAuthoritativeDnsServerCache() throws Exception {\r\n        testNsLoopFailsResolve(new DefaultAuthoritativeDnsServerCache());\r\n    }\r\n\r\n    @Test\r\n", "                            for (T item : result) {\r\n                                ReferenceCountUtil.safeRelease(item);\r\n                            }\r\n                        }\r\n                    } else {\r\n", "import static org.junit.Assert.*;\r\n\r\npublic class DefaultAuthoritativeDnsServerCacheTest {\r\n\r\n    @Test\r\n", "\r\n    @Override\r\n    FullMemcacheMessage replace(ByteBuf content);\r\n\r\n    @Override\r\n", "        }\r\n\r\n        @Override\r\n        public void clear() {\r\n            cache.clear();\r\n", "        }\r\n\r\n        if (!defaultNameServers.isEmpty()) {\r\n            if (logger.isDebugEnabled()) {\r\n                logger.debug(\r\n", "     * @param comparator the {@link Comparator} to order the {@link InetSocketAddress} for a hostname or {@code null}\r\n     *                   if insertion order should be used.\r\n     */\r\n    public DefaultAuthoritativeDnsServerCache(int minTtl, int maxTtl, Comparator<InetSocketAddress> comparator) {\r\n        this.minTtl = Math.min(Cache.MAX_SUPPORTED_TTL_SECS, checkPositiveOrZero(minTtl, \"minTtl\"));\r\n", "    /**\r\n     * The list of the domain names to exclude from {@link #testResolveAorAAAA()}.\r\n     */\r\n    private static final Set<String> EXCLUSIONS_RESOLVE_A = new HashSet<String>();\r\n\r\n", "            // See https://github.com/netty/netty/issues/7329\r\n            resolveCache.remove(hostname, this);\r\n\r\n            clearAndCancel();\r\n        }\r\n", "import static org.junit.Assert.assertTrue;\r\n\r\n/**\r\n * Verifies the correct functionality of the {@link BinaryMemcacheObjectAggregator}.\r\n */\r\n", "     * Clear all entries (if anything exists) for the given hostname and return {@code true} if anything was removed.\r\n     */\r\n    final boolean clear(String hostname) {\r\n        Entries entries = resolveCache.remove(hostname);\r\n        return entries != null && entries.clearAndCancel();\r\n", "\r\n    /**\r\n     * Returns the automatic inclusion of a optional records that tries to give the remote DNS server a hint about how\r\n     * much data the resolver can read per response is enabled.\r\n     */\r\n", "    @Override\r\n    public String toString() {\r\n        return \"DefaultAuthoritativeDnsServerCache(minTtl=\" + minTtl + \", maxTtl=\" + maxTtl + \", cached nameservers=\" +\r\n                resolveCache.size() + ')';\r\n    }\r\n", "    enum State {\r\n        /**\r\n         * Currently reading the header portion.\r\n         */\r\n        READ_HEADER,\r\n", "import org.junit.Before;\r\nimport org.junit.Test;\r\n\r\nimport static org.hamcrest.CoreMatchers.*;\r\nimport static org.hamcrest.MatcherAssert.assertThat;\r\n", "                                maybeIP = line.substring(i, x);\r\n                            }\r\n\r\n                            // There may be a port appended onto the IP address so we attempt to extract it.\r\n                            if (!NetUtil.isValidIpV4Address(maybeIP) && !NetUtil.isValidIpV6Address(maybeIP)) {\r\n", "        dst.dataType = dataType;\r\n        dst.totalBodyLength = totalBodyLength;\r\n        dst.opaque = opaque;\r\n        dst.cas = cas;\r\n    }\r\n", "        }\r\n    }\r\n\r\n    @Test\r\n    public void fullDuplicate() {\r\n", "        }\r\n    }\r\n\r\n    @Test\r\n    public void fullDuplicate() {\r\n", "\r\n        // Third message first content chunk\r\n        content = channel.readInbound();\r\n        assertThat(content, instanceOf(LastMemcacheContent.class));\r\n        assertThat(content.content().toString(CharsetUtil.UTF_8), is(msgBody));\r\n", "package io.netty.handler.codec.spdy;\r\n\r\nimport io.netty.buffer.ByteBuf;\r\nimport io.netty.buffer.Unpooled;\r\nimport org.junit.After;\r\n", "        }\r\n    }\r\n\r\n    private static Inet4Address toIPv4Address(Inet6Address a6) {\r\n        byte[] b6 = a6.getAddress();\r\n", "        EventLoopGroup group = new NioEventLoopGroup(1);\r\n\r\n        try {\r\n            EventLoop loop = group.next();\r\n            final DefaultAuthoritativeDnsServerCache cache = new DefaultAuthoritativeDnsServerCache();\r\n", "\r\n        @Override\r\n        public boolean clear(String hostname) {\r\n            return cache.clear(hostname);\r\n        }\r\n", "            final AuthoritativeDnsServerCache authoritativeDnsServerCache,\r\n            DnsQueryLifecycleObserverFactory dnsQueryLifecycleObserverFactory,\r\n            long queryTimeoutMillis,\r\n            ResolvedAddressTypes resolvedAddressTypes,\r\n            boolean recursionDesired,\r\n", "        buf.append(type).append('(');\r\n\r\n        for (InetSocketAddress a: addresses) {\r\n            buf.append(a).append(\", \");\r\n        }\r\n", "        } catch (Exception e) {\r\n            assertSame(exception, e);\r\n        }\r\n    }\r\n\r\n", "\r\n            message.setExtras(extras.retain());\r\n            assertEquals(key.readableBytes(), message.keyLength());\r\n            assertEquals(extras.readableBytes(), message.extrasLength());\r\n            assertEquals(key.readableBytes() + extras.readableBytes() + contentLength, message.totalBodyLength());\r\n", "\r\nimport static io.netty.resolver.dns.DefaultDnsServerAddressStreamProvider.defaultAddressList;\r\nimport static org.hamcrest.MatcherAssert.assertThat;\r\nimport static org.hamcrest.Matchers.*;\r\n\r\n", "            this.cause = cause;\r\n        }\r\n    }\r\n\r\n    private static final class QuerySucceededEvent {\r\n", "\r\n    /**\r\n     * Creates a new DNS-based name resolver that communicates with the specified list of DNS servers.\r\n     *\r\n     * @param eventLoop the {@link EventLoop} which will perform the communication with the DNS servers\r\n", "final class UnixResolverOptions {\r\n\r\n    private final int ndots;\r\n    private final int timeout;\r\n    private final int attempts;\r\n", "package io.netty.resolver.dns;\r\n\r\nimport io.netty.channel.DefaultEventLoopGroup;\r\nimport io.netty.channel.EventLoop;\r\nimport io.netty.channel.EventLoopGroup;\r\n", "package io.netty.resolver.dns;\r\n\r\nimport io.netty.channel.DefaultEventLoopGroup;\r\nimport io.netty.channel.EventLoop;\r\nimport io.netty.channel.EventLoopGroup;\r\n", "package io.netty.resolver.dns;\r\n\r\nimport io.netty.channel.DefaultEventLoopGroup;\r\nimport io.netty.channel.EventLoop;\r\nimport io.netty.channel.EventLoopGroup;\r\n", "    }\r\n\r\n    private static final class SearchDomainUnknownHostException extends UnknownHostException {\r\n        private static final long serialVersionUID = -8573510133644997085L;\r\n\r\n", "                fr.close();\r\n            } else {\r\n                br.close();\r\n            }\r\n        }\r\n", "                fr.close();\r\n            } else {\r\n                br.close();\r\n            }\r\n        }\r\n", "                }\r\n\r\n                @Override\r\n                public void remove() {\r\n                    throw new UnsupportedOperationException();\r\n", "        }\r\n\r\n        // We always store in the cache with a trailing '.'.\r\n        if (hostname.charAt(len - 1) != '.') {\r\n            hostname += \".\";\r\n", "                            }\r\n                            port = Integer.parseInt(line.substring(i));\r\n                        } else if (line.startsWith(SORTLIST_ROW_LABEL)) {\r\n                            logger.info(\"row type {} not supported. Ignoring line: {}\", SORTLIST_ROW_LABEL, line);\r\n                        }\r\n", "/*\r\n * Copyright 2020 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2020 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2020 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2020 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "/*\r\n * Copyright 2020 The Netty Project\r\n *\r\n * The Netty Project licenses this file to you under the Apache License,\r\n * version 2.0 (the \"License\"); you may not use this file except in compliance\r\n", "                StringUtil.EMPTY_STRING);\r\n    }\r\n\r\n    /**\r\n     * The list of the domain names to exclude from {@link #testResolveAAAA()}.\r\n", "\r\n    /**\r\n     * The {@link DnsCache} to use while resolving.\r\n     */\r\n    DnsCache resolveCache() {\r\n", "        assertEquals(expectedContent, actual.content());\r\n\r\n        assertEquals(expected.status(), actual.status());\r\n        assertEquals(expected.magic(), actual.magic());\r\n        assertEquals(expected.opcode(), actual.opcode());\r\n", "        } else {\r\n            this.i = 0;\r\n            shuffle();\r\n        }\r\n        return next;\r\n", "package io.netty.resolver.dns;\r\n\r\nimport io.netty.channel.EventLoop;\r\n\r\n/**\r\n", "                String resolved = questionName;\r\n                do {\r\n                    resolved = cnamesCopy.remove(resolved);\r\n                    if (recordName.equals(resolved)) {\r\n                        break;\r\n", "            if (hostname.charAt(idx) == '.' && ++dots >= parent.ndots()) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n", "    private byte opcode;\r\n    private short keyLength;\r\n    private byte extrasLength;\r\n    private byte dataType;\r\n    private int totalBodyLength;\r\n", "        // RedirectAuthoritativeDnsServerCache.\r\n        if (authoritativeDnsServerCache instanceof RedirectAuthoritativeDnsServerCache) {\r\n            return authoritativeDnsServerCache;\r\n        }\r\n        return new RedirectAuthoritativeDnsServerCache(authoritativeDnsServerCache);\r\n", "        }\r\n    }\r\n\r\n    @Override\r\n    public boolean acceptOutboundMessage(Object msg) throws Exception {\r\n", "     * @return {@code this}\r\n     */\r\n    public DnsNameResolverBuilder negativeTtl(int negativeTtl) {\r\n        this.negativeTtl = negativeTtl;\r\n        return this;\r\n", " */\r\npublic interface DnsCache {\r\n\r\n    /**\r\n     * Clears all the resolved addresses cached by this resolver.\r\n", "            // Cache the server now.\r\n            cache(server, authoritativeCache, loop);\r\n        }\r\n\r\n        private static void cache(AuthoritativeNameServer server, AuthoritativeDnsServerCache cache, EventLoop loop) {\r\n", "package io.netty.resolver.dns;\r\n\r\nimport io.netty.util.CharsetUtil;\r\nimport org.junit.Rule;\r\nimport org.junit.Test;\r\n", "        }\r\n    }\r\n\r\n    @Test\r\n    public void testExpireWithToBigMinTTL() {\r\n", "\r\n    /**\r\n     * Encode the content, depending on the object type.\r\n     *\r\n     * @param msg the object to encode.\r\n", "     *         none should be followed.\r\n     */\r\n    protected DnsServerAddressStream newRedirectDnsServerStream(\r\n            @SuppressWarnings(\"unused\") String hostname, List<InetSocketAddress> nameservers) {\r\n        DnsServerAddressStream cached = authoritativeDnsServerCache().get(hostname);\r\n", "    }\r\n\r\n    final boolean supportsARecords() {\r\n        return supportsARecords;\r\n    }\r\n", "     */\r\n    DnsCnameCache cnameCache() {\r\n        return parent.cnameCache();\r\n    }\r\n\r\n", "    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return NoopDnsCache.class.getSimpleName();\r\n", "        testFollowNsRedirects(NoopDnsCache.INSTANCE, new DefaultAuthoritativeDnsServerCache(), false);\r\n    }\r\n\r\n    @Test\r\n    public void testFollowNsRedirectsNoopAuthoritativeDnsServerCache() throws Exception {\r\n", "     * {@link DnsNameResolver}.\r\n     */\r\n    public static boolean isTimeoutError(Throwable cause) {\r\n        return cause != null && cause.getCause() instanceof DnsNameResolverTimeoutException;\r\n    }\r\n", "        }\r\n    };\r\n\r\n    /**\r\n     * Create a cache that respects the TTL returned by the DNS server.\r\n", "\r\n    private static String hostname(String inetHost) {\r\n        String hostname = IDN.toASCII(inetHost);\r\n        // Check for https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6894622\r\n        if (StringUtil.endsWith(inetHost, '.') && !StringUtil.endsWith(hostname, '.')) {\r\n", "        return sequential0(sanitize(addresses));\r\n    }\r\n\r\n    /**\r\n     * Returns the {@link DnsServerAddresses} that yields the specified {@code addresses} sequentially. Once the\r\n", "            @Override\r\n            public boolean clear(String hostname) {\r\n                return false;\r\n            }\r\n\r\n", "\r\n            @Override\r\n            public boolean clear(String hostname) {\r\n                return false;\r\n            }\r\n", "\r\n    @Override\r\n    public boolean clear(String hostname) {\r\n        return false;\r\n    }\r\n", "    public static final NoopAuthoritativeDnsServerCache INSTANCE = new NoopAuthoritativeDnsServerCache();\r\n\r\n    private NoopAuthoritativeDnsServerCache() { }\r\n\r\n    @Override\r\n", "     * @param decodeIdn {@code true} if domain / host names should be decoded to unicode when received.\r\n     *                        See <a href=\"https://tools.ietf.org/html/rfc3492\">rfc3492</a>.\r\n     * @deprecated Use {@link DnsNameResolverBuilder}.\r\n     */\r\n    @Deprecated\r\n", "        private static String nextIp() {\r\n            return ipPart() + \".\" + ipPart() + '.' + ipPart() + '.' + ipPart();\r\n        }\r\n\r\n        private static int ipPart() {\r\n", "import static org.junit.Assert.*;\r\n\r\npublic class DefaultDnsCnameCacheTest {\r\n\r\n    @Test\r\n", "\r\n    /**\r\n     * Creates a new {@link DnsServerAddressStream} to following a redirected DNS query. By overriding this\r\n     * it provides the opportunity to sort the name servers before following a redirected DNS query.\r\n     *\r\n", "        AuthoritativeNameServerList serverNames = new AuthoritativeNameServerList(questionName);\r\n        for (int i = 0; i < authorityCount; i++) {\r\n            serverNames.add(res.recordAt(DnsSection.AUTHORITY, i));\r\n        }\r\n        return serverNames.isEmpty() ? null : serverNames;\r\n", "    private final Cache<DefaultDnsCacheEntry> resolveCache = new Cache<DefaultDnsCacheEntry>() {\r\n\r\n        @Override\r\n        protected boolean shouldReplaceAll(DefaultDnsCacheEntry entry) {\r\n            return entry.cause() != null;\r\n", "\r\n        try {\r\n            EventLoop loop = group.next();\r\n            final DefaultAuthoritativeDnsServerCache cache;\r\n\r\n", "            @Override\r\n            public void operationComplete(ChannelFuture future) {\r\n                resolveCache.clear();\r\n                cnameCache.clear();\r\n                authoritativeDnsServerCache.clear();\r\n", "    RotationalDnsServerAddresses(List<InetSocketAddress> addresses) {\r\n        super(\"rotational\", addresses);\r\n    }\r\n\r\n    @Override\r\n", "import java.util.Collections;\r\nimport java.util.List;\r\n\r\npublic class PreferredAddressTypeComparatorTest {\r\n\r\n", "                .toString();\r\n    }\r\n\r\n    private static final class DefaultDnsCacheEntry implements DnsCacheEntry {\r\n        private final String hostname;\r\n", "                                int idx = indexOfNonWhiteSpace(line, x);\r\n                                if (idx == -1 || line.charAt(idx) != '#') {\r\n                                    throw new IllegalArgumentException(\"error parsing label \" + NAMESERVER_ROW_LABEL +\r\n                                            \" in file \" + etcResolverFile + \". value: \" + line);\r\n                                }\r\n", "        assertEquals(expected.extras(), actual.extras());\r\n        assertEquals(expectedContent, actual.content());\r\n\r\n        assertEquals(expected.reserved(), actual.reserved());\r\n        assertEquals(expected.magic(), actual.magic());\r\n", "     *\r\n     * @param extrasLength the extras length.\r\n     */\r\n    BinaryMemcacheMessage setExtrasLength(byte extrasLength) {\r\n        this.extrasLength = extrasLength;\r\n", "        short type = 4;\r\n        byte flags = 0x01; // FLAG_SETTINGS_CLEAR_SETTINGS\r\n        int numSettings = 0;\r\n        int length = 8 * numSettings + 4;\r\n\r\n", "\r\n    public static final NoopDnsCnameCache INSTANCE = new NoopDnsCnameCache();\r\n\r\n    private NoopDnsCnameCache() { }\r\n\r\n", "                nameServerCount++;\r\n            }\r\n        }\r\n\r\n        void handleWithAdditional(\r\n", "        @Override\r\n        public Throwable cause() {\r\n            return cause;\r\n        }\r\n\r\n", "import static org.junit.Assert.assertEquals;\r\nimport static org.junit.Assert.assertFalse;\r\nimport static org.junit.Assert.assertTrue;\r\n\r\npublic class FullMemcacheMessageResponseTest {\r\n", "package io.netty.resolver.dns;\r\n\r\nimport io.netty.channel.EventLoop;\r\nimport io.netty.util.AsciiString;\r\n\r\n", "                        + \"incorrect DNS resolutions on MacOS.\", MACOS_PROVIDER_CLASS_NAME);\r\n            } catch (Throwable cause) {\r\n                LOGGER.error(\"Unable to load {}, fallback to system defaults. This may result in \"\r\n                        + \"incorrect DNS resolutions on MacOS.\", MACOS_PROVIDER_CLASS_NAME, cause);\r\n                constructor = null;\r\n", "    }\r\n\r\n    /**\r\n     * The maximum allowed number of DNS queries to send when resolving a host name.\r\n     * The default value is {@code 16}.\r\n", "            hostname += \".\";\r\n        }\r\n        return hostname;\r\n    }\r\n\r\n", "        }\r\n    }\r\n\r\n    @Test\r\n    public void testFollowNsRedirectsNoopCaches() throws Exception {\r\n", "import io.netty.handler.codec.dns.DefaultDnsRawRecord;\r\nimport io.netty.handler.codec.dns.DnsQuestion;\r\nimport io.netty.handler.codec.dns.DnsRawRecord;\r\nimport io.netty.handler.codec.dns.DnsRecord;\r\nimport io.netty.handler.codec.dns.DnsRecordType;\r\n", "\r\n    private EmbeddedChannel channel;\r\n\r\n    @Test\r\n    public void shouldAggregateChunksOnDecode() {\r\n", "\r\n        boolean found = false;\r\n        boolean completeEarly = this.completeEarly;\r\n        for (int i = 0; i < answerCount; i ++) {\r\n            final DnsRecord r = response.recordAt(DnsSection.ANSWER, i);\r\n", "            });\r\n        }\r\n    }\r\n\r\n    private void doResolveAllUncached0(String hostname,\r\n", "\r\n    /**\r\n     * Returns the {@link DnsServerAddresses} that yields the system DNS server addresses sequentially. If it failed to\r\n     * retrieve the list of the system DNS server addresses from the environment, it will use {@code \"8.8.8.8\"} and\r\n     * {@code \"8.8.4.4\"}, the addresses of the Google public DNS servers.\r\n", "        totalBodyLength = totalBodyLength + keyLength - oldKeyLength;\r\n        return this;\r\n    }\r\n\r\n    @Override\r\n", "    }\r\n\r\n    @Test\r\n    public void testLastSpdyHeadersFrame() throws Exception {\r\n        short type = 8;\r\n", "import org.junit.After;\r\nimport org.junit.Before;\r\nimport org.junit.Test;\r\n\r\nimport static org.junit.Assert.assertEquals;\r\n", "\r\n    /**\r\n     * Returns the {@link DnsQuestion} of the DNS query that has failed.\r\n     */\r\n    public DnsQuestion question() {\r\n", "        public Throwable fillInStackTrace() {   // lgtm[java/non-sync-override]\r\n            return this;\r\n        }\r\n    }\r\n\r\n", "        } finally {\r\n            b.queryFailed(cause);\r\n        }\r\n    }\r\n\r\n", "        logger.log(level, \"from {} : {} no answer {}\", dnsServerAddress, question, code);\r\n        return this;\r\n    }\r\n\r\n    @Override\r\n", "import io.netty.util.internal.StringUtil;\r\nimport io.netty.util.internal.logging.InternalLogger;\r\nimport io.netty.util.internal.logging.InternalLoggerFactory;\r\nimport org.apache.directory.server.dns.DnsException;\r\nimport org.apache.directory.server.dns.io.encoder.DnsMessageEncoder;\r\n", "                    if (i >= 0) {\r\n                        localDomain = line.substring(i);\r\n                    }\r\n                } else if (line.startsWith(SEARCH_ROW_LABEL)) {\r\n                    int i = indexOfNonWhiteSpace(line, SEARCH_ROW_LABEL.length());\r\n", "    private EventLoopGroup group;\r\n    private DnsNameResolver resolver;\r\n\r\n    @Before\r\n    public void before() {\r\n", "            \"imdb.com\",\r\n            \"aliexpress.com\",\r\n            \"hao123.com\",\r\n            \"msn.com\",\r\n            \"tumblr.com\",\r\n", "     */\r\n    @Override\r\n    BinaryMemcacheMessage retain();\r\n\r\n    /**\r\n", "\r\n        boolean clearAndCancel() {\r\n            List<E> entries = getAndSet(Collections.<E>emptyList());\r\n            if (entries.isEmpty()) {\r\n                return false;\r\n", "    /**\r\n     * Encode the header.\r\n     * <p/>\r\n     * This methods needs to be implemented by a sub class because the header is different\r\n     * for both requests and responses.\r\n", "        this.comparator = comparator;\r\n    }\r\n\r\n    @SuppressWarnings(\"unchecked\")\r\n    @Override\r\n", "        assert expectedTypes.length > 0;\r\n\r\n        this.parent = parent;\r\n        this.originalPromise = originalPromise;\r\n        this.hostname = hostname;\r\n", "    }\r\n\r\n    @Test\r\n    public void testSpdyPingFrame() throws Exception {\r\n        short type = 6;\r\n", "    // $ head -100 top-1m.csv | cut -d, -f2 | cut -d/ -f1 | while read L; do echo '\"'\"$L\"'\",'; done > topsites.txt\r\n    private static final Set<String> DOMAINS = Collections.unmodifiableSet(new HashSet<String>(Arrays.asList(\r\n            \"google.com\",\r\n            \"youtube.com\",\r\n            \"facebook.com\",\r\n", "                .append(\"DefaultDnsCache(minTtl=\")\r\n                .append(minTtl).append(\", maxTtl=\")\r\n                .append(maxTtl).append(\", negativeTtl=\")\r\n                .append(negativeTtl).append(\", cached resolved hostname=\")\r\n                .append(resolveCache.size()).append(')')\r\n", "        BYTES.put(\"1:1:1:1:1:1:1:1\", new byte[]{0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1});\r\n\r\n        IPV6_ADDRESSES = BYTES.keySet().toArray(new String[0]);\r\n    }\r\n\r\n", "package io.netty.resolver.dns;\r\n\r\nimport java.net.InetSocketAddress;\r\n\r\n/**\r\n", "\r\n        @Override\r\n        public void clear() {\r\n            cache.clear();\r\n        }\r\n", "    @Override\r\n    public void clear() {\r\n        cache.clear();\r\n    }\r\n\r\n", "    public void testNegativeNameLength() throws Exception {\r\n        ByteBuf headerBlock = Unpooled.buffer(8);\r\n        headerBlock.writeInt(1);\r\n        headerBlock.writeInt(-1);\r\n        decoder.decode(ByteBufAllocator.DEFAULT, headerBlock, frame);\r\n", "        this.recursionDesired = recursionDesired;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n", "        this.ndots = ndots;\r\n        return this;\r\n    }\r\n\r\n    private DnsCache newCache() {\r\n", "\r\n        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeControlFrameHeader(buf, type, flags, length);\r\n        buf.writeLong(RANDOM.nextLong());\r\n\r\n", "        cache.clear();\r\n    }\r\n\r\n    @Override\r\n    public boolean clear(String hostname) {\r\n", "            }\r\n        } finally {\r\n            group.shutdownGracefully();\r\n        }\r\n    }\r\n", "        }\r\n\r\n        @Override\r\n        protected boolean equals(DefaultDnsCacheEntry entry, DefaultDnsCacheEntry otherEntry) {\r\n            if (entry.address() != null) {\r\n", "        }\r\n    }\r\n\r\n    @Test\r\n    public void testAddSameCnameForSameHostname() throws Exception {\r\n", "            final int numEntries = cachedEntries.size();\r\n            // Find the first entry with the preferred address type.\r\n            for (InternetProtocolFamily f : resolvedInternetProtocolFamilies) {\r\n                for (int i = 0; i < numEntries; i++) {\r\n                    final DnsCacheEntry e = cachedEntries.get(i);\r\n", "        }\r\n\r\n        buf.writeBytes(key);\r\n    }\r\n\r\n", "            assertEquals(extras2.readableBytes(), message.extrasLength());\r\n            assertEquals(key2.readableBytes() + extras2.readableBytes() + contentLength, message.totalBodyLength());\r\n        } finally {\r\n            key.release();\r\n            extras.release();\r\n", "                //                responses.  The values have the following\r\n                //                interpretation:\r\n                //\r\n                //                ....\r\n                //                ....\r\n", "\r\n        Collections.sort(addresses, comparator);\r\n\r\n        assertEquals(expected, addresses);\r\n    }\r\n", "\r\n        Collections.sort(addresses, comparator);\r\n\r\n        assertEquals(expected, addresses);\r\n    }\r\n", "\r\n            message.setKey(key.retain());\r\n            assertEquals(key.readableBytes(), message.keyLength());\r\n            assertEquals(initialExtrasLength, message.extrasLength());\r\n            assertEquals(key.readableBytes() + initialExtrasLength + contentLength, message.totalBodyLength());\r\n", "        private static final char[] CHARS = new char[26];\r\n\r\n        static {\r\n            for (int i = 0; i < NUMBERS.length; i++) {\r\n                NUMBERS[i] = i + 1;\r\n", "import io.netty.channel.AddressedEnvelope;\r\nimport io.netty.channel.ChannelPromise;\r\nimport io.netty.channel.EventLoop;\r\nimport io.netty.handler.codec.CorruptedFrameException;\r\nimport io.netty.handler.codec.dns.DefaultDnsQuestion;\r\n", " * Note that by design, even when no content is emitted by the protocol, an\r\n * empty {@link LastMemcacheContent} is issued to make the upstream parsing\r\n * easier.\r\n */\r\n@UnstableApi\r\n", "        }\r\n\r\n        int idx = hostname.indexOf('.');\r\n        if (idx == hostname.length() - 1) {\r\n            // We are not interested in handling '.' as we should never serve the root servers from cache.\r\n", "     * Decodes an {@link InetAddress} from an A or AAAA {@link DnsRawRecord}.\r\n     *\r\n     * @param record the {@link DnsRecord}, most likely a {@link DnsRawRecord}\r\n     * @param name the host name of the decoded address\r\n     * @param decodeIdn whether to convert {@code name} to a unicode host name\r\n", "    void copyMeta(AbstractBinaryMemcacheMessage dst) {\r\n        dst.magic = magic;\r\n        dst.opcode = opcode;\r\n        dst.keyLength = keyLength;\r\n        dst.extrasLength = extrasLength;\r\n", "        ByteBuf extras2 = Unpooled.copiedBuffer(\"extras!\", CharsetUtil.UTF_8);\r\n        try {\r\n            assertEquals(initialKeyLength, message.keyLength());\r\n            assertEquals(initialExtrasLength, message.extrasLength());\r\n            assertEquals(initialKeyLength + initialExtrasLength + contentLength, message.totalBodyLength());\r\n", "import org.apache.mina.core.buffer.IoBuffer;\r\nimport org.hamcrest.Matchers;\r\nimport org.junit.AfterClass;\r\nimport org.junit.BeforeClass;\r\nimport org.junit.Rule;\r\n", "        short oldExtrasLength = extrasLength;\r\n        extrasLength = extras == null ? 0 : (byte) extras.readableBytes();\r\n        totalBodyLength = totalBodyLength + extrasLength - oldExtrasLength;\r\n        return this;\r\n    }\r\n", "            }\r\n        }\r\n    }\r\n\r\n    private void query(final DnsServerAddressStream nameServerAddrStream,\r\n", "        EventLoopGroup group = new DefaultEventLoopGroup(1);\r\n\r\n        try {\r\n            EventLoop loop = group.next();\r\n            final DefaultDnsCache cache = new DefaultDnsCache(1, 100, 100);\r\n", "        EventLoopGroup group = new DefaultEventLoopGroup(1);\r\n\r\n        try {\r\n            EventLoop loop = group.next();\r\n            final DefaultDnsCache cache = new DefaultDnsCache();\r\n", "        EventLoopGroup group = new DefaultEventLoopGroup(1);\r\n\r\n        try {\r\n            EventLoop loop = group.next();\r\n            final DefaultDnsCache cache = new DefaultDnsCache();\r\n", "     * <pre>\r\n     * DnsServerAddresses.sequential(DnsServerAddresses.defaultAddressList());\r\n     * </pre>\r\n     * </p>\r\n     */\r\n", "        };\r\n\r\n        // Java7 will strip of the \".\" so we need to adjust the expected dnsname. Both are valid in terms of the RFC\r\n        // so its ok.\r\n        String expectedDnsName = PlatformDependent.javaVersion() == 7 ?\r\n", "public abstract class AbstractMemcacheObjectAggregator<H extends MemcacheMessage> extends\r\n        MessageAggregator<MemcacheObject, H, MemcacheContent, FullMemcacheMessage> {\r\n\r\n    protected AbstractMemcacheObjectAggregator(int maxContentLength) {\r\n        super(maxContentLength);\r\n", "        EventLoopGroup group = new NioEventLoopGroup(1);\r\n\r\n        try {\r\n            EventLoop loop = group.next();\r\n            final DefaultDnsCache cache = new DefaultDnsCache(Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE);\r\n", "\r\n    private static final long serialVersionUID = 8372151874317596185L;\r\n\r\n    private final Class<? extends InetAddress> preferredAddressType;\r\n\r\n", "     * Sets the extras buffer on the message. {@link ByteBuf#release()} ownership of {@code extras}\r\n     * is transferred to this {@link BinaryMemcacheMessage}.\r\n     *\r\n     * @param extras the extras buffer of the document. {@link ByteBuf#release()} ownership is transferred\r\n     *               to this {@link BinaryMemcacheMessage}.\r\n", "    @Override\r\n    public void clear() {\r\n        resolveCache.clear();\r\n    }\r\n\r\n", "        }\r\n    }\r\n\r\n    @Test\r\n    public void testResolveAllEmptyIpv4() {\r\n", "    @Test\r\n    public void testInvalidSpdyGoAwayFrameLength() throws Exception {\r\n        short type = 7;\r\n        byte flags = 0;\r\n        int length = 12; // invalid length\r\n", "package io.netty.resolver.dns;\r\n\r\nimport io.netty.channel.socket.InternetProtocolFamily;\r\nimport org.junit.Assert;\r\nimport org.junit.Test;\r\n", "package io.netty.resolver.dns;\r\n\r\nimport io.netty.util.NetUtil;\r\nimport io.netty.util.internal.SocketUtils;\r\nimport io.netty.util.internal.logging.InternalLogger;\r\n", "import io.netty.channel.AddressedEnvelope;\r\nimport io.netty.channel.Channel;\r\nimport io.netty.channel.ChannelFactory;\r\nimport io.netty.channel.ChannelFuture;\r\nimport io.netty.channel.ChannelFutureListener;\r\n", "        if (maxTtl == 0 || !emptyAdditionals(additionals)) {\r\n            return e;\r\n        }\r\n        resolveCache.cache(appendDot(hostname), e, Math.max(minTtl, (int) Math.min(maxTtl, originalTtl)), loop);\r\n        return e;\r\n", "                final List<String> list = (List<String>) nameservers.invoke(instance);\r\n                for (String a: list) {\r\n                    if (a != null) {\r\n                        defaultNameServers.add(new InetSocketAddress(SocketUtils.addressByName(a), DNS_PORT));\r\n                    }\r\n", "        int len = hostname.length();\r\n\r\n        if (len == 0) {\r\n            // We never cache for root servers.\r\n            return null;\r\n", "package io.netty.resolver.dns;\r\n\r\nimport java.util.List;\r\n\r\n/**\r\n", "import static org.hamcrest.MatcherAssert.assertThat;\r\nimport static org.hamcrest.Matchers.instanceOf;\r\nimport static org.hamcrest.Matchers.not;\r\nimport static org.hamcrest.core.StringContains.containsString;\r\nimport static org.junit.Assert.assertEquals;\r\n", "    protected void sortEntries(\r\n            @SuppressWarnings(\"unused\") String hostname, @SuppressWarnings(\"unused\") List<E> entries) {\r\n        // NOOP.\r\n    }\r\n\r\n", "        }\r\n    }\r\n\r\n    @Test\r\n    public void fullReplace() {\r\n", "\r\n        // First message first content chunk\r\n        MemcacheContent content = channel.readInbound();\r\n        assertThat(content, instanceOf(LastMemcacheContent.class));\r\n        assertThat(content.content().toString(CharsetUtil.UTF_8), is(msgBody));\r\n", "import io.netty.util.internal.StringUtil;\r\nimport io.netty.util.internal.SuppressJava6Requirement;\r\nimport io.netty.util.internal.ThrowableUtil;\r\n\r\nimport java.net.InetAddress;\r\n", "                            break;\r\n                        default:\r\n                            return null;\r\n                    }\r\n                } else {\r\n", "                }\r\n            } catch (Exception ignore) {\r\n                // Failed to get the system name server list via reflection.\r\n                // Will add the default name servers afterwards.\r\n            }\r\n", "            return nameServerCount == 0;\r\n        }\r\n\r\n        /**\r\n         * Creates a new {@link List} which holds the {@link InetSocketAddress}es.\r\n", "            {InternetProtocolFamily.IPv6, InternetProtocolFamily.IPv4};\r\n\r\n    static final ResolvedAddressTypes DEFAULT_RESOLVE_ADDRESS_TYPES;\r\n    static final String[] DEFAULT_SEARCH_DOMAINS;\r\n    private static final UnixResolverOptions DEFAULT_OPTIONS;\r\n", "            final DnsRecordType type = r.type();\r\n            boolean matches = false;\r\n            for (DnsRecordType expectedType : expectedTypes) {\r\n                if (type == expectedType) {\r\n                    matches = true;\r\n", "                            domainName = line.substring(i);\r\n                            if (!addresses.isEmpty()) {\r\n                                putIfAbsent(domainToNameServerStreamMap, domainName, addresses, rotate);\r\n                            }\r\n                            addresses = new ArrayList<InetSocketAddress>(2);\r\n", "                    List<E> entries = get();\r\n                    if (!entries.isEmpty()) {\r\n                        final E firstEntry = entries.get(0);\r\n                        if (shouldReplaceAll(firstEntry)) {\r\n                            assert entries.size() == 1;\r\n", "        DEFAULT_NAME_SERVER_LIST = Collections.unmodifiableList(defaultNameServers);\r\n        DEFAULT_NAME_SERVERS = sequential(DEFAULT_NAME_SERVER_LIST);\r\n    }\r\n\r\n    private DefaultDnsServerAddressStreamProvider() {\r\n", "package io.netty.resolver.dns;\r\n\r\nimport java.net.InetAddress;\r\n\r\n/**\r\n", "        }\r\n\r\n        void setAttempts(int attempts) {\r\n            this.attempts = attempts;\r\n        }\r\n", "import io.netty.util.CharsetUtil;\r\nimport org.junit.After;\r\nimport org.junit.Before;\r\nimport org.junit.Test;\r\n\r\n", "import io.netty.util.CharsetUtil;\r\nimport org.junit.After;\r\nimport org.junit.Before;\r\nimport org.junit.Test;\r\n\r\n", "\r\nimport io.netty.buffer.ByteBuf;\r\nimport io.netty.buffer.ByteBufHolder;\r\nimport io.netty.handler.codec.dns.DnsRawRecord;\r\nimport io.netty.handler.codec.dns.DnsRecord;\r\n", "        if (minTtl > maxTtl) {\r\n            throw new IllegalArgumentException(\r\n                    \"minTtl: \" + minTtl + \", maxTtl: \" + maxTtl + \" (expected: 0 <= minTtl <= maxTtl)\");\r\n        }\r\n    }\r\n", "import java.util.Collections;\r\nimport java.util.Comparator;\r\nimport java.util.Enumeration;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\n", "        int length = 8 * numSettings + 8; // invalid length\r\n        byte idFlags = 0;\r\n        int id = RANDOM.nextInt() & 0x00FFFFFF;\r\n        int value = RANDOM.nextInt();\r\n\r\n", "        }\r\n        return name + '.';\r\n    }\r\n\r\n    // Resolve the final name from the CNAME cache until there is nothing to follow anymore. This also\r\n", "                AuthoritativeNameServer server, AuthoritativeDnsServerCache authoritativeCache, EventLoop loop) {\r\n            // We still want to cached the unresolved address\r\n            server.address = InetSocketAddress.createUnresolved(\r\n                    server.nsName, DefaultDnsServerAddressStreamProvider.DNS_PORT);\r\n\r\n", "                logger.warn(\r\n                        \"Default DNS servers: {} (Google Public DNS as a fallback)\", defaultNameServers);\r\n            }\r\n        }\r\n\r\n", "     * Unfortunately, there are only handful of domain names with IPv6 addresses.\r\n     */\r\n    private static final Set<String> EXCLUSIONS_RESOLVE_AAAA = new HashSet<String>();\r\n\r\n    static {\r\n", "    BinaryMemcacheMessage setOpaque(int opaque);\r\n\r\n    /**\r\n     * Returns the CAS identifier.\r\n     *\r\n", "            \"xvideos.com\",\r\n            \"ebay.com\",\r\n            \"yahoo.co.jp\",\r\n            \"google.ca\",\r\n            \"google.com.mx\",\r\n", "\r\n            for (int i = 0; i < 2; i++) {\r\n                txts.addAll(decodeTxt(response.recordAt(DnsSection.ANSWER, i)));\r\n            }\r\n            assertTrue(txts.contains(txt1));\r\n", "    public void testUnknownSpdyPingFrameFlags() throws Exception {\r\n        short type = 6;\r\n        byte flags = (byte) 0xFF; // undefined flags\r\n        int length = 4;\r\n        int id = RANDOM.nextInt();\r\n", " * <p/>\r\n * For example, here for the binary protocol:\r\n * <p/>\r\n * <pre>\r\n * {@link ChannelPipeline} p = ...;\r\n", "    public static final byte GAT = 0x1d;\r\n    public static final byte GATQ = 0x1e;\r\n    public static final byte GATK = 0x23;\r\n    public static final byte GATKQ = 0x24;\r\n    public static final byte SASL_LIST_MECHS = 0x20;\r\n", "                continue;\r\n            }\r\n\r\n            boolean shouldRelease = false;\r\n            // Check if we did determine we wanted to complete early before. If this is the case we want to not\r\n", "import io.netty.handler.codec.memcache.DefaultLastMemcacheContent;\r\nimport io.netty.handler.codec.memcache.DefaultMemcacheContent;\r\nimport io.netty.util.CharsetUtil;\r\nimport org.junit.Test;\r\n\r\n", "    /**\r\n     * Returns the {@code {@link AuthoritativeNameServerList} which were included in {@link DnsSection#AUTHORITY}\r\n     * or {@code null} if non are found.\r\n     */\r\n    private static AuthoritativeNameServerList extractAuthoritativeNameServers(String questionName, DnsResponse res) {\r\n", "        private final InetAddress address;\r\n        private final Throwable cause;\r\n\r\n        DefaultDnsCacheEntry(String hostname, InetAddress address) {\r\n            this.hostname = hostname;\r\n", "                    rm.put(DnsAttribute.DOMAIN_NAME, \"foo.service.netty.io\");\r\n                    rm.put(DnsAttribute.SERVICE_PORT, \"8080\");\r\n                    rm.put(DnsAttribute.SERVICE_PRIORITY, \"10\");\r\n                    rm.put(DnsAttribute.SERVICE_WEIGHT, \"1\");\r\n                    records.add(rm.getEntry());\r\n", "import io.netty.util.internal.logging.InternalLogLevel;\r\nimport io.netty.util.internal.logging.InternalLogger;\r\n\r\nimport java.net.InetSocketAddress;\r\nimport java.util.List;\r\n", "import io.netty.handler.codec.memcache.LastMemcacheContent;\r\nimport io.netty.handler.codec.memcache.MemcacheContent;\r\nimport io.netty.util.CharsetUtil;\r\nimport io.netty.util.ReferenceCounted;\r\nimport org.junit.After;\r\n", "                        case A:\r\n                            rm.put(DnsAttribute.IP_ADDRESS, ipv4Addr);\r\n                            break;\r\n                        case AAAA:\r\n                            rm.put(DnsAttribute.IP_ADDRESS, ipv6Addr);\r\n", "            // results to the enduser if one of the A or AAAA records has different TTL settings.\r\n            //\r\n            // As a TTL is just a hint of the maximum time a cache is allowed to cache stuff it's\r\n            // completely fine to remove the entry even if the TTL is not reached yet.\r\n            //\r\n", "                int additionalCount = res.count(DnsSection.ADDITIONAL);\r\n\r\n                AuthoritativeDnsServerCache authoritativeDnsServerCache = authoritativeDnsServerCache();\r\n                for (int i = 0; i < additionalCount; i++) {\r\n                    final DnsRecord r = res.recordAt(DnsSection.ADDITIONAL, i);\r\n", "            }\r\n            case READ_CONTENT: try {\r\n                int valueLength = currentMessage.totalBodyLength()\r\n                    - currentMessage.keyLength()\r\n                    - currentMessage.extrasLength();\r\n", "\r\n    private EmbeddedChannel channel;\r\n\r\n    @Before\r\n    public void setup() throws Exception {\r\n", "            copiedBuilder.negativeTtl(negativeTtl);\r\n        }\r\n\r\n        if (authoritativeDnsServerCache != null) {\r\n            copiedBuilder.authoritativeDnsServerCache(authoritativeDnsServerCache);\r\n", "            }\r\n        };\r\n\r\n        EventLoop loop = group.next();\r\n        DefaultDnsCache cache = new DefaultDnsCache();\r\n", "\r\n    @Override\r\n    protected void doResolveAll(String inetHost, Promise<List<InetAddress>> promise) throws Exception {\r\n        doResolveAll(inetHost, EMPTY_ADDITIONALS, promise, resolveCache);\r\n    }\r\n", "                    rm.setDnsClass(RecordClass.IN);\r\n                    rm.setDnsName(question.getDomainName());\r\n                    rm.setDnsTtl(100);\r\n                    rm.setDnsType(RecordType.CNAME);\r\n                    rm.put(DnsAttribute.DOMAIN_NAME, lastName);\r\n", "package io.netty.resolver.dns;\r\n\r\nimport io.netty.util.internal.SocketUtils;\r\nimport io.netty.util.internal.logging.InternalLogger;\r\nimport io.netty.util.internal.logging.InternalLoggerFactory;\r\n", "                    rm.setDnsTtl(10);\r\n                    rm.setDnsType(RecordType.CNAME);\r\n                    rm.put(DnsAttribute.DOMAIN_NAME, \"alias.service.netty.io\");\r\n                    records.add(rm.getEntry());\r\n\r\n", "    @Override\r\n    public byte opcode() {\r\n        return opcode;\r\n    }\r\n\r\n", "import io.netty.handler.codec.dns.DefaultDnsRecordDecoder;\r\nimport io.netty.handler.codec.dns.DnsQuestion;\r\nimport io.netty.handler.codec.dns.DnsRawRecord;\r\nimport io.netty.handler.codec.dns.DnsRecord;\r\nimport io.netty.handler.codec.dns.DnsRecordType;\r\n", "package io.netty.resolver.dns;\r\n\r\nimport io.netty.buffer.ByteBuf;\r\nimport io.netty.buffer.ByteBufHolder;\r\nimport io.netty.channel.AddressedEnvelope;\r\n", "import static io.netty.util.internal.ObjectUtil.checkNotNull;\r\n\r\n/**\r\n * {@link AuthoritativeDnsServerCache} implementation which delegates all operations to a wrapped {@link DnsCache}.\r\n * This implementation is only present to preserve a upgrade story.\r\n", "                assertEquals(unresolved, entries.next());\r\n                assertEquals(resolved, entries.next());\r\n            } else {\r\n                assertEquals(resolved, entries.next());\r\n                assertEquals(unresolved, entries.next());\r\n", "            default:\r\n                throw new IllegalArgumentException(\"Unknown ResolvedAddressTypes \" + resolvedAddressTypes);\r\n        }\r\n        preferredAddressType = preferredAddressType(this.resolvedAddressTypes);\r\n        this.authoritativeDnsServerCache = checkNotNull(authoritativeDnsServerCache, \"authoritativeDnsServerCache\");\r\n", "    }\r\n\r\n    /**\r\n     * Returns the list of the system DNS server addresses. If it failed to retrieve the list of the system DNS server\r\n     * addresses from the environment, it will return {@code \"8.8.8.8\"} and {@code \"8.8.4.4\"}, the addresses of the\r\n", "\r\n    static {\r\n        if (NetUtil.isIpV4StackPreferred() || !anyInterfaceSupportsIpV6()) {\r\n            DEFAULT_RESOLVE_ADDRESS_TYPES = ResolvedAddressTypes.IPV4_ONLY;\r\n            LOCALHOST_ADDRESS = NetUtil.LOCALHOST4;\r\n", "     *\r\n     * @param ctx the channel handler context.\r\n     * @param msg the message to encode.\r\n     * @return the {@link ByteBuf} representation of the message.\r\n     */\r\n", "package io.netty.resolver.dns;\r\n\r\n/**\r\n * Represents options defined in a file of the format <a href=https://linux.die.net/man/5/resolver>etc/resolv.conf</a>.\r\n */\r\n", "\r\n        assertThat(request.keyLength(), is((short) 3));\r\n        assertThat(request.extrasLength(), is((byte) 0));\r\n        assertThat(request.totalBodyLength(), is(3));\r\n\r\n", "\r\nimport static org.junit.Assert.assertEquals;\r\nimport static org.junit.Assert.assertNotNull;\r\nimport static org.junit.Assert.assertNull;\r\nimport static org.junit.Assert.assertSame;\r\n", "import org.junit.Test;\r\n\r\nimport java.net.InetAddress;\r\nimport java.util.Collections;\r\nimport java.util.List;\r\n", "        testFollowNsRedirects(NoopDnsCache.INSTANCE, NoopAuthoritativeDnsServerCache.INSTANCE, false);\r\n    }\r\n\r\n    @Test\r\n    public void testFollowNsRedirectsNoopDnsCache() throws Exception {\r\n", "            return null;\r\n        }\r\n\r\n        // We start from the closed match and then move down.\r\n        for (;;) {\r\n", "        testCNAMERecursiveResolve(true);\r\n    }\r\n\r\n    @Test\r\n    public void testCNAMEResolveAllIpv6() throws IOException {\r\n", "package io.netty.resolver.dns;\r\n\r\nimport io.netty.channel.AddressedEnvelope;\r\nimport io.netty.channel.Channel;\r\nimport io.netty.channel.ChannelFuture;\r\n", "        alreadyReadChunkSize = 0;\r\n    }\r\n\r\n    /**\r\n     * Decode and return the parsed {@link BinaryMemcacheMessage}.\r\n", "\r\n        Assert.assertEquals(Arrays.asList(ipv4Address1, ipv4Address2, ipv4Address3, ipv6Address1,\r\n                ipv6Address2, ipv6Address3), addressList);\r\n    }\r\n\r\n", "\r\n    @Test\r\n    public void testProgressivelyDiscardUnknownEmptyFrame() throws Exception {\r\n        short type = 5;\r\n        byte flags = (byte) 0xFF;\r\n", "        this.addresses = addresses;\r\n\r\n        shuffle();\r\n    }\r\n\r\n", "            assertEquals(4, redirected.size());\r\n            assertEquals(4, cached.size());\r\n\r\n            if (reversed) {\r\n                assertEquals(ns4Address, redirected.next());\r\n", "import io.netty.channel.ChannelFutureListener;\r\nimport io.netty.channel.ChannelPromise;\r\nimport io.netty.handler.codec.dns.AbstractDnsOptPseudoRrRecord;\r\nimport io.netty.handler.codec.dns.DnsQuery;\r\nimport io.netty.handler.codec.dns.DnsQuestion;\r\n", "     * Get the number of times {@link #next()} will return a distinct element before repeating or terminating.\r\n     * @return the number of times {@link #next()} will return a distinct element before repeating or terminating.\r\n     */\r\n    int size();\r\n\r\n", "\r\n    private static final TestDnsServer dnsServer = new TestDnsServer(DOMAINS_ALL);\r\n    private static final EventLoopGroup group = new NioEventLoopGroup(1);\r\n\r\n    @Rule\r\n", "            if (questionName.length() <  r.name().length()) {\r\n                return;\r\n            }\r\n\r\n            String recordName = r.name().toLowerCase(Locale.US);\r\n", "        NameServerComparator comparator = new NameServerComparator(Inet4Address.class);\r\n\r\n        Collections.sort(addresses, comparator);\r\n\r\n        assertEquals(expected, addresses);\r\n", "    private static final byte[] SET_REQUEST_WITH_CONTENT = {\r\n        (byte) 0x80, 0x01, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x00,\r\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x6f, 0x6f, 0x01, 0x02, 0x03, 0x04, 0x05,\r\n        0x06, 0x07, 0x08\r\n    };\r\n", "import io.netty.util.internal.StringUtil;\r\nimport io.netty.util.internal.logging.InternalLogger;\r\nimport io.netty.util.internal.logging.InternalLoggerFactory;\r\n\r\nimport java.lang.reflect.Method;\r\n", "import java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.regex.Pattern;\r\n\r\n", "\r\n    /**\r\n     * Sets the {@link ChannelFactory} as a {@link ReflectiveChannelFactory} of this type.\r\n     * Use as an alternative to {@link #channelFactory(ChannelFactory)}.\r\n     *\r\n", "            \"xnxx.com\",\r\n            \"googleusercontent.com\",\r\n            \"savefrom.net\",\r\n            \"google.com.pk\",\r\n            \"amazon.in\",\r\n", "                return null;\r\n            }\r\n        }).authoritativeDnsServerCache(new DnsCache() {\r\n            @Override\r\n            public void clear() {\r\n", "        resolveCache.clear();\r\n    }\r\n\r\n    @Override\r\n    public boolean clear(String hostname) {\r\n", " * Represents a full {@link BinaryMemcacheRequest}, which contains the header and optional key and extras.\r\n */\r\n@UnstableApi\r\npublic interface BinaryMemcacheRequest extends BinaryMemcacheMessage {\r\n\r\n", "     *\r\n     * @param in the incoming buffer.\r\n     * @return the decoded header.\r\n     */\r\n    protected abstract M decodeHeader(ByteBuf in);\r\n", "        content = channel.readInbound();\r\n        assertThat(content, instanceOf(LastMemcacheContent.class));\r\n        assertThat(content.content().toString(CharsetUtil.UTF_8), is(msgBody.substring(7, 9)));\r\n        content.release();\r\n\r\n", "\r\n    @Override\r\n    public DnsCacheEntry cache(String hostname, DnsRecord[] additional,\r\n                               InetAddress address, long originalTtl, EventLoop loop) {\r\n        return new NoopDnsCacheEntry(address);\r\n", "import org.junit.Test;\r\nimport org.junit.rules.ExpectedException;\r\n\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\n", "     * has been called.\r\n     */\r\n    @Override\r\n    public void close() {\r\n        if (ch.isOpen()) {\r\n", "// FIXME(trustin): Find a better name and move it to the 'resolver' module.\r\nfinal class InflightNameResolver<T> implements NameResolver<T> {\r\n\r\n    private final EventExecutor executor;\r\n    private final NameResolver<T> delegate;\r\n", "\r\n    /**\r\n     * Sets the TTL of the cache for the failed DNS queries (in seconds).\r\n     *\r\n     * @param negativeTtl the TTL for failed cached queries\r\n", "        return rotational0(sanitize(addresses));\r\n    }\r\n\r\n    private static DnsServerAddresses rotational0(List<InetSocketAddress> addresses) {\r\n        if (addresses.size() == 1) {\r\n", " * </ol>\r\n * OR\r\n * <ol>\r\n *     <li>Object creation</li>\r\n *     <li>{@link #queryWritten(InetSocketAddress, ChannelFuture)}</li>\r\n", "        rm.setDnsClass(RecordClass.IN);\r\n        rm.setDnsName(name);\r\n        rm.setDnsTtl(100);\r\n        rm.setDnsType(type);\r\n        rm.put(DnsAttribute.IP_ADDRESS, address);\r\n", "\r\n    /**\r\n     * Caches a failed resolution.\r\n     */\r\n    abstract void cache(String hostname, DnsRecord[] additionals,\r\n", "        rm.setDnsClass(RecordClass.IN);\r\n        rm.setDnsName(dnsname);\r\n        rm.setDnsTtl(100);\r\n        rm.setDnsType(RecordType.NS);\r\n        rm.put(DnsAttribute.DOMAIN_NAME, domainName);\r\n", "import io.netty.handler.codec.dns.DefaultDnsOptEcsRecord;\r\nimport io.netty.handler.codec.dns.DnsRecord;\r\nimport io.netty.util.internal.SocketUtils;\r\nimport io.netty.util.concurrent.Future;\r\nimport org.junit.Ignore;\r\n", "            for (String name : DOMAINS) {\r\n                if (EXCLUSIONS_QUERY_MX.contains(name)) {\r\n                    continue;\r\n                }\r\n\r\n", "        group = new NioEventLoopGroup(1);\r\n    }\r\n\r\n    @After\r\n    public void destroy() {\r\n", "     * Creates a new builder.\r\n     */\r\n    public DnsNameResolverBuilder() {\r\n    }\r\n\r\n", " * Represents a full {@link BinaryMemcacheResponse}, which contains the header and optional key and extras.\r\n */\r\n@UnstableApi\r\npublic interface BinaryMemcacheResponse extends BinaryMemcacheMessage {\r\n\r\n", "                            int i = indexOfNonWhiteSpace(line, DOMAIN_ROW_LABEL.length());\r\n                            if (i < 0) {\r\n                                throw new IllegalArgumentException(\"error parsing label \" + DOMAIN_ROW_LABEL +\r\n                                        \" in file \" + etcResolverFile + \" value: \" + line);\r\n                            }\r\n", "\r\n        @Override\r\n        protected DnsMessage filterMessage(DnsMessage message) {\r\n            // Clear the answers as we want to add our own stuff to test dns redirects.\r\n            message.getAnswerRecords().clear();\r\n", "     * <ul>\r\n     *     <li>IO Error</li>\r\n     *     <li>Server responded with an invalid DNS response</li>\r\n     *     <li>Server responded with a valid DNS response, but it didn't progress the resolution</li>\r\n     * </ul>\r\n", "            \"pornhub.com\",\r\n            \"t.co\",\r\n            \"google.es\",\r\n            \"twitch.tv\",\r\n            \"alipay.com\",\r\n", "        assertEquals(expected.keyLength(), actual.keyLength());\r\n        assertEquals(expected.extrasLength(), actual.extrasLength());\r\n        assertEquals(expected.dataType(), actual.dataType());\r\n        assertEquals(expected.totalBodyLength(), actual.totalBodyLength());\r\n        assertEquals(expected.opaque(), actual.opaque());\r\n", "                rm.setDnsTtl(100);\r\n                rm.setDnsType(RecordType.CNAME);\r\n\r\n                if (question.getDomainName().equals(firstName)) {\r\n                    rm.put(DnsAttribute.DOMAIN_NAME, secondName);\r\n", "    public static final short DELTA_BADVAL = 0x06;\r\n    public static final short AUTH_ERROR = 0x20;\r\n    public static final short AUTH_CONTINUE = 0x21;\r\n    public static final short UNKNOWN_COMMAND = 0x81;\r\n    public static final short ENOMEM = 0x82;\r\n", "\r\n    /**\r\n     * Creates a new {@link AddressResolver}. Override this method to create an alternative {@link AddressResolver}\r\n     * implementation or override the default configuration.\r\n     */\r\n", "\r\n    /**\r\n     * Encode the key.\r\n     *\r\n     * @param buf the {@link ByteBuf} to write into.\r\n", "     * @throws IOException If a failure occurs parsing the file.\r\n     */\r\n    static List<String> parseEtcResolverSearchDomains() throws IOException {\r\n        return parseEtcResolverSearchDomains(new File(ETC_RESOLV_CONF_FILE));\r\n    }\r\n", "package io.netty.resolver.dns;\r\n\r\nimport io.netty.util.internal.PlatformDependent;\r\nimport io.netty.util.internal.logging.InternalLogger;\r\nimport io.netty.util.internal.logging.InternalLoggerFactory;\r\n", "            final DefaultDnsCnameCache cache = new DefaultDnsCnameCache();\r\n            cache.cache(\"x.netty.io\", \"mapping.netty.io\", 100000, loop);\r\n            cache.cache(\"y.netty.io\", \"mapping.netty.io\", 100000, loop);\r\n\r\n            assertEquals(\"mapping.netty.io\", cache.get(\"x.netty.io\"));\r\n", "            this.hostname = hostname;\r\n            this.cause = cause;\r\n            address = null;\r\n        }\r\n\r\n", "    }\r\n\r\n    private static final class TestDnsCache implements DnsCache {\r\n        final DnsCache cache;\r\n        final Map<String, List<? extends DnsCacheEntry>> cacheHits =\r\n", "    final String[] searchDomains() {\r\n        return searchDomains;\r\n    }\r\n\r\n    final int ndots() {\r\n", " */\r\n@UnstableApi\r\npublic interface BinaryMemcacheMessage extends MemcacheMessage {\r\n\r\n    /**\r\n", "        NameServerComparator comparator = new NameServerComparator(Inet6Address.class);\r\n\r\n        Collections.sort(addresses, comparator);\r\n\r\n        assertEquals(expected, addresses);\r\n", "\r\n    /**\r\n     * If the DNS query failed this will provide the rational.\r\n     * @return the rational for why the DNS query failed, or {@code null} if the query hasn't failed.\r\n     */\r\n", "            int count = response.count(DnsSection.ANSWER);\r\n\r\n            assertEquals(1, count);\r\n            List<String> texts = decodeTxt(response.recordAt(DnsSection.ANSWER, 0));\r\n            assertEquals(1, texts.size());\r\n", "import static io.netty.resolver.dns.DefaultDnsServerAddressStreamProvider.DNS_PORT;\r\nimport static io.netty.util.internal.ObjectUtil.checkNotNull;\r\nimport static io.netty.util.internal.StringUtil.indexOfNonWhiteSpace;\r\nimport static io.netty.util.internal.StringUtil.indexOfWhiteSpace;\r\n\r\n", "\r\nimport static io.netty.util.internal.ObjectUtil.checkNotNull;\r\nimport static io.netty.util.internal.ObjectUtil.checkPositiveOrZero;\r\n\r\n/**\r\n", "\r\n    private DnsCnameCache newCnameCache() {\r\n        return new DefaultDnsCnameCache(\r\n                intValue(minTtl, 0), intValue(maxTtl, Integer.MAX_VALUE));\r\n    }\r\n", "import org.junit.Before;\r\nimport org.junit.Test;\r\n\r\nimport static org.junit.Assert.assertEquals;\r\nimport static org.junit.Assert.assertNotSame;\r\n", "import org.junit.Before;\r\nimport org.junit.Test;\r\n\r\nimport static org.junit.Assert.assertEquals;\r\nimport static org.junit.Assert.assertNotSame;\r\n", "/**\r\n * Provides an infinite sequence of DNS server addresses to {@link DnsNameResolver}.\r\n */\r\n@SuppressWarnings(\"IteratorNextCanNotThrowNoSuchElementException\")\r\npublic abstract class DnsServerAddresses {\r\n", "package io.netty.resolver.dns;\r\n\r\nimport java.net.InetSocketAddress;\r\n\r\nimport static io.netty.resolver.dns.DnsServerAddresses.sequential;\r\n", "    public DnsNameResolver(\r\n            EventLoop eventLoop,\r\n            ChannelFactory<? extends DatagramChannel> channelFactory,\r\n            final DnsCache resolveCache,\r\n            final AuthoritativeDnsServerCache authoritativeDnsServerCache,\r\n", "     * @param cause The cause which for the failure.\r\n     */\r\n    void queryFailed(Throwable cause);\r\n\r\n    /**\r\n", "            nonCompliantDnsServer.stop();\r\n        }\r\n    }\r\n\r\n    private static void testRecursiveResolveCache(boolean cache)\r\n", "package io.netty.resolver.dns;\r\n\r\nimport io.netty.bootstrap.Bootstrap;\r\nimport io.netty.buffer.ByteBuf;\r\nimport io.netty.buffer.Unpooled;\r\n", "    private ChannelFactory<? extends SocketChannel> socketChannelFactory;\r\n    private DnsCache resolveCache;\r\n    private DnsCnameCache cnameCache;\r\n    private AuthoritativeDnsServerCache authoritativeDnsServerCache;\r\n    private Integer minTtl;\r\n", "\r\n            // Replace the previous key\r\n            message.setKey(key2.retain());\r\n            assertEquals(key2.readableBytes(), message.keyLength());\r\n            assertEquals(extras.readableBytes(), message.extrasLength());\r\n", "    void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future);\r\n\r\n    /**\r\n     * The query may have been written but it was cancelled at some point.\r\n     * @param queriesRemaining The number of queries remaining.\r\n", "    /**\r\n     * The query has been written.\r\n     * @param dnsServerAddress The DNS server address which the query was sent to.\r\n     * @param future The future which represents the status of the write operation for the DNS query.\r\n     */\r\n", "\r\nimport javax.naming.Context;\r\nimport javax.naming.NamingException;\r\nimport javax.naming.directory.DirContext;\r\nimport javax.naming.directory.InitialDirContext;\r\n", "                assertNull(nsEntry.cause());\r\n\r\n                List<? extends DnsCacheEntry> ns2Cached = cache.get(ns2Name + '.', null);\r\n                if (invalidNsFirst) {\r\n                    assertEquals(1, ns2Cached.size());\r\n", "     * Sets the maximum allowed number of DNS queries to send when resolving a host name.\r\n     *\r\n     * @param maxQueriesPerResolve the max number of queries\r\n     * @return {@code this}\r\n     */\r\n", " * Represents the results from a previous DNS query which can be cached.\r\n */\r\npublic interface DnsCacheEntry {\r\n    /**\r\n     * Get the resolved address.\r\n", "     *\r\n     * @param key    the message key.\r\n     * @param extras the message extras.\r\n     */\r\n    protected AbstractBinaryMemcacheMessage(ByteBuf key, ByteBuf extras) {\r\n", "import static org.junit.Assert.assertFalse;\r\nimport static org.junit.Assert.assertTrue;\r\n\r\npublic class SpdyHeaderBlockRawDecoderTest {\r\n\r\n", "        int length = 8; // invalid length\r\n        int id = RANDOM.nextInt();\r\n\r\n        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeControlFrameHeader(buf, type, flags, length);\r\n", "                } finally {\r\n                    tryToFinishResolve(nameServerAddrStream, nameServerAddrStreamIndex, question,\r\n                                       // queryLifecycleObserver has already been terminated at this point so we must\r\n                                       // not allow it to be terminated again by tryToFinishResolve.\r\n                                       NoopDnsQueryLifecycleObserver.INSTANCE,\r\n", "        buf.append('[')\r\n           .append(nameServerAddr)\r\n           .append(\"] \")\r\n           .append(message)\r\n           .append(\" (no stack trace available)\");\r\n", "    }\r\n\r\n    /**\r\n     * Sets the timeout of each DNS query performed by this resolver (in milliseconds).\r\n     *\r\n", "        List<String> domains = UnixResolverDnsServerAddressStreamProvider.parseEtcResolverSearchDomains(f);\r\n        assertEquals(Arrays.asList(\"linecorp.local\", \"squarecorp.local\"), domains);\r\n    }\r\n\r\n    @Test\r\n", "            return;\r\n        }\r\n\r\n        buf.writeBytes(extras);\r\n    }\r\n", "\r\n/**\r\n * An alternative to Java's built-in domain name lookup mechanism that resolves a domain name asynchronously,\r\n * which supports the queries of an arbitrary DNS record type as well.\r\n */\r\n", "        List<InetSocketAddress> addresses = new ArrayList<InetSocketAddress>(\r\n                Arrays.asList(IPV6ADDRESS1, IPV4ADDRESS1, IPV6ADDRESS2, UNRESOLVED1, UNRESOLVED2, IPV4ADDRESS2));\r\n        NameServerComparator comparator = new NameServerComparator(Inet4Address.class);\r\n\r\n        Collections.sort(addresses, comparator);\r\n", "            assert shared;\r\n        }\r\n\r\n        // Override fillInStackTrace() so we not populate the backtrace via a native call and so leak the\r\n        // Classloader.\r\n", "    @Test\r\n    public void testUnknownSpdyHeadersFrameFlags() throws Exception {\r\n        short type = 8;\r\n        byte flags = (byte) 0xFE; // undefined flags\r\n        int length = 4;\r\n", "                                port = Integer.parseInt(maybeIP.substring(i + 1));\r\n                                maybeIP = maybeIP.substring(0, i);\r\n                            }\r\n                            addresses.add(SocketUtils.socketAddress(maybeIP, port));\r\n                        } else if (line.startsWith(DOMAIN_ROW_LABEL)) {\r\n", "            String[] searchDomains,\r\n            int ndots,\r\n            boolean decodeIdn) {\r\n        this(eventLoop, channelFactory, null, resolveCache, NoopDnsCnameCache.INSTANCE, authoritativeDnsServerCache,\r\n             dnsQueryLifecycleObserverFactory, queryTimeoutMillis, resolvedAddressTypes, recursionDesired,\r\n", "            br = new BufferedReader(fr);\r\n            String line;\r\n            while ((line = br.readLine()) != null) {\r\n                if (localDomain == null && line.startsWith(DOMAIN_ROW_LABEL)) {\r\n                    int i = indexOfNonWhiteSpace(line, DOMAIN_ROW_LABEL.length());\r\n", "     * @deprecated Use {@link DnsNameResolverBuilder}.\r\n     */\r\n    @Deprecated\r\n    public DnsNameResolver(\r\n            EventLoop eventLoop,\r\n", "            \"vk.com\",\r\n            \"live.com\",\r\n            \"sohu.com\",\r\n            \"instagram.com\",\r\n            \"google.co.jp\",\r\n", "import io.netty.channel.socket.nio.NioDatagramChannel;\r\nimport io.netty.resolver.AddressResolver;\r\nimport io.netty.util.concurrent.Future;\r\nimport io.netty.util.concurrent.FutureListener;\r\nimport io.netty.util.concurrent.Promise;\r\n", "\r\nimport java.net.InetSocketAddress;\r\nimport java.util.List;\r\n\r\nfinal class NoopDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\r\n", "\r\npackage io.netty.resolver.dns;\r\n\r\nimport io.netty.util.NetUtil;\r\nimport org.junit.Test;\r\n", "            this.address = address;\r\n            cause = null;\r\n        }\r\n\r\n        DefaultDnsCacheEntry(String hostname, Throwable cause) {\r\n", "    public SequentialDnsServerAddressStreamProvider(InetSocketAddress... addresses) {\r\n        super(sequential(addresses));\r\n    }\r\n\r\n    /**\r\n", "        testFollowNsRedirects(new DefaultDnsCache(), NoopAuthoritativeDnsServerCache.INSTANCE, false);\r\n    }\r\n\r\n    @Test\r\n    public void testFollowNsRedirectsDefaultCaches() throws Exception {\r\n", "import static org.hamcrest.MatcherAssert.assertThat;\r\nimport static org.hamcrest.Matchers.instanceOf;\r\nimport static org.junit.Assert.assertTrue;\r\n\r\npublic class DnsAddressResolverGroupTest {\r\n", "                }\r\n            } else if (!recipient().equals(that.recipient())) {\r\n                return false;\r\n            }\r\n\r\n", "        assertThat(written.readableBytes(), is(DEFAULT_HEADER_SIZE + keyLength));\r\n        written.skipBytes(DEFAULT_HEADER_SIZE);\r\n        assertThat(written.readSlice(keyLength).toString(CharsetUtil.UTF_8), equalTo(\"netty\"));\r\n        written.release();\r\n    }\r\n", "                if (question.getDomainName().equals(firstName)) {\r\n                    rm.setDnsType(RecordType.CNAME);\r\n                    rm.put(DnsAttribute.DOMAIN_NAME, secondName);\r\n                } else if (question.getDomainName().equals(lastName)) {\r\n                    rm.setDnsType(question.getRecordType());\r\n", "            // include the result\r\n            if (!completeEarly) {\r\n                completeEarly = isCompleteEarly(converted);\r\n            }\r\n\r\n", " * A {@link BinaryMemcacheMessage} always consists of a header and optional extras or/and\r\n * a key.\r\n *\r\n * @see BinaryMemcacheRequest\r\n * @see BinaryMemcacheResponse\r\n", "    /**\r\n     * Clears the resolved addresses of the specified host name from the cache of this resolver.\r\n     *\r\n     * @return {@code true} if and only if there was an entry for the specified host name in the cache and\r\n     *         it has been removed by this method\r\n", "        // We not expect the linked-list to be very long so a double-linked-list is overkill.\r\n        private AuthoritativeNameServer head;\r\n\r\n        private int nameServerCount;\r\n\r\n", "import java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.Collections;\r\nimport java.util.List;\r\n\r\n", "     * Returns the {@link DnsServerAddresses} that yields the system DNS server addresses sequentially. If it failed to\r\n     * retrieve the list of the system DNS server addresses from the environment, it will use {@code \"8.8.8.8\"} and\r\n     * {@code \"8.8.4.4\"}, the addresses of the Google public DNS servers.\r\n     * <p>\r\n     * This method has the same effect with the following code:\r\n", "        return this;\r\n    }\r\n\r\n    @Override\r\n    protected void deallocate() {\r\n", "    static {\r\n        Collections.addAll(\r\n                EXCLUSIONS_RESOLVE_A,\r\n                \"akamaihd.net\",\r\n                \"googleusercontent.com\",\r\n", "            // Avoid duplicate entries.\r\n            if (list.contains(f)) {\r\n                continue;\r\n            }\r\n\r\n", "package io.netty.handler.codec.memcache;\r\n\r\nimport io.netty.channel.ChannelHandler;\r\nimport io.netty.channel.ChannelPipeline;\r\nimport io.netty.handler.codec.MessageAggregator;\r\n", "                                    List<InetSocketAddress> addresses,\r\n                                    boolean rotate) {\r\n        // TODO(scott): sortlist is being ignored.\r\n        DnsServerAddresses addrs = rotate\r\n            ? DnsServerAddresses.rotational(addresses)\r\n", "\r\n/**\r\n * A {@link BinaryMemcacheResponse} that also includes the content.\r\n */\r\n@UnstableApi\r\n", "@UnstableApi\r\npublic class BinaryMemcacheObjectAggregator extends AbstractMemcacheObjectAggregator<BinaryMemcacheMessage> {\r\n\r\n    public BinaryMemcacheObjectAggregator(int maxContentLength) {\r\n        super(maxContentLength);\r\n", " * A {@link AddressResolverGroup} of {@link DnsNameResolver}s that supports random selection of destination addresses if\r\n * multiple are provided by the nameserver. This is ideal for use in applications that use a pool of connections, for\r\n * which connecting to a single resolved address would be inefficient.\r\n */\r\npublic class RoundRobinDnsAddressResolverGroup extends DnsAddressResolverGroup {\r\n", "        }\r\n\r\n        @Override\r\n        protected boolean equals(InetSocketAddress entry, InetSocketAddress otherEntry) {\r\n            if (PlatformDependent.javaVersion() >= 7) {\r\n", "    static final int DNS_PORT = 53;\r\n\r\n    static {\r\n        final List<InetSocketAddress> defaultNameServers = new ArrayList<InetSocketAddress>(2);\r\n        if (!PlatformDependent.isAndroid()) {\r\n", "package io.netty.resolver.dns;\r\n\r\nimport io.netty.channel.EventLoop;\r\n\r\nimport java.net.InetSocketAddress;\r\n", "package io.netty.resolver.dns;\r\n\r\nimport io.netty.channel.EventLoop;\r\n\r\nimport java.net.InetSocketAddress;\r\n", "            }\r\n\r\n            @SuppressWarnings(\"unchecked\")\r\n            final AddressedEnvelope<?, SocketAddress> that = (AddressedEnvelope<?, SocketAddress>) obj;\r\n            if (sender() == null) {\r\n", "\r\n    /**\r\n     * Hook designed for extensibility so one can pass a different cache on each resolution attempt\r\n     * instead of using the global one.\r\n     */\r\n", "\r\n    /**\r\n     * Hook designed for extensibility so one can pass a different cache on each resolution attempt\r\n     * instead of using the global one.\r\n     */\r\n", "import static org.junit.Assert.*;\r\n\r\npublic class FullMemcacheMessageRequestTest {\r\n\r\n    private EmbeddedChannel channel;\r\n", "            assertEquals(2, entries.size());\r\n            assertEquals(unresolved, entries.next());\r\n            assertEquals(resolved1, entries.next());\r\n\r\n            cache.cache(\"netty.io\", resolved2, 100, loop);\r\n", "    }\r\n\r\n    public DefaultLastMemcacheContent(ByteBuf content) {\r\n        super(content);\r\n    }\r\n", "        EXCLUSIONS_RESOLVE_AAAA.addAll(EXCLUSIONS_RESOLVE_A);\r\n        EXCLUSIONS_RESOLVE_AAAA.addAll(DOMAINS);\r\n        EXCLUSIONS_RESOLVE_AAAA.removeAll(Arrays.asList(\r\n                \"google.com\",\r\n                \"facebook.com\",\r\n", "        private static final long serialVersionUID = 1209303419266433003L;\r\n\r\n        private DnsResolveContextException(String message) {\r\n            super(message);\r\n        }\r\n", "import io.netty.handler.codec.EncoderException;\r\nimport io.netty.handler.codec.memcache.DefaultLastMemcacheContent;\r\nimport io.netty.handler.codec.memcache.DefaultMemcacheContent;\r\nimport io.netty.util.CharsetUtil;\r\nimport org.junit.After;\r\n", "package io.netty.resolver.dns;\r\n\r\nimport io.netty.channel.embedded.EmbeddedChannel;\r\nimport org.junit.Test;\r\n\r\n", "        }\r\n    }\r\n\r\n    private static Inet6Address toCompactAddress(Inet4Address a4) {\r\n        byte[] b4 = a4.getAddress();\r\n", "\r\n    /**\r\n     * Default magic byte for a request.\r\n     */\r\n    public static final byte REQUEST_MAGIC_BYTE = (byte) 0x80;\r\n", "    /**\r\n     * Sets the {@link ChannelFactory} as a {@link ReflectiveChannelFactory} of this type for\r\n     * <a href=\"https://tools.ietf.org/html/rfc7766\">TCP fallback</a> if needed.\r\n     * Use as an alternative to {@link #socketChannelFactory(ChannelFactory)}.\r\n     *\r\n", "        } finally {\r\n            group.shutdownGracefully();\r\n        }\r\n    }\r\n\r\n", "        } finally {\r\n            group.shutdownGracefully();\r\n        }\r\n    }\r\n\r\n", "package io.netty.resolver.dns;\r\n\r\nimport io.netty.channel.socket.InternetProtocolFamily;\r\n\r\nimport java.net.Inet4Address;\r\n", "            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e, 0x6f, 0x74, 0x20, 0x66, 0x6f,\r\n            0x75, 0x6e, 0x64\r\n    };\r\n\r\n    private EmbeddedChannel channel;\r\n", "    @Override\r\n    protected void deallocate() {\r\n        super.deallocate();\r\n        content.release();\r\n    }\r\n", "    @Override\r\n    protected void deallocate() {\r\n        super.deallocate();\r\n        content.release();\r\n    }\r\n", "                    rm = new ResourceRecordModifier();\r\n                    rm.setDnsClass(RecordClass.IN);\r\n                    rm.setDnsName(name);\r\n                    rm.setDnsTtl(10);\r\n                    rm.setDnsType(RecordType.SRV);\r\n", "\r\nimport static io.netty.resolver.dns.UnixResolverDnsServerAddressStreamProvider.parseEtcResolverOptions;\r\nimport static org.junit.Assert.assertEquals;\r\n\r\npublic class UnixResolverDnsServerAddressStreamProviderTest {\r\n", "                group.next(), new ReflectiveChannelFactory<DatagramChannel>(NioDatagramChannel.class),\r\n                NoopDnsCache.INSTANCE, authoritativeDnsServerCache,\r\n                NoopDnsQueryLifecycleObserverFactory.INSTANCE, 2000, ResolvedAddressTypes.IPV4_ONLY,\r\n                true, 10, true, 4096,\r\n                false, HostsFileEntriesResolver.DEFAULT,\r\n", "        boolean rotateGlobal = RES_OPTIONS != null && RES_OPTIONS.contains(OPTIONS_ROTATE_FLAG);\r\n        for (File etcResolverFile : etcResolverFiles) {\r\n            if (!etcResolverFile.isFile()) {\r\n                continue;\r\n            }\r\n", "import java.net.IDN;\r\nimport java.net.Inet4Address;\r\nimport java.net.Inet6Address;\r\nimport java.net.InetAddress;\r\nimport java.net.InetSocketAddress;\r\n", "package io.netty.handler.codec.memcache.binary;\r\n\r\nimport io.netty.buffer.ByteBuf;\r\nimport io.netty.handler.codec.memcache.AbstractMemcacheObjectAggregator;\r\nimport io.netty.handler.codec.memcache.FullMemcacheMessage;\r\n", "import java.net.InetAddress;\r\nimport java.net.InetSocketAddress;\r\nimport java.util.Comparator;\r\nimport java.util.List;\r\n\r\n", "     * An empty input will return the default value, based on \"java.net\" System properties.\r\n     * Valid inputs are (), (IPv4), (IPv6), (Ipv4, IPv6) and (IPv6, IPv4).\r\n     * @param internetProtocolFamilies a valid sequence of {@link InternetProtocolFamily}s\r\n     * @return a {@link ResolvedAddressTypes}\r\n     */\r\n", "    @Test\r\n    public void testDiscardUnknownFrame() throws Exception {\r\n        short type = 5;\r\n        byte flags = (byte) 0xFF;\r\n        int length = 8;\r\n", "\r\n                // Process all unresolved nameservers as well.\r\n                serverNames.handleWithoutAdditionals(parent, resolveCache(), authoritativeDnsServerCache);\r\n\r\n                List<InetSocketAddress> addresses = serverNames.addressList();\r\n", "import io.netty.handler.codec.PrematureChannelClosureException;\r\nimport io.netty.handler.codec.memcache.LastMemcacheContent;\r\nimport io.netty.util.internal.UnstableApi;\r\n\r\nimport java.util.List;\r\n", "\r\nabstract class DefaultDnsServerAddresses extends DnsServerAddresses {\r\n\r\n    protected final List<InetSocketAddress> addresses;\r\n    private final String strVal;\r\n", "package io.netty.resolver.dns;\r\n\r\nimport org.junit.BeforeClass;\r\nimport org.junit.Test;\r\n\r\n", "package io.netty.resolver.dns;\r\n\r\nimport io.netty.handler.codec.dns.DnsQuestion;\r\n\r\n/**\r\n", "        short type = 4;\r\n        byte flags = 0;\r\n        int numSettings = 2;\r\n        int length = 8 * numSettings + 4;\r\n        byte idFlags = 0;\r\n", "     */\r\n    private final class TestDnsProtocolUdpCodecFactory implements ProtocolCodecFactory {\r\n        private final DnsMessageEncoder encoder = new DnsMessageEncoder();\r\n        private final TestAAAARecordEncoder recordEncoder = new TestAAAARecordEncoder();\r\n        private final boolean dropAAAArecords;\r\n", "\r\n    // Using the top-100 web sites ranked in Alexa.com (Oct 2014)\r\n    // Please use the following series of shell commands to get this up-to-date:\r\n    // $ curl -O https://s3.amazonaws.com/alexa-static/top-1m.csv.zip\r\n    // $ unzip -o top-1m.csv.zip top-1m.csv\r\n", "                DnsNameResolver parent, DnsRecord r, AuthoritativeDnsServerCache authoritativeCache) {\r\n            // Just walk the linked-list and mark the entry as handled when matched.\r\n            AuthoritativeNameServer serverName = head;\r\n\r\n            String nsName = r.name();\r\n", "                        break;\r\n                    } else {\r\n                        // There was something else scheduled in the meantime... Cancel and try again.\r\n                        newFuture.cancel(true);\r\n                    }\r\n", "    }\r\n\r\n    @Test\r\n    public void testAllNameServers() throws IOException {\r\n        final String domain = \"netty.io\";\r\n", "    }\r\n\r\n    @Override\r\n    public long cas() {\r\n        return cas;\r\n", "    /**\r\n     * Every binary memcache message has at least a 24 bytes header.\r\n     */\r\n    private static final int MINIMUM_HEADER_SIZE = 24;\r\n\r\n", "                    }\r\n                });\r\n            }\r\n            cache.cache(\"netty.io\", unresolved, 100, loop);\r\n            cache.cache(\"netty.io\", resolved, 10000, loop);\r\n", " *     <li>{@link #queryRedirected(List)} or {@link #queryCNAMEd(DnsQuestion)} or\r\n *     {@link #queryNoAnswer(DnsResponseCode)} or {@link #queryCancelled(int)} or\r\n *     {@link #queryFailed(Throwable)} or {@link #querySucceed()}</li>\r\n * </ol>\r\n * <p>\r\n", "/**\r\n * Abstract super class for both ascii and binary decoders.\r\n * <p/>\r\n * Currently it just acts as a common denominator, but will certainly include methods once the ascii protocol\r\n * is implemented.\r\n", "        return channel;\r\n    }\r\n\r\n    @Override\r\n    protected String protocol() {\r\n", "    @Override\r\n    protected void doResolve(String inetHost, Promise<InetAddress> promise) throws Exception {\r\n        doResolve(inetHost, EMPTY_ADDITIONALS, promise, resolveCache);\r\n    }\r\n\r\n", "                Future<AddressedEnvelope<DnsResponse, InetSocketAddress>> f = i.next();\r\n                i.remove();\r\n\r\n                f.cancel(false);\r\n            }\r\n", "    /**\r\n     * Returns the TTL of the cache for the failed DNS queries (in seconds). The default value is {@code 0}, which\r\n     * disables the cache for negative results.\r\n     */\r\n    public int negativeTtl() {\r\n", "\r\n        buf.setLength(buf.length() - 2);\r\n        buf.append(')');\r\n\r\n        strVal = buf.toString();\r\n", "\r\n    /**\r\n     * Cache for {@link #doResolve(String, Promise)} and {@link #doResolveAll(String, Promise)}.\r\n     */\r\n    private final DnsCache resolveCache;\r\n", "                }\r\n\r\n                for (DnsRecordType expectedType : expectedTypes) {\r\n                    if (type == expectedType) {\r\n                        onExpectedResponse(question, envelope, queryLifecycleObserver, promise);\r\n", "\r\n                                assert address != null :\r\n                                        \"Cache returned a cached failure, should never return anything else\";\r\n\r\n                                AuthoritativeNameServer server = new AuthoritativeNameServer(serverName);\r\n", "    @Before\r\n    public void setUp() {\r\n        decoder = new SpdyHeaderBlockRawDecoder(SpdyVersion.SPDY_3_1, maxHeaderSize);\r\n        frame = new DefaultSpdyHeadersFrame(1);\r\n    }\r\n", "    public static final byte QUITQ = 0x17;\r\n    public static final byte FLUSHQ = 0x18;\r\n    public static final byte APPENDQ = 0x19;\r\n    public static final byte PREPENDQ = 0x1a;\r\n    public static final byte TOUCH = 0x1c;\r\n", "     * <p>\r\n     * This method has the same effect with the following code:\r\n     * <pre>\r\n     * DnsServerAddresses.sequential(DnsServerAddresses.defaultAddressList());\r\n     * </pre>\r\n", "\r\n        Decoder(int chunkSize) {\r\n            super(chunkSize);\r\n        }\r\n\r\n", "     * Returns the {@link DnsServerAddresses} that yields the specified {@code address} in a shuffled order. Once all\r\n     * addresses are yielded, the addresses are shuffled again.\r\n     */\r\n    public static DnsServerAddresses shuffled(Iterable<? extends InetSocketAddress> addresses) {\r\n        return shuffled0(sanitize(addresses));\r\n", "\r\nimport static io.netty.util.internal.ObjectUtil.checkNotNull;\r\nimport static io.netty.util.internal.ObjectUtil.intValue;\r\n\r\n/**\r\n", "            return false;\r\n        }\r\n        final InetSocketAddress nameServerAddr = nameServerAddr();\r\n\r\n        final StringBuilder buf = new StringBuilder(message.length() + 64);\r\n", "            assertEquals(3, cached.size());\r\n\r\n            // The redirected addresses should have been retrieven from the DnsCache if not resolved, so these are\r\n            // fully resolved.\r\n            assertEquals(ns0Address, redirected.next());\r\n", "\r\n    private static void assertEntry(DnsCacheEntry entry, InetAddress address) {\r\n        assertEquals(address, entry.address());\r\n        assertNull(entry.cause());\r\n    }\r\n", "     */\r\n    public DnsNameResolverBuilder(EventLoop eventLoop) {\r\n        eventLoop(eventLoop);\r\n    }\r\n\r\n", "package io.netty.resolver.dns;\r\n\r\nimport io.netty.channel.AddressedEnvelope;\r\nimport io.netty.channel.Channel;\r\nimport io.netty.handler.codec.dns.DefaultDnsQuery;\r\n", "     * The default value is {@code true}.\r\n     */\r\n    public boolean isRecursionDesired() {\r\n        return recursionDesired;\r\n    }\r\n", "\r\n            while (serverName != null) {\r\n                if (serverName.nsName.equalsIgnoreCase(nsName)) {\r\n                    if (serverName.address != null) {\r\n                        // We received multiple ADDITIONAL records for the same name.\r\n", "        public LastMemcacheContent replace(ByteBuf content) {\r\n            return new DefaultLastMemcacheContent(content);\r\n        }\r\n\r\n        @Override\r\n", "                assertEquals(ns2Address, redirected.next());\r\n                assertEquals(ns3Address, redirected.next());\r\n                assertEquals(ns4Address, redirected.next());\r\n            }\r\n\r\n", "     * @return {@code this}\r\n     * @deprecated Prefer to {@linkplain #dnsQueryLifecycleObserverFactory(DnsQueryLifecycleObserverFactory) configure}\r\n     * a {@link LoggingDnsQueryLifeCycleObserverFactory} instead.\r\n     */\r\n    @Deprecated\r\n", "            extras = extras.retainedDuplicate();\r\n        }\r\n        return newInstance(key, extras, content);\r\n    }\r\n\r\n", "            extras = extras.retainedDuplicate();\r\n        }\r\n        return newInstance(key, extras, content);\r\n    }\r\n\r\n", "     * order. It is similar to {@link #sequential(Iterable)}, but each {@link DnsServerAddressStream} starts from\r\n     * a different starting point.  For example, the first {@link #stream()} will start from the first address, the\r\n     * second one will start from the second address, and so on.\r\n     */\r\n    public static DnsServerAddresses rotational(InetSocketAddress... addresses) {\r\n", "        int length = 0; // invalid length\r\n\r\n        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeControlFrameHeader(buf, type, flags, length);\r\n\r\n", "    public void testRecursiveResolveCache() throws Exception {\r\n        testRecursiveResolveCache(true);\r\n    }\r\n\r\n    @Test\r\n", "                new HashMap<String, List<? extends DnsCacheEntry>>();\r\n\r\n        TestDnsCache(DnsCache cache) {\r\n            this.cache = cache;\r\n        }\r\n", "\r\n    @Test\r\n    public void testNegativeNameValuePairs() throws Exception {\r\n        ByteBuf headerBlock = Unpooled.buffer(4);\r\n        headerBlock.writeInt(-1);\r\n", "    @Override\r\n    public void cache(String hostname, String cname, long originalTtl, EventLoop loop) {\r\n        // NOOP\r\n    }\r\n\r\n", "     * Sets the CAS identifier.\r\n     *\r\n     * @param cas the CAS identifier to use.\r\n     */\r\n    BinaryMemcacheMessage setCas(long cas);\r\n", "    protected abstract ByteBuf encodeMessage(ChannelHandlerContext ctx, M msg);\r\n\r\n    /**\r\n     * Determine the content length of the given object.\r\n     *\r\n", "\r\npackage io.netty.resolver.dns;\r\n\r\nimport io.netty.buffer.ByteBuf;\r\nimport io.netty.buffer.ByteBufHolder;\r\n", "import io.netty.util.internal.UnstableApi;\r\n\r\n/**\r\n * An Memcache content chunk.\r\n * <p/>\r\n", "                    }\r\n                    return;\r\n                }\r\n\r\n                final Throwable queryCause = future.cause();\r\n", "                lastName = nextName;\r\n            }\r\n            cache.cache(lastName, HOSTNAME, Long.MAX_VALUE, channel.eventLoop());\r\n        }\r\n        return cache;\r\n", "    private static final byte[] GET_REQUEST = {\r\n        (byte) 0x80, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,\r\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x6f, 0x6f\r\n    };\r\n\r\n", "                        SocketUtils.socketAddress(\"2001:4860:4860::8888\", DNS_PORT),\r\n                        SocketUtils.socketAddress(\"2001:4860:4860::8844\", DNS_PORT));\r\n            } else {\r\n                Collections.addAll(\r\n                        defaultNameServers,\r\n", "            }\r\n\r\n            @Override\r\n            public DnsCacheEntry cache(\r\n                    String hostname, DnsRecord[] additionals, Throwable cause, EventLoop loop) {\r\n", "        }\r\n\r\n        resolveCache.cache(hostname, address, Math.max(minTtl, (int) Math.min(maxTtl, originalTtl)), loop);\r\n    }\r\n\r\n", "                for (int i = 0; i < numEntries; i++) {\r\n                    final DnsCacheEntry e = cachedEntries.get(i);\r\n                    if (f.addressType().isInstance(e.address())) {\r\n                        if (result == null) {\r\n                            result = new ArrayList<InetAddress>(numEntries);\r\n", "\r\npackage io.netty.resolver.dns;\r\n\r\nimport java.net.InetSocketAddress;\r\n\r\n", "\r\npackage io.netty.resolver.dns;\r\n\r\nimport java.net.InetSocketAddress;\r\n\r\n", "        }\r\n\r\n        @Override\r\n        public boolean equals(Object obj) {\r\n            if (this == obj) {\r\n", "    }\r\n\r\n    /**\r\n     * We need to override this method, not\r\n     * {@link #newNameResolver(EventLoop, ChannelFactory, DnsServerAddressStreamProvider)},\r\n", "        final String lastName = \"lastname.nettybar.com\";\r\n        final String ipv4Addr = \"1.2.3.4\";\r\n        final String ipv6Addr = \"::1\";\r\n        final AtomicBoolean hitServer2 = new AtomicBoolean();\r\n        final TestDnsServer dnsServer2 = new TestDnsServer(new RecordStore() {\r\n", "import java.util.concurrent.TimeUnit;\r\n\r\npublic class DnsNameResolverClientSubnetTest {\r\n\r\n    // See https://www.gsic.uva.es/~jnisigl/dig-edns-client-subnet.html\r\n", "            return;\r\n        }\r\n\r\n        --allowedQueries;\r\n\r\n", "\r\n    @SuppressWarnings(\"unchecked\")\r\n    @Override\r\n    public String get(String hostname) {\r\n        List<? extends String> cached =  cache.get(checkNotNull(hostname, \"hostname\"));\r\n", "                    String hostname, List<InetSocketAddress> nameservers) {\r\n                if (reversed) {\r\n                    Collections.reverse(nameservers);\r\n                }\r\n                DnsServerAddressStream stream = new SequentialDnsServerAddressStream(nameservers, 0);\r\n", "import java.net.InetAddress;\r\nimport java.net.InetSocketAddress;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n", "package io.netty.resolver.dns;\r\n\r\nimport io.netty.handler.codec.dns.DnsQuestion;\r\nimport io.netty.util.internal.EmptyArrays;\r\nimport io.netty.util.internal.ObjectUtil;\r\n", "package io.netty.resolver.dns;\r\n\r\nimport io.netty.channel.EventLoop;\r\nimport io.netty.util.internal.PlatformDependent;\r\n\r\n", "package io.netty.resolver.dns;\r\n\r\nimport io.netty.channel.EventLoop;\r\nimport io.netty.util.internal.PlatformDependent;\r\n\r\n", "            boolean decodeIdn) {\r\n        this(eventLoop, channelFactory, resolveCache,\r\n             new AuthoritativeDnsServerCacheAdapter(authoritativeDnsServerCache), dnsQueryLifecycleObserverFactory,\r\n             queryTimeoutMillis, resolvedAddressTypes, recursionDesired, maxQueriesPerResolve, traceEnabled,\r\n             maxPayloadSize, optResourceEnabled, hostsFileEntriesResolver, dnsServerAddressStreamProvider,\r\n", "\r\npackage io.netty.resolver.dns;\r\n\r\nimport io.netty.channel.ChannelFactory;\r\nimport io.netty.channel.EventLoop;\r\n", "\r\npackage io.netty.resolver.dns;\r\n\r\nimport io.netty.channel.ChannelFactory;\r\nimport io.netty.channel.EventLoop;\r\n", "        checkNotNull(hostname, \"hostname\");\r\n        if (!emptyAdditionals(additionals)) {\r\n            return Collections.<DnsCacheEntry>emptyList();\r\n        }\r\n\r\n", "\r\n    final InternetProtocolFamily preferredAddressType() {\r\n        return preferredAddressType;\r\n    }\r\n\r\n", "package io.netty.resolver.dns;\r\n\r\nimport io.netty.util.internal.ObjectUtil;\r\n\r\n/**\r\n", "                    }\r\n                } while (resolved != null);\r\n\r\n                if (resolved == null) {\r\n                    continue;\r\n", "package io.netty.resolver.dns;\r\n\r\nimport io.netty.util.NetUtil;\r\nimport io.netty.util.internal.PlatformDependent;\r\nimport io.netty.util.internal.SocketUtils;\r\n", "     *\r\n     * @return the {@link InetAddress}, or {@code null} if {@code record} is not a {@link DnsRawRecord} or\r\n     *         its content is malformed\r\n     */\r\n    static InetAddress decodeAddress(DnsRecord record, String name, boolean decodeIdn) {\r\n", "        final DnsNameResolver resolver = new DnsNameResolverBuilder(group.next())\r\n                .dnsQueryLifecycleObserverFactory(new TestRecursiveCacheDnsQueryLifecycleObserverFactory())\r\n                .channelType(NioDatagramChannel.class)\r\n                .optResourceEnabled(false)\r\n                .nameServerProvider(nameServerProvider)\r\n", "                    rm.setDnsTtl(100);\r\n                    rm.setDnsType(RecordType.CNAME);\r\n                    rm.put(DnsAttribute.DOMAIN_NAME, lastName);\r\n                    return Collections.singleton(rm.getEntry());\r\n                }\r\n", "            this.ttl = min(this.ttl, ttl);\r\n        }\r\n\r\n        void update(InetSocketAddress address) {\r\n            update(address, Long.MAX_VALUE);\r\n", "import java.net.InetSocketAddress;\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\nimport java.util.List;\r\n\r\n", "     * Google public DNS servers.\r\n     */\r\n    public static List<InetSocketAddress> defaultAddressList() {\r\n        return DEFAULT_NAME_SERVER_LIST;\r\n    }\r\n", "        return opaque;\r\n    }\r\n\r\n    @Override\r\n    public BinaryMemcacheMessage setOpaque(int opaque) {\r\n", "\r\npackage io.netty.resolver.dns;\r\n\r\nimport io.netty.util.NetUtil;\r\nimport io.netty.util.collection.IntObjectHashMap;\r\n", "    private static InetSocketAddress IPV6ADDRESS2;\r\n\r\n    private static InetSocketAddress UNRESOLVED1;\r\n    private static InetSocketAddress UNRESOLVED2;\r\n    private static InetSocketAddress UNRESOLVED3;\r\n", "        List<InetSocketAddress> addresses = new ArrayList<InetSocketAddress>(expected);\r\n        NameServerComparator comparator = new NameServerComparator(Inet6Address.class);\r\n\r\n        Collections.sort(addresses, comparator);\r\n\r\n", "            \"livejasmin.com\",\r\n            \"amazon.co.jp\",\r\n            \"deloton.com\",\r\n            \"apple.com\",\r\n            \"google.com.au\",\r\n", "        final AuthoritativeDnsServerCache cache;\r\n        final Map<String, DnsServerAddressStream> cacheHits = new HashMap<String, DnsServerAddressStream>();\r\n\r\n        TestAuthoritativeDnsServerCache(AuthoritativeDnsServerCache cache) {\r\n            this.cache = cache;\r\n", "    }\r\n\r\n    /**\r\n     * @deprecated Use {@link DefaultDnsServerAddressStreamProvider#defaultAddresses()}.\r\n     * <p>\r\n", "\r\n    UnixResolverOptions(int ndots, int timeout, int attempts) {\r\n        this.ndots = ndots;\r\n        this.timeout = timeout;\r\n        this.attempts = attempts;\r\n", "            events.add(new QuerySucceededEvent());\r\n        }\r\n    }\r\n\r\n    private static final class TestAuthoritativeDnsServerCache implements AuthoritativeDnsServerCache {\r\n", "    public void testRecursiveResolveNoCache() throws Exception {\r\n        testRecursiveResolveCache(false);\r\n    }\r\n\r\n    @Test\r\n", "            }\r\n        } finally {\r\n            dnsServer2.stop();\r\n        }\r\n    }\r\n", "            \"blogspot.com\",\r\n            \"detail.tmall.com\",\r\n            \"google.pl\",\r\n            \"microsoftonline.com\",\r\n            \"xhamster.com\",\r\n", "            // Skip '.' as well.\r\n            hostname = hostname.substring(idx + 1);\r\n\r\n            int idx2 = hostname.indexOf('.');\r\n            if (idx2 <= 0 || idx2 == hostname.length() - 1) {\r\n", "            return e;\r\n        }\r\n\r\n        resolveCache.cache(appendDot(hostname), e, negativeTtl, loop);\r\n        return e;\r\n", "import io.netty.handler.codec.dns.DnsRawRecord;\r\nimport io.netty.handler.codec.dns.DnsRecord;\r\nimport io.netty.handler.codec.dns.DnsRecordType;\r\nimport io.netty.handler.codec.dns.DnsResponse;\r\nimport io.netty.handler.codec.dns.DnsResponseCode;\r\n", "        }\r\n\r\n        void add(E e, int ttl, EventLoop loop) {\r\n            if (!shouldReplaceAll(e)) {\r\n                for (;;) {\r\n", "                        defaultNameServers.add(SocketUtils.socketAddress(uri.getHost(), port == -1 ?\r\n                                defaultPort : port));\r\n                    } catch (URISyntaxException e) {\r\n                        logger.debug(\"Skipping a malformed nameserver URI: {}\", server, e);\r\n                    }\r\n", "\r\n    @Test\r\n    public void testReservedSpdyGoAwayFrameBits() throws Exception {\r\n        short type = 7;\r\n        byte flags = 0;\r\n", "        buf.writeInt(msg.totalBodyLength());\r\n        buf.writeInt(msg.opaque());\r\n        buf.writeLong(msg.cas());\r\n    }\r\n\r\n", "        buf.writeInt(msg.totalBodyLength());\r\n        buf.writeInt(msg.opaque());\r\n        buf.writeLong(msg.cas());\r\n    }\r\n\r\n", "                return true;\r\n            }\r\n\r\n            if (!(obj instanceof AddressedEnvelope)) {\r\n                return false;\r\n", "\r\n    /**\r\n     * @deprecated Override {@link #newNameResolver(EventLoop, ChannelFactory, DnsServerAddressStreamProvider)}.\r\n     */\r\n    @Deprecated\r\n", "    /**\r\n     * The query returned a CNAME which we may attempt to follow with a new query.\r\n     * <p>\r\n     * Note that multiple queries may be encountering a CNAME. For example a if both {@link DnsRecordType#AAAA} and\r\n     * {@link DnsRecordType#A} are supported we may query for both.\r\n", " * A {@link ChannelHandler} that aggregates an {@link MemcacheMessage}\r\n * and its following {@link MemcacheContent}s into a single {@link MemcacheMessage} with\r\n * no following {@link MemcacheContent}s.  It is useful when you don't want to take\r\n * care of memcache messages where the content comes along in chunks. Insert this\r\n * handler after a AbstractMemcacheObjectDecoder in the {@link ChannelPipeline}.\r\n", "        Throwable cause = cachedEntries.get(0).cause();\r\n        if (cause == null) {\r\n            List<InetAddress> result = null;\r\n            final int numEntries = cachedEntries.size();\r\n            for (InternetProtocolFamily f : resolvedInternetProtocolFamilies) {\r\n", "    public BinaryMemcacheMessage setTotalBodyLength(int totalBodyLength) {\r\n        this.totalBodyLength = totalBodyLength;\r\n        return this;\r\n    }\r\n\r\n", "\r\npackage io.netty.resolver.dns;\r\n\r\nimport java.net.InetSocketAddress;\r\nimport java.util.Collection;\r\n", "             searchDomains, ndots, decodeIdn);\r\n    }\r\n\r\n    /**\r\n     * Creates a new DNS-based name resolver that communicates with the specified list of DNS servers.\r\n", "     * order. It is similar to {@link #sequential(Iterable)}, but each {@link DnsServerAddressStream} starts from\r\n     * a different starting point.  For example, the first {@link #stream()} will start from the first address, the\r\n     * second one will start from the second address, and so on.\r\n     */\r\n    public static DnsServerAddresses rotational(Iterable<? extends InetSocketAddress> addresses) {\r\n", "        assertThat(written.readSlice(extrasLength).toString(CharsetUtil.UTF_8), equalTo(extrasContent));\r\n        written.release();\r\n    }\r\n\r\n    @Test\r\n", "import io.netty.channel.socket.SocketChannel;\r\nimport io.netty.handler.codec.CorruptedFrameException;\r\nimport io.netty.handler.codec.dns.DatagramDnsQueryEncoder;\r\nimport io.netty.handler.codec.dns.DatagramDnsResponse;\r\nimport io.netty.handler.codec.dns.DatagramDnsResponseDecoder;\r\n", "import io.netty.channel.socket.DatagramChannel;\r\nimport io.netty.resolver.AddressResolver;\r\nimport io.netty.resolver.AddressResolverGroup;\r\nimport io.netty.resolver.InetSocketAddressResolver;\r\nimport io.netty.resolver.NameResolver;\r\n", "\r\n    /**\r\n     * Private singleton constructor.\r\n     */\r\n    private NoopDnsCache() {\r\n", "                                         allowedQueries,\r\n                                         resolveCache,\r\n                                         redirectAuthoritativeDnsServerCache(authoritativeDnsServerCache()), false)\r\n                    .resolve(resolverPromise);\r\n        }\r\n", "                            if (i < 0) {\r\n                                throw new IllegalArgumentException(\"error parsing label \" + NAMESERVER_ROW_LABEL +\r\n                                        \" in file \" + etcResolverFile + \". value: \" + line);\r\n                            }\r\n                            String maybeIP;\r\n", "public final class DnsNameResolverTimeoutException extends DnsNameResolverException {\r\n    private static final long serialVersionUID = -8826717969627131854L;\r\n\r\n    public DnsNameResolverTimeoutException(\r\n            InetSocketAddress remoteAddress, DnsQuestion question, String message) {\r\n", "                        do {\r\n                            attr.put(DnsAttribute.IP_ADDRESS.toLowerCase(Locale.US), nextIp());\r\n                        } while (PlatformDependent.threadLocalRandom().nextBoolean());\r\n                        break;\r\n                    case AAAA:\r\n", "import java.io.IOException;\r\nimport java.net.InetSocketAddress;\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\nimport java.util.Collections;\r\n", "     * Returns the resolution cache.\r\n     */\r\n    public DnsCache resolveCache() {\r\n        return resolveCache;\r\n    }\r\n", " * <p>Note that this class is designed to be extended, especially because both the binary and ascii protocol\r\n * require different treatment of their messages. Since the content chunk writing is the same for both, the encoder\r\n * abstracts this right away.</p>\r\n */\r\n@UnstableApi\r\n", "import io.netty.util.concurrent.Future;\r\nimport org.junit.After;\r\nimport org.junit.Before;\r\nimport org.junit.Test;\r\n\r\n", "        assertThat(content, instanceOf(MemcacheContent.class));\r\n        assertThat(content.content().toString(CharsetUtil.UTF_8), is(msgBody.substring(0, 7)));\r\n        content.release();\r\n\r\n        // Second message second content chunk\r\n", "        assertThat(response.totalBodyLength(), is(msgBody.length()));\r\n        response.release();\r\n\r\n        // Second message first content chunk\r\n        content = channel.readInbound();\r\n", "     * Resolves the specified host name and port into a list of address.\r\n     *\r\n     * @param inetHost the name to resolve\r\n     * @param additionals additional records ({@code OPT})\r\n     * @param promise the {@link Promise} which will be fulfilled when the name resolution is finished\r\n", "package io.netty.resolver.dns;\r\n\r\nimport io.netty.channel.ChannelFactory;\r\nimport io.netty.channel.EventLoop;\r\nimport io.netty.channel.ReflectiveChannelFactory;\r\n", "    }\r\n\r\n    @Override\r\n    protected boolean isAggregated(MemcacheObject msg) throws Exception {\r\n        return msg instanceof FullMemcacheMessage;\r\n", "     */\r\n    void finish(AddressedEnvelope<? extends DnsResponse, InetSocketAddress> envelope) {\r\n        final DnsResponse res = envelope.content();\r\n        if (res.count(DnsSection.QUESTION) != 1) {\r\n            logger.warn(\"Received a DNS response with invalid number of questions: {}\", envelope);\r\n", "            }\r\n        }\r\n        entries.add(value, ttl, loop);\r\n    }\r\n\r\n", "                int idx = name.indexOf('.');\r\n                if (idx <= 0) {\r\n                    break;\r\n                }\r\n                name = name.substring(idx + 1); // skip the '.' as well.\r\n", "        int segment = 4;\r\n        int length = 2 * segment;\r\n\r\n        ByteBuf header = Unpooled.buffer(SPDY_HEADER_SIZE);\r\n        ByteBuf segment1 = Unpooled.buffer(segment);\r\n", "    /**\r\n     * Returns the {@link DnsServerAddressStream} that was cached for the given hostname or {@code null} if non\r\n     *  could be found.\r\n     */\r\n    private DnsServerAddressStream getNameServersFromCache(String hostname) {\r\n", "import org.junit.Before;\r\nimport org.junit.Test;\r\n\r\nimport java.util.ArrayDeque;\r\nimport java.util.Queue;\r\n", "\r\n        private static String nextDomain() {\r\n            return CHARS[index(CHARS.length)] + \".netty.io\";\r\n        }\r\n\r\n", "    private Integer maxTtl;\r\n    private Integer negativeTtl;\r\n    private long queryTimeoutMillis = -1;\r\n    private ResolvedAddressTypes resolvedAddressTypes = DnsNameResolver.DEFAULT_RESOLVE_ADDRESS_TYPES;\r\n    private boolean completeOncePreferredResolved;\r\n", "            message.getAuthorityRecords().clear();\r\n            message.getAdditionalRecords().clear();\r\n\r\n            String name = domain;\r\n            for (int i = 0 ;; i++) {\r\n", "                //                                not exist.\r\n                //                ....\r\n                //                ....\r\n                if (!res.isAuthoritativeAnswer()) {\r\n                    query(nameServerAddrStream, nameServerAddrStreamIndex + 1, question,\r\n", "package io.netty.resolver.dns;\r\n\r\nimport io.netty.handler.codec.dns.DnsQuestion;\r\n\r\nimport java.net.InetSocketAddress;\r\n", "\r\n            @SuppressWarnings({ \"unchecked\", \"CastConflictsWithInstanceof\" })\r\n            final M m = (M) msg;\r\n            out.add(encodeMessage(ctx, m));\r\n        }\r\n", "package io.netty.resolver.dns;\r\n\r\nimport io.netty.handler.codec.dns.DnsQuestion;\r\nimport io.netty.handler.logging.LogLevel;\r\nimport io.netty.util.internal.logging.InternalLogLevel;\r\n", "                        } else if (line.startsWith(PORT_ROW_LABEL)) {\r\n                            int i = indexOfNonWhiteSpace(line, PORT_ROW_LABEL.length());\r\n                            if (i < 0) {\r\n                                throw new IllegalArgumentException(\"error parsing label \" + PORT_ROW_LABEL +\r\n                                        \" in file \" + etcResolverFile + \" value: \" + line);\r\n", "            }\r\n        }\r\n\r\n        // It was not A/AAAA question or there was no entry in /etc/hosts.\r\n        final DnsServerAddressStream nameServerAddrs =\r\n", "\r\n        try {\r\n            EventLoop loop = group.next();\r\n            final DefaultDnsCache cache = new DefaultDnsCache(1, 100, 100);\r\n            cache.cache(\"netty.io\", null, addr1, 10000, loop);\r\n", "import io.netty.channel.EventLoopGroup;\r\nimport io.netty.channel.ReflectiveChannelFactory;\r\nimport io.netty.channel.nio.NioEventLoopGroup;\r\nimport io.netty.channel.socket.DatagramChannel;\r\nimport io.netty.channel.socket.DatagramPacket;\r\n", "                assertEquals(2, entries.size());\r\n                assertFalse(entries.next().isUnresolved());\r\n                assertTrue(entries.next().isUnresolved());\r\n\r\n                assertNull(nsCache.cache.get(hostname));\r\n", "import io.netty.handler.codec.dns.DnsSection;\r\nimport io.netty.resolver.HostsFileEntriesResolver;\r\nimport io.netty.resolver.ResolvedAddressTypes;\r\nimport io.netty.util.CharsetUtil;\r\nimport io.netty.util.NetUtil;\r\n", "public abstract class AbstractBinaryMemcacheMessage\r\n    extends AbstractMemcacheObject\r\n    implements BinaryMemcacheMessage {\r\n\r\n    /**\r\n", "            }\r\n        }\r\n    }\r\n\r\n    private final class Decoder extends BinaryMemcacheResponseDecoder {\r\n", "     */\r\n    byte dataType();\r\n\r\n    /**\r\n     * Sets the data type of the message.\r\n", "                completeOncePreferredResolved);\r\n    }\r\n\r\n    /**\r\n     * Creates a copy of this {@link DnsNameResolverBuilder}\r\n", "package io.netty.resolver.dns;\r\n\r\nimport io.netty.channel.EventLoop;\r\nimport io.netty.handler.codec.dns.DnsRecord;\r\nimport io.netty.util.internal.StringUtil;\r\n", "        header.setTotalBodyLength(in.readInt());\r\n        header.setOpaque(in.readInt());\r\n        header.setCas(in.readLong());\r\n        return header;\r\n    }\r\n", "        header.setTotalBodyLength(in.readInt());\r\n        header.setOpaque(in.readInt());\r\n        header.setCas(in.readLong());\r\n        return header;\r\n    }\r\n", "        int length = 8 * numSettings + 4;\r\n        byte idFlags = 0;\r\n        int id = RANDOM.nextInt() & 0x00FFFFFF;\r\n        int value = RANDOM.nextInt();\r\n\r\n", "\r\npackage io.netty.resolver.dns;\r\n\r\nimport java.net.InetSocketAddress;\r\nimport java.util.List;\r\n", "\r\npackage io.netty.resolver.dns;\r\n\r\nimport java.net.InetSocketAddress;\r\nimport java.util.List;\r\n", "    /**\r\n     * Create a new instance.\r\n     * @param addresses The addresses which will be be returned in sequential order via\r\n     * {@link #nameServerAddressStream(String)}\r\n     */\r\n", "\r\n    /**\r\n     * Create a new {@link DnsCacheEntry} and cache a resolved address for a given hostname.\r\n     * @param hostname the hostname\r\n     * @param additionals the additional records\r\n", "        return this;\r\n    }\r\n\r\n    @Override\r\n    public int opaque() {\r\n", "                new TestRecursiveCacheDnsQueryLifecycleObserverFactory();\r\n        EventLoopGroup group = new NioEventLoopGroup(1);\r\n        final DnsNameResolver resolver = new DnsNameResolver(\r\n                group.next(), new ReflectiveChannelFactory<DatagramChannel>(NioDatagramChannel.class),\r\n                NoopDnsCache.INSTANCE, nsCache, lifecycleObserverFactory, 3000, ResolvedAddressTypes.IPV4_ONLY, true,\r\n", "\r\n/**\r\n * Combines two {@link DnsQueryLifecycleObserver} into a single {@link DnsQueryLifecycleObserver}.\r\n */\r\npublic final class BiDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\r\n", "package io.netty.resolver.dns;\r\n\r\nimport static io.netty.resolver.dns.DnsAddressDecoder.decodeAddress;\r\n\r\nimport java.net.InetAddress;\r\n", "    public void cache(String hostname, InetSocketAddress address, long originalTtl, EventLoop loop) {\r\n        // NOOP\r\n    }\r\n\r\n    @Override\r\n", "            });\r\n        }\r\n    }\r\n\r\n    private void onQueryWriteCompletion(ChannelFuture writeFuture) {\r\n", "    private static final InternetProtocolFamily[] IPV6_ONLY_RESOLVED_PROTOCOL_FAMILIES =\r\n            {InternetProtocolFamily.IPv6};\r\n    private static final DnsRecordType[] IPV6_PREFERRED_RESOLVED_RECORD_TYPES =\r\n            {DnsRecordType.AAAA, DnsRecordType.A};\r\n    private static final InternetProtocolFamily[] IPV6_PREFERRED_RESOLVED_PROTOCOL_FAMILIES =\r\n", "    @Override\r\n    public boolean clear(String hostname) {\r\n        return resolveCache.clear(checkNotNull(hostname, \"hostname\"));\r\n    }\r\n\r\n", "import java.util.Arrays;\r\nimport java.util.Collections;\r\nimport java.util.HashMap;\r\nimport java.util.HashSet;\r\nimport java.util.Iterator;\r\n", "                \"google.com.au\",\r\n                \"google.pl\",\r\n                \"google.com.hk\",\r\n                \"blogspot.in\"\r\n        ));\r\n", "                        do {\r\n                            attr.put(DnsAttribute.IP_ADDRESS.toLowerCase(Locale.US), nextIp6());\r\n                        } while (PlatformDependent.threadLocalRandom().nextBoolean());\r\n                        break;\r\n                    case MX:\r\n", "package io.netty.handler.codec.spdy;\r\n\r\nimport io.netty.buffer.ByteBuf;\r\nimport io.netty.buffer.ByteBufAllocator;\r\nimport io.netty.buffer.Unpooled;\r\n", "\r\n        final List<InetSocketAddress> list;\r\n        if (addresses instanceof Collection) {\r\n            list = new ArrayList<InetSocketAddress>(((Collection<?>) addresses).size());\r\n        } else {\r\n", "   *\r\n   * @param ndots the ndots value\r\n   * @return {@code this}\r\n   */\r\n    public DnsNameResolverBuilder ndots(int ndots) {\r\n", "        final StringBuilder buf = new StringBuilder(type.length() + 2 + addresses.size() * 16);\r\n        buf.append(type).append(\"(index: \").append(index);\r\n        buf.append(\", addrs: (\");\r\n        for (InetSocketAddress a: addresses) {\r\n            buf.append(a).append(\", \");\r\n", "        return cnameCache;\r\n    }\r\n\r\n    /**\r\n     * Returns the cache used for authoritative DNS servers for a domain.\r\n", "\r\nimport java.net.InetSocketAddress;\r\nimport java.util.List;\r\n\r\nimport static io.netty.util.internal.ObjectUtil.checkNotNull;\r\n", "        DEFAULT_OPTIONS = options;\r\n    }\r\n\r\n    /**\r\n     * Returns {@code true} if any {@link NetworkInterface} supports {@code IPv6}, {@code false} otherwise.\r\n", "        DnsNameResolver resolver = newResolver().resolveCache(new DnsCache() {\r\n            @Override\r\n            public void clear() {\r\n                resolveLatch.countDown();\r\n            }\r\n", "        // We don't want include duplicates to mimic JDK behaviour.\r\n        return false;\r\n    }\r\n\r\n    @Override\r\n", "                modifier.setTransactionId(txnId);\r\n                new DnsMessageEncoder().encode(ioBuffer, modifier.getDnsMessage());\r\n                ioBuffer.flip();\r\n\r\n                ByteBuffer lenBuffer = ByteBuffer.allocate(2);\r\n", "        InetSocketAddress next = addresses.get(i);\r\n        if (++ i < addresses.size()) {\r\n            this.i = i;\r\n        } else {\r\n            this.i = 0;\r\n", "            EventLoop loop = group.next();\r\n            final DefaultAuthoritativeDnsServerCache cache = new DefaultAuthoritativeDnsServerCache();\r\n            cache.cache(\"netty.io\", resolved1, 100, loop);\r\n            cache.cache(\"netty.io\", resolved2, 10000, loop);\r\n\r\n", "                        // This is a hack to allow to also test for AAAA resolution as DnsMessageEncoder\r\n                        // does not support it and it is hard to extend, because the interesting methods\r\n                        // are private...\r\n                        // In case of RecordType.AAAA we need to encode the RecordType by ourselves.\r\n                        if (record.getRecordType() == RecordType.AAAA) {\r\n", "            \"qq.com\",\r\n            \"amazon.com\",\r\n            \"taobao.com\",\r\n            \"tmall.com\",\r\n            \"twitter.com\",\r\n", "import java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\nimport java.util.Map;\r\n", "            } else {\r\n                shouldRelease = true;\r\n            }\r\n\r\n            cache(hostname, additionals, r, converted);\r\n", "            searchDomains = EmptyArrays.EMPTY_STRINGS;\r\n        }\r\n        DEFAULT_SEARCH_DOMAINS = searchDomains;\r\n\r\n        UnixResolverOptions options;\r\n", "import java.net.InetSocketAddress;\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.List;\r\n\r\n", "                    ResourceRecordModifier rm = new ResourceRecordModifier();\r\n                    rm.setDnsClass(RecordClass.IN);\r\n                    rm.setDnsName(question.getDomainName());\r\n                    rm.setDnsTtl(100);\r\n                    rm.setDnsType(question.getRecordType());\r\n", "                    // Cache the server now.\r\n                    cache(serverName, authoritativeCache, parent.executor());\r\n                    return;\r\n                }\r\n                serverName = serverName.next;\r\n", "            \"soso.com\",\r\n            \"espn.com\",\r\n            \"adobe.com\",\r\n            \"google.com.ua\",\r\n            \"tianya.cn\",\r\n", "\r\n    DefaultDnsServerAddresses(String type, List<InetSocketAddress> addresses) {\r\n        this.addresses = addresses;\r\n\r\n        final StringBuilder buf = new StringBuilder(type.length() + 2 + addresses.size() * 16);\r\n", "    }\r\n\r\n    private static String hostnameWithDot(String name) {\r\n        if (StringUtil.endsWith(name, '.')) {\r\n            return name;\r\n", "    BinaryMemcacheMessage setKey(ByteBuf key);\r\n\r\n    /**\r\n     * Returns a {@link ByteBuf} representation of the optional extras.\r\n     *\r\n", "    private final String[] searchDomains;\r\n    private final int ndots;\r\n    private final boolean supportsAAAARecords;\r\n    private final boolean supportsARecords;\r\n    private final InternetProtocolFamily preferredAddressType;\r\n", "                    // These will be resolved on the fly if needed.\r\n                    cacheUnresolved(serverName, authoritativeCache, parent.executor());\r\n\r\n                    // Try to resolve via cache as we had no ADDITIONAL entry for the server.\r\n\r\n", "\r\n            // If negative cache works, this thread should be done really quickly.\r\n            final Thread negativeLookupThread = new Thread() {\r\n                @Override\r\n                public void run() {\r\n", "        FullBinaryMemcacheRequest read = channel.readInbound();\r\n        assertThat(read, notNullValue());\r\n        assertThat(read.key().toString(CharsetUtil.UTF_8), is(\"Netty\"));\r\n        assertThat(read.extras().toString(CharsetUtil.UTF_8), is(\"extras\"));\r\n        assertThat(read.content().toString(CharsetUtil.UTF_8), is(\"Netty Rocks!\"));\r\n", "\r\n    @Test\r\n    public void testCNAMERecursiveResolveDifferentNameServersForDomains() throws IOException {\r\n        final String firstName = \"firstname.com\";\r\n        final String secondName = \"secondname.com\";\r\n", "     * Create a cache that respects the TTL returned by the DNS server.\r\n     */\r\n    public DefaultDnsCnameCache() {\r\n        this(0, Cache.MAX_SUPPORTED_TTL_SECS);\r\n    }\r\n", "        List<InetSocketAddress> expected = Arrays.asList(\r\n                IPV4ADDRESS1, IPV4ADDRESS2, IPV6ADDRESS1, IPV6ADDRESS2, UNRESOLVED1, UNRESOLVED2);\r\n\r\n        List<InetSocketAddress> addresses = new ArrayList<InetSocketAddress>(expected);\r\n        NameServerComparator comparator = new NameServerComparator(Inet4Address.class);\r\n", "    @Override\r\n    FullMemcacheMessage touch();\r\n\r\n    @Override\r\n    FullMemcacheMessage touch(Object hint);\r\n", "\r\n    @Override\r\n    protected Channel channel() {\r\n        return parent().ch;\r\n    }\r\n", "     */\r\n    private static boolean anyInterfaceSupportsIpV6() {\r\n        try {\r\n            Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();\r\n            while (interfaces.hasMoreElements()) {\r\n", "            int maxQueriesPerResolve,\r\n            boolean traceEnabled,\r\n            int maxPayloadSize,\r\n            boolean optResourceEnabled,\r\n            HostsFileEntriesResolver hostsFileEntriesResolver,\r\n", "        short type = 4;\r\n        byte flags = 0;\r\n        int numSettings = 1;\r\n        int length = 8 * numSettings + 4;\r\n        byte idFlags = (byte) 0xFC; // undefined flags\r\n", "            \"csdn.net\",\r\n            \"wikia.com\",\r\n            \"wordpress.com\",\r\n            \"office.com\",\r\n            \"google.com.tr\",\r\n", "            }\r\n        });\r\n        DnsCache resolveCache = resolveCache();\r\n        if (!DnsNameResolver.doResolveAllCached(nameServerName, additionals, resolverPromise, resolveCache,\r\n                parent.resolvedInternetProtocolFamiliesUnsafe())) {\r\n", "\r\n    final void flushQueries() {\r\n        ch.flush();\r\n    }\r\n\r\n", "            boolean traceEnabled,\r\n            int maxPayloadSize,\r\n            boolean optResourceEnabled,\r\n            HostsFileEntriesResolver hostsFileEntriesResolver,\r\n            DnsServerAddressStreamProvider dnsServerAddressStreamProvider,\r\n", "import java.net.UnknownHostException;\r\nimport java.util.Collections;\r\nimport java.util.List;\r\n\r\nimport io.netty.channel.EventLoop;\r\n", "            if (values.isEmpty()) {\r\n                throw new IllegalArgumentException(etcResolvConf + \" didn't provide any name servers\");\r\n            }\r\n            this.defaultNameServerAddresses = values.iterator().next();\r\n        } else {\r\n", "            ResolvedAddressTypes resolvedAddressTypes,\r\n            boolean recursionDesired,\r\n            int maxQueriesPerResolve,\r\n            boolean traceEnabled,\r\n            int maxPayloadSize,\r\n", "            // Cache NS record if not for a root server as we should never cache for root servers.\r\n            if (!server.isRootServer()) {\r\n                cache.cache(server.domainName, server.address, server.ttl, loop);\r\n            }\r\n        }\r\n", "import io.netty.channel.ChannelHandlerContext;\r\nimport io.netty.channel.ChannelInboundHandlerAdapter;\r\nimport io.netty.channel.ChannelInitializer;\r\nimport io.netty.channel.ChannelOption;\r\nimport io.netty.channel.ChannelPromise;\r\n", "                .channelType(NioDatagramChannel.class)\r\n                .maxQueriesPerResolve(1)\r\n                .decodeIdn(decodeToUnicode)\r\n                .optResourceEnabled(false)\r\n                .ndots(1);\r\n", "    }\r\n\r\n    @Test\r\n    public void testMultipleCnamesForSameHostname() throws Exception {\r\n        EventLoopGroup group = new DefaultEventLoopGroup(1);\r\n", "            final DefaultDnsCnameCache cache = new DefaultDnsCnameCache();\r\n            cache.cache(\"netty.io\", \"mapping.netty.io\", 1, loop);\r\n\r\n            Throwable error = loop.schedule(new Callable<Throwable>() {\r\n                @Override\r\n", "    public DnsNameResolverBuilder ttl(int minTtl, int maxTtl) {\r\n        this.maxTtl = maxTtl;\r\n        this.minTtl = minTtl;\r\n        return this;\r\n    }\r\n", "            if (cache != NoopDnsCache.INSTANCE) {\r\n                List<? extends DnsCacheEntry> ns1Cached = cache.get(ns1Name + '.', null);\r\n                assertEquals(1, ns1Cached.size());\r\n                DnsCacheEntry nsEntry = ns1Cached.get(0);\r\n                assertNotNull(nsEntry.address());\r\n", "    }\r\n\r\n    @SuppressWarnings(\"unchecked\")\r\n    private static List<String> getSearchDomainsHack() throws Exception {\r\n        // Only try if not using Java9 and later\r\n", "\r\n    @Override\r\n    public byte magic() {\r\n        return magic;\r\n    }\r\n", "                final int answerCount = response.count(DnsSection.ANSWER);\r\n                final List<DnsRecord> mxList = new ArrayList<DnsRecord>(answerCount);\r\n                for (int i = 0; i < answerCount; i++) {\r\n                    final DnsRecord r = response.recordAt(DnsSection.ANSWER, i);\r\n                    if (r.type() == DnsRecordType.MX) {\r\n", "            throw new IllegalStateException(\"eventLoop should be specified to build a DnsNameResolver.\");\r\n        }\r\n\r\n        if (resolveCache != null && (minTtl != null || maxTtl != null || negativeTtl != null)) {\r\n            throw new IllegalStateException(\"resolveCache and TTLs are mutually exclusive\");\r\n", "        short type = 9;\r\n        byte flags = (byte) 0xFF; // undefined flags\r\n        int length = 8;\r\n        int streamId = RANDOM.nextInt() & 0x7FFFFFFF;\r\n        int deltaWindowSize = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;\r\n", "package io.netty.resolver.dns;\r\n\r\nimport io.netty.channel.ChannelFuture;\r\nimport io.netty.handler.codec.dns.DnsQuestion;\r\nimport io.netty.handler.codec.dns.DnsRecordType;\r\n", "        } else {\r\n            if (NetUtil.isIpV6AddressesPreferred()) {\r\n                DEFAULT_RESOLVE_ADDRESS_TYPES = ResolvedAddressTypes.IPV6_PREFERRED;\r\n                LOCALHOST_ADDRESS = NetUtil.LOCALHOST6;\r\n            } else {\r\n", "                if (EXCLUSIONS_RESOLVE_A.contains(name)) {\r\n                    continue;\r\n                }\r\n                if (PlatformDependent.threadLocalRandom().nextBoolean()) {\r\n                    overriddenHostnames.add(name);\r\n", "        for (String f : searchDomains) {\r\n            if (f == null) {\r\n                break;\r\n            }\r\n\r\n", "import io.netty.util.internal.logging.InternalLogger;\r\nimport io.netty.util.internal.logging.InternalLoggerFactory;\r\n\r\nimport static io.netty.util.internal.ObjectUtil.checkNotNull;\r\n\r\n", "    private static final Set<String> EXCLUSIONS_QUERY_MX = new HashSet<String>();\r\n\r\n    static {\r\n        Collections.addAll(\r\n                EXCLUSIONS_QUERY_MX,\r\n", "    DnsCache resolveCache() {\r\n        return resolveCache;\r\n    }\r\n\r\n    @Override\r\n", "    /**\r\n     * Attempt to parse {@code /etc/resolv.conf} and files in the {@code /etc/resolver} directory by default.\r\n     * A failure to parse will return {@link DefaultDnsServerAddressStreamProvider}.\r\n     */\r\n    static DnsServerAddressStreamProvider parseSilently() {\r\n", "            \"nameserver 127.0.0.11\\n\");\r\n        assertEquals(1, parseEtcResolverOptions(f).ndots());\r\n    }\r\n\r\n    @Test\r\n", "        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns a new {@link DnsNameResolver} instance.\r\n", "import java.util.HashMap;\r\nimport java.util.IdentityHashMap;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\nimport java.util.Locale;\r\n", "    }\r\n\r\n    private static final class AddressedEnvelopeAdapter implements AddressedEnvelope<DnsResponse, InetSocketAddress> {\r\n        private final InetSocketAddress sender;\r\n        private final InetSocketAddress recipient;\r\n", "\r\n    /**\r\n     * Default magic byte for a request.\r\n     */\r\n    public static final byte RESPONSE_MAGIC_BYTE = (byte) 0x81;\r\n", "    /**\r\n     * Duplicate this object. The result of this should be able to be independently iterated over via {@link #next()}.\r\n     * <p>\r\n     * Note that {@link #clone()} isn't used because it may make sense for some implementations to have the following\r\n     * relationship {@code x.duplicate() == x}.\r\n", "        int length = 12; // invalid length\r\n        int streamId = RANDOM.nextInt() & 0x7FFFFFFF;\r\n        int deltaWindowSize = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;\r\n\r\n        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n", "                        server.next = serverName.next;\r\n                        serverName.next = server;\r\n                        serverName = server;\r\n\r\n                        nameServerCount++;\r\n", "\r\n    private static void assertNotEmptyAndRelease(Future<List<DnsRecord>> recordsFuture) throws Exception {\r\n        List<DnsRecord> records = recordsFuture.get();\r\n        assertFalse(records.isEmpty());\r\n        for (DnsRecord record : records) {\r\n", "                \"google.ca\",\r\n                \"google.co.id\",\r\n                \"blogger.com\",\r\n                \"flipkart.com\",\r\n                \"google.com.tr\",\r\n", "import io.netty.util.internal.logging.InternalLogger;\r\nimport io.netty.util.internal.logging.InternalLoggerFactory;\r\n\r\nimport java.lang.reflect.Method;\r\nimport java.net.Inet6Address;\r\n", "                        // Create a new List for COW semantics\r\n                        List<E> newEntries = new ArrayList<E>(entries.size() + 1);\r\n                        int i = 0;\r\n                        E replacedEntry = null;\r\n                        do {\r\n", "    protected AbstractMemcacheObject() {\r\n        // Disallow direct instantiation\r\n    }\r\n\r\n    @Override\r\n", "import java.net.NetworkInterface;\r\nimport java.net.SocketAddress;\r\nimport java.net.SocketException;\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\n", "    public String toString() {\r\n        return toString(\"sequential\", i, addresses);\r\n    }\r\n\r\n    static String toString(String type, int index, Collection<? extends InetSocketAddress> addresses) {\r\n", "        testFollowNsRedirects(NoopDnsCache.INSTANCE, NoopAuthoritativeDnsServerCache.INSTANCE, true);\r\n    }\r\n\r\n    @Test\r\n    public void testFollowNsRedirectAndTrySecondNsOnTimeoutDefaultCaches() throws Exception {\r\n", "import java.util.List;\r\n\r\nfinal class SequentialDnsServerAddressStream implements DnsServerAddressStream {\r\n\r\n    private final List<? extends InetSocketAddress> addresses;\r\n", "    protected void doResolveAll(String inetHost,\r\n                                DnsRecord[] additionals,\r\n                                Promise<List<InetAddress>> promise,\r\n                                DnsCache resolveCache) throws Exception {\r\n        if (inetHost == null || inetHost.isEmpty()) {\r\n", "            return true;\r\n        }\r\n\r\n        @Override\r\n        protected boolean equals(String entry, String otherEntry) {\r\n", "    }\r\n\r\n    @Override\r\n    public InetSocketAddress next() {\r\n        int i = this.i;\r\n", "    private final boolean recursionDesired;\r\n    private final int maxPayloadSize;\r\n    private final boolean optResourceEnabled;\r\n    private final HostsFileEntriesResolver hostsFileEntriesResolver;\r\n    private final DnsServerAddressStreamProvider dnsServerAddressStreamProvider;\r\n", "    public void testIpv4PreferredWhenIpv6First() throws Exception {\r\n        testResolvesPreferredWhenNonPreferredFirst0(ResolvedAddressTypes.IPV4_PREFERRED);\r\n    }\r\n\r\n    @Test\r\n", "                    .resolveCache(NoopDnsCache.INSTANCE)\r\n                    .cnameCache(new DnsCnameCache() {\r\n                        @Override\r\n                        public String get(String hostname) {\r\n                            assertTrue(hostname, hostname.endsWith(\".\"));\r\n", "\r\n/**\r\n * A {@link BinaryMemcacheRequest} that also includes the content.\r\n */\r\n@UnstableApi\r\n", "    }\r\n\r\n    @Test\r\n    public void testExpireWithDifferentTTLs() {\r\n        testExpireWithTTL0(1);\r\n", "    }\r\n\r\n    @Test\r\n    public void testExpireWithDifferentTTLs() {\r\n        testExpireWithTTL0(1);\r\n", " * <p>\r\n * This may use the JDK's blocking DNS resolution to bootstrap the default DNS server addresses.\r\n */\r\npublic final class DefaultDnsServerAddressStreamProvider implements DnsServerAddressStreamProvider {\r\n    private static final InternalLogger logger =\r\n", "import io.netty.util.concurrent.Future;\r\nimport io.netty.util.concurrent.FutureListener;\r\nimport io.netty.util.concurrent.Promise;\r\nimport io.netty.util.internal.EmptyArrays;\r\nimport io.netty.util.internal.PlatformDependent;\r\n", "                // ignore\r\n            } catch (InstantiationException e) {\r\n                // ignore\r\n            } catch (InvocationTargetException e) {\r\n                // ignore\r\n", "        0x01, 0x02, 0x03, 0x04,\r\n        0x05, 0x06, 0x07, 0x08\r\n    };\r\n\r\n    public static final int MAX_CONTENT_SIZE = 2 << 10;\r\n", "    }\r\n\r\n    @Test\r\n    public void testNegativeTtl() throws Exception {\r\n        final DnsNameResolver resolver = newResolver().negativeTtl(10).build();\r\n", "    final Future<AddressedEnvelope<DnsResponse, InetSocketAddress>> query0(\r\n            InetSocketAddress nameServerAddr, DnsQuestion question,\r\n            DnsRecord[] additionals,\r\n            boolean flush,\r\n            ChannelPromise writePromise,\r\n", "                return stream;\r\n            }\r\n        };\r\n\r\n        try {\r\n", "            return NUMBERS[index(NUMBERS.length)];\r\n        }\r\n\r\n        private static String nextIp6() {\r\n            return IPV6_ADDRESSES[index(IPV6_ADDRESSES.length)];\r\n", "\r\n        @SuppressJava6Requirement(reason = \"uses Java 7+ Exception.<init>(String, Throwable, boolean, boolean)\" +\r\n                \" but is guarded by version checks\")\r\n        private DnsResolveContextException(String message, boolean shared) {\r\n            super(message, null, false, true);\r\n", "\r\nimport java.lang.reflect.Constructor;\r\nimport java.lang.reflect.InvocationTargetException;\r\nimport java.security.AccessController;\r\nimport java.security.PrivilegedAction;\r\n", "        this.dnsResolverBuilder = new DnsNameResolverBuilder();\r\n        dnsResolverBuilder.channelFactory(channelFactory).nameServerProvider(nameServerProvider);\r\n    }\r\n\r\n    @SuppressWarnings(\"deprecation\")\r\n", "                                      FullBinaryMemcacheResponse actual) {\r\n        assertNotSame(expected, actual);\r\n\r\n        assertEquals(expected.key(), actual.key());\r\n        assertEquals(expected.extras(), actual.extras());\r\n", "        return this;\r\n    }\r\n\r\n    @Override\r\n    public short keyLength() {\r\n", "     */\r\n    protected abstract M buildInvalidMessage();\r\n\r\n    /**\r\n     * Contains all states this decoder can possibly be in.\r\n", "     */\r\n    BinaryMemcacheMessage setOpcode(byte code);\r\n\r\n    /**\r\n     * Returns the key length of the message.\r\n", "        AuthoritativeNameServerList(String questionName) {\r\n            this.questionName = questionName.toLowerCase(Locale.US);\r\n        }\r\n\r\n        void add(DnsRecord r) {\r\n", "            cache.cache(\"netty.io\", null, addr1, 1, loop);\r\n            cache.cache(\"netty.io\", null, addr1, 10000, loop);\r\n\r\n            List<? extends DnsCacheEntry> entries = cache.get(\"netty.io\", null);\r\n            assertEquals(1, entries.size());\r\n", "    /**\r\n     * Start the {@link TestDnsServer} but drop all {@code AAAA} queries and not send any response to these at all.\r\n     */\r\n    public void start(final boolean dropAAAAQueries) throws IOException {\r\n        InetSocketAddress address = new InetSocketAddress(NetUtil.LOCALHOST4, 0);\r\n", "            extras.release();\r\n            content.release();\r\n        }\r\n    }\r\n\r\n", "     * @param dnsServerAddressStreamProvider The {@link DnsServerAddressStreamProvider} used to determine the name\r\n     *                                       servers for each hostname lookup.\r\n     * @param searchDomains the list of search domain\r\n     *                      (can be null, if so, will try to default to the underlying platform ones)\r\n     * @param ndots the ndots value\r\n", "        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeDataFrameHeader(buf, streamId, flags, length);\r\n        for (int i = 0; i < 256; i ++) {\r\n            buf.writeInt(RANDOM.nextInt());\r\n        }\r\n", "\r\n/**\r\n * Cache which stores the nameservers that should be used to resolve a specific hostname.\r\n */\r\npublic interface AuthoritativeDnsServerCache {\r\n", "        envelope.release();\r\n    }\r\n\r\n    @SuppressWarnings(\"unchecked\")\r\n    private boolean trySuccess(AddressedEnvelope<? extends DnsResponse, InetSocketAddress> envelope) {\r\n", "    DnsCacheEntry cache(String hostname, DnsRecord[] additionals, InetAddress address, long originalTtl,\r\n                        EventLoop loop);\r\n\r\n    /**\r\n     * Cache the resolution failure for a given hostname.\r\n", "import org.junit.Test;\r\n\r\nimport static org.junit.Assert.assertEquals;\r\n\r\npublic class BinaryMemcacheMessageTest {\r\n", "package io.netty.resolver.dns;\r\n\r\nimport io.netty.channel.EventLoop;\r\nimport io.netty.handler.codec.dns.DnsRecord;\r\n\r\n", "package io.netty.resolver.dns;\r\n\r\nimport io.netty.channel.EventLoop;\r\nimport io.netty.handler.codec.dns.DnsRecord;\r\n\r\n", "package io.netty.resolver.dns;\r\n\r\nimport io.netty.channel.EventLoop;\r\nimport io.netty.handler.codec.dns.DnsRecord;\r\n\r\n", "                                ++i;\r\n                                for (; i < entries.size(); ++i) {\r\n                                    newEntries.add(entries.get(i));\r\n                                }\r\n                                break;\r\n", "import static org.junit.Assert.assertFalse;\r\nimport static org.junit.Assert.assertTrue;\r\n\r\npublic class SearchDomainTest {\r\n\r\n", "\r\n    @Test\r\n    public void testDiscardUnknownEmptyFrame() throws Exception {\r\n        short type = 5;\r\n        byte flags = (byte) 0xFF;\r\n", "        assertEquals(0, frame.headers().names().size());\r\n        headerBlock.release();\r\n    }\r\n\r\n    @Test\r\n", "     * Returns the cached cname for the given hostname.\r\n     *\r\n     * @param hostname the hostname\r\n     * @return the cached entries or an {@code null} if none.\r\n     */\r\n", "                assertEquals(ns3Address, redirected.next());\r\n                assertEquals(ns2Address, redirected.next());\r\n                assertEquals(ns1Address, redirected.next());\r\n            } else {\r\n                assertEquals(ns1Address, redirected.next());\r\n", "                assertEquals(ipv4Addr, resolvedAddress.getHostAddress());\r\n            } else {\r\n                assertEquals(ipv6Addr, NetUtil.toAddressString(resolvedAddress));\r\n            }\r\n            assertEquals(firstName, resolvedAddress.getHostName());\r\n", "    String get(String hostname);\r\n\r\n    /**\r\n     * Caches a cname entry that should be used for the given hostname.\r\n     *\r\n", "     * Returns {@code true} if we should allow duplicates in the result or {@code false} if no duplicates should\r\n     * be included.\r\n     */\r\n    abstract boolean isDuplicateAllowed();\r\n\r\n", "                assertNull(nsCache.cacheHits.get(\"io.\"));\r\n                assertNull(nsCache.cacheHits.get(\"netty.io.\"));\r\n                assertNotNull(nsCache.cacheHits.get(\"record.netty.io.\"));\r\n                assertNull(nsCache.cacheHits.get(\"some.record.netty.io.\"));\r\n            }\r\n", "\r\n    @Override\r\n    protected void deallocate() {\r\n        content.release();\r\n    }\r\n", "    private static DnsCnameCache buildCache(int chainLength) {\r\n        EmbeddedChannel channel = new EmbeddedChannel();\r\n        DnsCnameCache cache = new DefaultDnsCnameCache();\r\n        if (chainLength == 1) {\r\n            cache.cache(HOSTNAME, HOSTNAME, Long.MAX_VALUE, channel.eventLoop());\r\n", "package io.netty.handler.codec.memcache.binary;\r\n\r\nimport io.netty.buffer.ByteBuf;\r\nimport io.netty.buffer.Unpooled;\r\nimport io.netty.util.CharsetUtil;\r\n", "package io.netty.handler.codec.memcache.binary;\r\n\r\nimport io.netty.buffer.ByteBuf;\r\nimport io.netty.buffer.Unpooled;\r\nimport io.netty.util.CharsetUtil;\r\n", "package io.netty.handler.codec.memcache.binary;\r\n\r\nimport io.netty.buffer.ByteBuf;\r\nimport io.netty.buffer.Unpooled;\r\nimport io.netty.util.CharsetUtil;\r\n", "        assertFalse(fut.isSuccess());\r\n    }\r\n\r\n    private static void assertNotResolveAll(DnsNameResolver resolver, String inetHost) throws InterruptedException {\r\n        Future<List<InetAddress>> fut = resolver.resolveAll(inetHost);\r\n", "        testFollowNsRedirects(new DefaultDnsCache(), new DefaultAuthoritativeDnsServerCache(), false);\r\n    }\r\n\r\n    @Test\r\n    public void testFollowNsRedirectAndTrySecondNsOnTimeout() throws Exception {\r\n", "    protected void doResolve(String inetHost,\r\n                             DnsRecord[] additionals,\r\n                             Promise<InetAddress> promise,\r\n                             DnsCache resolveCache) throws Exception {\r\n        if (inetHost == null || inetHost.isEmpty()) {\r\n", "\r\n        // \"host3\" does not contain a dot nor it's absolute but it should still be resolved after search list have\r\n        // been checked\r\n        resolved = assertResolveAll(resolver, \"host3\");\r\n        assertEquals(store.getAddresses(\"host3\"), resolved);\r\n", "                    int remainingLength = valueLength - alreadyReadChunkSize;\r\n                    if (toRead > remainingLength) {\r\n                        toRead = remainingLength;\r\n                    }\r\n\r\n", "\r\n    /**\r\n     * Create a new instance.\r\n     * @param providers The providers to use for DNS resolution. They will be queried in order.\r\n     */\r\n", "\r\n        try {\r\n            EventLoop loop = group.next();\r\n            final DefaultDnsCnameCache cache = new DefaultDnsCnameCache();\r\n            cache.cache(\"netty.io\", \"mapping1.netty.io\", 10, loop);\r\n", "\r\n    /**\r\n     * Returns the cached nameservers that should be used to resolve the given hostname. The returned\r\n     * {@link DnsServerAddressStream} may contain unresolved {@link InetSocketAddress}es that will be resolved\r\n     * when needed while resolving other domain names.\r\n", "        int length = 12; // invalid length\r\n        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;\r\n        int statusCode = RANDOM.nextInt() | 0x01;\r\n\r\n        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n", "            }\r\n\r\n            @Override\r\n            public DnsCacheEntry cache(String hostname, DnsRecord[] additionals, Throwable cause, EventLoop loop) {\r\n                fail(\"Should not be cached\");\r\n", "\r\n        // \"host3\" does not contain a dot nor it's absolute but it should still be resolved after search list have\r\n        // been checked\r\n        resolved = assertResolve(resolver, \"host3\");\r\n        assertEquals(store.getAddress(\"host3\"), resolved);\r\n", "\r\npackage io.netty.resolver.dns;\r\n\r\nimport io.netty.util.internal.ObjectUtil;\r\n\r\n", "     * @param etcResolverDir Directory containing files of the format defined in\r\n     * <a href=\"\r\n     * https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man5/resolver.5.html\">\r\n     * /etc/resolver</a>.\r\n     * @throws IOException If an error occurs while parsing the input files.\r\n", "    @Test\r\n    public void testReservedSpdySynReplyFrameBits() throws Exception {\r\n        short type = 2;\r\n        byte flags = 0;\r\n        int length = 4;\r\n", "import io.netty.channel.FileRegion;\r\nimport io.netty.handler.codec.MessageToMessageEncoder;\r\nimport io.netty.util.internal.StringUtil;\r\nimport io.netty.util.internal.UnstableApi;\r\n\r\n", "        buf.append(\"failed to resolve '\").append(hostname).append('\\'');\r\n        if (tries > 1) {\r\n            if (tries < maxAllowedQueries) {\r\n                buf.append(\" after \")\r\n                   .append(tries)\r\n", "\r\n    private static int parseResIntOption(String opt, String fullLabel) {\r\n        String optValue = opt.substring(fullLabel.length());\r\n        return Integer.parseInt(optValue);\r\n    }\r\n", "        this.key = key;\r\n        keyLength = key == null ? 0 : (short) key.readableBytes();\r\n        this.extras = extras;\r\n        extrasLength = extras == null ? 0 : (byte) extras.readableBytes();\r\n        totalBodyLength = keyLength + extrasLength;\r\n", "\r\npackage io.netty.resolver.dns;\r\n\r\nimport io.netty.util.internal.PlatformDependent;\r\n\r\n", "                           \"search squarecorp.local\\n\" +\r\n                           \"nameserver 127.0.0.2\\n\");\r\n        List<String> domains = UnixResolverDnsServerAddressStreamProvider.parseEtcResolverSearchDomains(f);\r\n        assertEquals(Arrays.asList(\"linecorp.local\", \"squarecorp.local\"), domains);\r\n    }\r\n", "\r\n                if (!truncatedBecauseOfMtu) {\r\n                    // Create a copy of the message but set the truncated flag.\r\n                    DnsMessageModifier modifier = modifierFrom(message);\r\n                    modifier.setTruncated(true);\r\n", "    }\r\n\r\n    @Test\r\n    public void testMissingName() throws Exception {\r\n        ByteBuf headerBlock = Unpooled.buffer(8);\r\n", "            br = new BufferedReader(fr);\r\n            String line;\r\n            while ((line = br.readLine()) != null) {\r\n                if (line.startsWith(OPTIONS_ROW_LABEL)) {\r\n                    parseResOptions(line.substring(OPTIONS_ROW_LABEL.length()), optionsBuilder);\r\n", "            \"google.co.uk\",\r\n            \"google.com.br\",\r\n            \"list.tmall.com\",\r\n            \"google.ru\",\r\n            \"google.fr\",\r\n", "import java.util.List;\r\n\r\n/**\r\n * A general purpose {@link AbstractMemcacheObjectEncoder} that encodes {@link MemcacheMessage}s.\r\n * <p/>\r\n", "                                   long originalTtl, EventLoop loop) {\r\n            return cache.cache(hostname, additionals, address, originalTtl, loop);\r\n        }\r\n\r\n        @Override\r\n", "package io.netty.resolver.dns;\r\n\r\nimport java.net.UnknownHostException;\r\nimport java.util.List;\r\n\r\n", "        final List<? extends DnsCacheEntry> cachedEntries = resolveCache.get(hostname, additionals);\r\n        if (cachedEntries == null || cachedEntries.isEmpty()) {\r\n            return false;\r\n        }\r\n\r\n", "\r\n    AuthoritativeDnsServerCacheAdapter(DnsCache cache) {\r\n        this.cache = checkNotNull(cache, \"cache\");\r\n    }\r\n\r\n", "                                      final DnsCache resolveCache,\r\n                                      final boolean completeEarlyIfPossible) {\r\n        // Call doResolveUncached0(...) in the EventLoop as we may need to submit multiple queries which would need\r\n        // to submit multiple Runnable at the end if we are not already on the EventLoop.\r\n        EventExecutor executor = executor();\r\n", "            return entry.cause().equals(otherEntry.cause());\r\n        }\r\n    };\r\n\r\n    private final int minTtl;\r\n", "public final class UnixResolverDnsServerAddressStreamProvider implements DnsServerAddressStreamProvider {\r\n    private static final InternalLogger logger =\r\n            InternalLoggerFactory.getInstance(UnixResolverDnsServerAddressStreamProvider.class);\r\n\r\n    private static final Pattern WHITESPACE_PATTERN = Pattern.compile(\"\\\\s+\");\r\n", "                resetDecoder();\r\n                out.add(invalidMessage(e));\r\n                return;\r\n            }\r\n            case READ_EXTRAS: try {\r\n", "            final String next = cnames.remove(resolved);\r\n            if (next != null) {\r\n                found = true;\r\n                resolved = next;\r\n            } else {\r\n", "        ByteBuf headerBlock = Unpooled.buffer(headerBlockLength);\r\n        for (int i = 0; i < 256; i ++) {\r\n            headerBlock.writeInt(RANDOM.nextInt());\r\n        }\r\n        decoder.decode(buf);\r\n", "        super(parent, originalPromise, hostname, DnsRecord.CLASS_IN,\r\n              parent.resolveRecordTypes(), additionals, nameServerAddrs, allowedQueries);\r\n        this.resolveCache = resolveCache;\r\n        this.authoritativeDnsServerCache = authoritativeDnsServerCache;\r\n        this.completeEarlyIfPossible = completeEarlyIfPossible;\r\n", "\r\n    private static void testExpireWithTTL0(int days) {\r\n        EventLoopGroup group = new NioEventLoopGroup(1);\r\n\r\n        try {\r\n", "\r\n    /**\r\n     * Returns the {@link DnsServerAddresses} that yields only a single {@code address}.\r\n     */\r\n    public static DnsServerAddresses singleton(final InetSocketAddress address) {\r\n", "\r\n        request.release();\r\n\r\n        int expectedContentChunks = 4;\r\n        for (int i = 1; i <= expectedContentChunks; i++) {\r\n", "            cache.cache(\"netty.io.\", null, addr2, 10000, loop);\r\n\r\n            List<? extends DnsCacheEntry> entries = cache.get(\"netty.io\", null);\r\n            assertEquals(2, entries.size());\r\n            assertEntry(entries.get(0), addr1);\r\n", "        assertNext(i, ADDR2);\r\n        assertNext(i, ADDR3);\r\n    }\r\n\r\n    @Test\r\n", "     * test to ensure that some hostnames can be directed toward both the primary and secondary DNS test servers\r\n     * simultaneously.\r\n     */\r\n    @Test\r\n    public void testNameServerCache() throws IOException, InterruptedException {\r\n", "     * @param additionals additional records ({@code OPT})\r\n     * @param promise the {@link Promise} which will be fulfilled when the name resolution is finished\r\n     *\r\n     * @return the address as the result of the resolution\r\n     */\r\n", "\r\n    private short reserved;\r\n\r\n    /**\r\n     * Create a new {@link DefaultBinaryMemcacheRequest} with the header only.\r\n", "\r\n                rm.setDnsType(question.getRecordType());\r\n                rm.put(DnsAttribute.IP_ADDRESS, ipv4Addr);\r\n                return Collections.singleton(rm.getEntry());\r\n            }\r\n", "                byte extrasLength = currentMessage.extrasLength();\r\n                if (extrasLength > 0) {\r\n                    if (in.readableBytes() < extrasLength) {\r\n                        return;\r\n                    }\r\n", "\r\n        @Override\r\n        public void cache(String hostname, InetSocketAddress address, long originalTtl, EventLoop loop) {\r\n            wrapped.cache(hostname, address, originalTtl, loop);\r\n        }\r\n", "\r\n            @Override\r\n            public DnsCacheEntry cache(\r\n                    String hostname, DnsRecord[] additionals, InetAddress address, long originalTtl, EventLoop loop) {\r\n                return null;\r\n", "    }\r\n\r\n    /**\r\n     * Closes the internal datagram channel used for sending and receiving DNS messages, and clears all DNS resource\r\n     * records from the cache. Attempting to send a DNS query or to resolve a domain name will fail once this method\r\n", "import io.netty.channel.socket.DatagramChannel;\r\nimport io.netty.resolver.AddressResolver;\r\nimport io.netty.resolver.AddressResolverGroup;\r\nimport io.netty.resolver.NameResolver;\r\nimport io.netty.resolver.RoundRobinInetAddressResolver;\r\n", "                    tryFailure(promise, future.cause());\r\n                }\r\n            }\r\n        });\r\n    }\r\n", "\r\npackage io.netty.resolver.dns;\r\n\r\nimport io.netty.resolver.NameResolver;\r\nimport io.netty.util.concurrent.EventExecutor;\r\n", "import io.netty.handler.codec.dns.DnsRecord;\r\nimport io.netty.handler.codec.dns.DnsResponse;\r\nimport io.netty.handler.codec.dns.DnsSection;\r\nimport io.netty.util.concurrent.Future;\r\nimport io.netty.util.concurrent.FutureListener;\r\n", "        // in the cache eventually.\r\n        if (!completeEarly && !queriesInProgress.isEmpty()) {\r\n            // If there are queries in progress, we should cancel it because we already finished the resolution.\r\n            for (Iterator<Future<AddressedEnvelope<DnsResponse, InetSocketAddress>>> i = queriesInProgress.iterator();\r\n                 i.hasNext();) {\r\n", "\r\n    @Test\r\n    public void testAddMultipleDnsServerForSameHostname() throws Exception {\r\n        InetSocketAddress resolved1 = new InetSocketAddress(\r\n                InetAddress.getByAddress(\"ns1\", new byte[] { 10, 0, 0, 1 }), 53);\r\n", "\r\nimport java.net.InetSocketAddress;\r\n\r\n/**\r\n * A {@link RuntimeException} raised when {@link DnsNameResolver} failed to perform a successful query.\r\n", "\r\n/**\r\n * A {@link DnsNameResolverException} raised when {@link DnsNameResolver} failed to perform a successful query because\r\n * of an timeout. In this case you may want to retry the operation.\r\n */\r\n", "            @Override\r\n            public DnsCacheEntry cache(String hostname, DnsRecord[] additionals, InetAddress address,\r\n                                       long originalTtl, EventLoop loop) {\r\n                fail(\"Should not be cached\");\r\n                return null;\r\n", "import io.netty.handler.codec.dns.DnsResponseCode;\r\n\r\nimport java.net.InetSocketAddress;\r\nimport java.util.List;\r\n\r\n", "        @Override\r\n        public void run() {\r\n            // We always remove all entries for a hostname once one entry expire. This is not the\r\n            // most efficient to do but this way we can guarantee that if a DnsResolver\r\n            // be configured to prefer one ip family over the other we will not return unexpected\r\n", "    @Override\r\n    public short status() {\r\n        return status;\r\n    }\r\n\r\n", "        static DnsResolveContextException newStatic(String message, Class<?> clazz, String method) {\r\n            final DnsResolveContextException exception;\r\n            if (PlatformDependent.javaVersion() >= 7) {\r\n                exception = new DnsResolveContextException(message, true);\r\n            } else {\r\n", "    @Override\r\n    public void cache(String hostname, InetSocketAddress address, long originalTtl, EventLoop loop) {\r\n        checkNotNull(hostname, \"hostname\");\r\n        checkNotNull(address, \"address\");\r\n        checkNotNull(loop, \"loop\");\r\n", "     * These methods can be used on the {@link Future#cause()} that is returned by the various methods exposed by this\r\n     * {@link DnsNameResolver}.\r\n     */\r\n    public static boolean isTransportOrTimeoutError(Throwable cause) {\r\n        return cause != null && cause.getCause() instanceof DnsNameResolverException;\r\n", "     * Create a new instance.\r\n     * @param addresses The addresses which will be be returned in sequential order via\r\n     * {@link #nameServerAddressStream(String)}\r\n     */\r\n    public SequentialDnsServerAddressStreamProvider(Iterable<? extends InetSocketAddress> addresses) {\r\n", "package io.netty.handler.codec.memcache;\r\n\r\nimport io.netty.buffer.ByteBuf;\r\nimport io.netty.util.internal.ObjectUtil;\r\nimport io.netty.util.internal.StringUtil;\r\n", "                serverName = serverName.next;\r\n            }\r\n        }\r\n\r\n        private static void cacheUnresolved(\r\n", "    private M currentMessage;\r\n    private int alreadyReadChunkSize;\r\n\r\n    private State state = State.READ_HEADER;\r\n\r\n", "    private static void testSettingLengths(BinaryMemcacheMessage message,\r\n                                    int initialKeyLength, int initialExtrasLength, int contentLength) {\r\n        ByteBuf key = Unpooled.copiedBuffer(\"netty\", CharsetUtil.UTF_8);\r\n        ByteBuf extras = Unpooled.copiedBuffer(\"extras\", CharsetUtil.UTF_8);\r\n        ByteBuf key2 = Unpooled.copiedBuffer(\"netty!\", CharsetUtil.UTF_8);\r\n", "    private static InetSocketAddress IPV4ADDRESS1;\r\n    private static InetSocketAddress IPV4ADDRESS2;\r\n    private static InetSocketAddress IPV4ADDRESS3;\r\n\r\n    private static InetSocketAddress IPV6ADDRESS1;\r\n", "\r\n    @Test\r\n    public void testInvalidSpdyPingFrameLength() throws Exception {\r\n        short type = 6;\r\n        byte flags = 0;\r\n", "import java.net.InetAddress;\r\nimport java.net.UnknownHostException;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.Collections;\r\n", "        List<String> domains = UnixResolverDnsServerAddressStreamProvider.parseEtcResolverSearchDomains(f);\r\n        assertEquals(Collections.singletonList(\"linecorp.local\"), domains);\r\n    }\r\n\r\n    @Test\r\n", "    private static final DnsRecordType[] IPV4_ONLY_RESOLVED_RECORD_TYPES =\r\n            {DnsRecordType.A};\r\n    private static final InternetProtocolFamily[] IPV4_ONLY_RESOLVED_PROTOCOL_FAMILIES =\r\n            {InternetProtocolFamily.IPv4};\r\n    private static final DnsRecordType[] IPV4_PREFERRED_RESOLVED_RECORD_TYPES =\r\n", "        all.addAll(DOMAINS);\r\n        all.addAll(DOMAINS_PUNYCODE.values());\r\n        DOMAINS_ALL = Collections.unmodifiableSet(all);\r\n    }\r\n\r\n", "            entries = cache.get(\"netty.io\", null);\r\n            DnsCacheEntry entry = entries.get(0);\r\n            assertEquals(1, entries.size());\r\n            assertSame(exception, entry.cause());\r\n            assertNull(entry.address());\r\n", "    /**\r\n     * Create {@link DnsQueryLifecycleObserver} instances that log events to a logger with the given name context,\r\n     * at the given log level.\r\n     * @param name The name for the logger to use.\r\n     * @param level The log level to use for logging resolver events.\r\n", "import io.netty.channel.EventLoop;\r\nimport io.netty.handler.codec.dns.DnsQuestion;\r\nimport io.netty.handler.codec.dns.DnsRecord;\r\nimport io.netty.handler.codec.dns.DnsRecordType;\r\nimport io.netty.util.ReferenceCountUtil;\r\n", "import java.io.OutputStream;\r\nimport java.net.InetSocketAddress;\r\nimport java.util.Arrays;\r\nimport java.util.Collections;\r\nimport java.util.List;\r\n", "            assertEquals(DnsResponseCode.NOERROR, response.code());\r\n            int count = response.count(DnsSection.ANSWER);\r\n\r\n            assertEquals(2, count);\r\n            List<String> txts = new ArrayList<String>();\r\n", "\r\n    @Override\r\n    protected String protocol() {\r\n        return \"UDP\";\r\n    }\r\n", "        byte[] b6 = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, b4[0], b4[1], b4[2], b4[3] };\r\n        try {\r\n            return (Inet6Address) InetAddress.getByAddress(b6);\r\n        } catch (UnknownHostException e) {\r\n            throw new Error(e);\r\n", "                    new IdentityHashMap<Future<AddressedEnvelope<DnsResponse, InetSocketAddress>>, Boolean>());\r\n\r\n    private List<T> finalResult;\r\n    private int allowedQueries;\r\n    private boolean triedCNAME;\r\n", "                                    \"Skipping a nameserver URI as host portion could not be extracted: {}\", server);\r\n                            // If the host portion can not be parsed we should just skip this entry.\r\n                            continue;\r\n                        }\r\n                        int port  = uri.getPort();\r\n", "        }\r\n\r\n        @Override\r\n        public boolean equals(Object o) {\r\n            return o == this;\r\n", "            throw new UnsupportedOperationException();\r\n        }\r\n    };\r\n\r\n    // Two years are supported by all our EventLoop implementations and so safe to use as maximum.\r\n", "            assertNext(i, ADDR3);\r\n            assertNext(i, ADDR1);\r\n            assertNext(i, ADDR2);\r\n            assertNext(i, ADDR3);\r\n        }\r\n", "                ResourceRecordModifier rm = new ResourceRecordModifier();\r\n                rm.setDnsClass(RecordClass.IN);\r\n                rm.setDnsName(question.getDomainName());\r\n                rm.setDnsTtl(100);\r\n\r\n", "package io.netty.resolver.dns;\r\n\r\nimport io.netty.handler.codec.dns.DnsQuestion;\r\n\r\npublic final class NoopDnsQueryLifecycleObserverFactory implements DnsQueryLifecycleObserverFactory {\r\n", "                new DefaultLastMemcacheContent(Unpooled.copiedBuffer(\" Rocks!\", CharsetUtil.UTF_8));\r\n        int totalBodyLength = key.readableBytes() + extras.readableBytes() +\r\n                content1.content().readableBytes() + content2.content().readableBytes();\r\n        request.setTotalBodyLength(totalBodyLength);\r\n\r\n", "     * resource record returned by the DNS server is less than the minimum TTL or greater than the maximum TTL,\r\n     * this resolver will ignore the TTL from the DNS server and use the minimum TTL or the maximum TTL instead\r\n     * respectively.\r\n     * The default value is {@code 0} and {@link Integer#MAX_VALUE}, which practically tells this resolver to\r\n     * respect the TTL from the DNS server.\r\n", "        return new SingletonDnsServerAddresses(address);\r\n    }\r\n\r\n    private static List<InetSocketAddress> sanitize(Iterable<? extends InetSocketAddress> addresses) {\r\n        ObjectUtil.checkNotNull(addresses, \"addresses\");\r\n", "\r\n    @Override\r\n    LastMemcacheContent retainedDuplicate();\r\n\r\n    @Override\r\n", "        buf.release();\r\n    }\r\n\r\n    @Test\r\n    public void testSpdyGoAwayFrame() throws Exception {\r\n", "import org.junit.Test;\r\n\r\nimport java.net.SocketAddress;\r\nimport java.nio.channels.UnsupportedAddressTypeException;\r\n\r\n", "            cache.cache(\"netty.io\", null, addr1, 1, loop);\r\n            cache.cache(\"netty.io\", null, addr2, 10000, loop);\r\n\r\n            List<? extends DnsCacheEntry> entries = cache.get(\"netty.io\", null);\r\n            assertEquals(2, entries.size());\r\n", "            List<? extends DnsCacheEntry> cached = cache.cache.get(\"test.netty.io\", null);\r\n            List<? extends DnsCacheEntry> cached2 = cache.cache.get(\"test.netty.io.\", null);\r\n            assertEquals(1, cached.size());\r\n            assertSame(cached, cached2);\r\n\r\n", "\r\n    @Test\r\n    public void testSort1() {\r\n        List<InetSocketAddress> expected = Arrays.asList(\r\n                IPV4ADDRESS1, IPV4ADDRESS2, IPV6ADDRESS1, IPV6ADDRESS2, UNRESOLVED1, UNRESOLVED2);\r\n", "                    logger.debug(\r\n                            \"{} RECEIVED: UDP truncated packet received, consider adjusting maxPayloadSize for the {}.\",\r\n                            ctx.channel(), StringUtil.simpleClassName(DnsNameResolver.class));\r\n                }\r\n            }\r\n", "    }\r\n\r\n    @Test\r\n    public void testResolveAorAAAA() throws Exception {\r\n        DnsNameResolver resolver = newResolver(ResolvedAddressTypes.IPV4_PREFERRED).build();\r\n", "    static final NoopDnsQueryLifecycleObserver INSTANCE = new NoopDnsQueryLifecycleObserver();\r\n\r\n    private NoopDnsQueryLifecycleObserver() {\r\n    }\r\n\r\n", "    public InetSocketAddress next() {\r\n        int i = this.i;\r\n        InetSocketAddress next = addresses.get(i);\r\n        if (++ i < addresses.size()) {\r\n            this.i = i;\r\n", "        return rm.getEntry();\r\n    }\r\n\r\n    /**\r\n     * {@link ProtocolCodecFactory} which allows to test AAAA resolution.\r\n", "    @Override\r\n    FullMemcacheMessage duplicate();\r\n\r\n    @Override\r\n    FullMemcacheMessage retainedDuplicate();\r\n", "    private static final Constructor<? extends DnsServerAddressStreamProvider> STREAM_PROVIDER_CONSTRUCTOR;\r\n    private static final String MACOS_PROVIDER_CLASS_NAME =\r\n            \"io.netty.resolver.dns.macos.MacOSDnsServerAddressStreamProvider\";\r\n\r\n    static {\r\n", "    }\r\n\r\n    @Override\r\n    public DnsCacheEntry cache(String hostname, DnsRecord[] additionals, Throwable cause, EventLoop loop) {\r\n        checkNotNull(hostname, \"hostname\");\r\n", "    public void testSpdyHeadersFrame() throws Exception {\r\n        short type = 8;\r\n        byte flags = 0;\r\n        int length = 4;\r\n        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;\r\n", "\r\n    @Test\r\n    public void testSetLengths() {\r\n        ByteBuf key = Unpooled.copiedBuffer(\"Netty  Rocks!\", CharsetUtil.UTF_8);\r\n        ByteBuf extras = Unpooled.copiedBuffer(\"some extras\", CharsetUtil.UTF_8);\r\n", "import io.netty.util.internal.logging.InternalLoggerFactory;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.File;\r\nimport java.io.FileReader;\r\n", "import io.netty.channel.EventLoop;\r\nimport io.netty.channel.FixedRecvByteBufAllocator;\r\nimport io.netty.channel.socket.DatagramChannel;\r\nimport io.netty.channel.socket.DatagramPacket;\r\nimport io.netty.channel.socket.InternetProtocolFamily;\r\n", "            List<InetAddress> resolvedAll = resolver.resolveAll(\"netty.com\").syncUninterruptibly().getNow();\r\n            List<InetAddress> expected = types == ResolvedAddressTypes.IPV4_PREFERRED ?\r\n                    Arrays.asList(ipv4InetAddress, ipv6InetAddress) :  Arrays.asList(ipv6InetAddress, ipv4InetAddress);\r\n            assertEquals(expected, resolvedAll);\r\n        } finally {\r\n", "            case READ_KEY: try {\r\n                short keyLength = currentMessage.keyLength();\r\n                if (keyLength > 0) {\r\n                    if (in.readableBytes() < keyLength) {\r\n                        return;\r\n", "    }\r\n\r\n    @Test\r\n    public void shouldDecodeSeparatedValues() {\r\n        String msgBody = \"Not found\";\r\n", "        byte flags = (byte) 0xFE; // undefined flags\r\n        int length = 4;\r\n        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;\r\n\r\n        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n", "\r\n    @Test\r\n    public void testIllegalNameOnlyNull() throws Exception {\r\n        ByteBuf headerBlock = Unpooled.buffer(18);\r\n        headerBlock.writeInt(1);\r\n", "        super(key, extras);\r\n        this.content = ObjectUtil.checkNotNull(content, \"content\");\r\n        setTotalBodyLength(keyLength() + extrasLength() + content.readableBytes());\r\n    }\r\n\r\n", "        super(key, extras);\r\n        this.content = ObjectUtil.checkNotNull(content, \"content\");\r\n        setTotalBodyLength(keyLength() + extrasLength() + content.readableBytes());\r\n    }\r\n\r\n", "    private void assertCopy(FullBinaryMemcacheRequest expected, ByteBuf expectedContent,\r\n                            FullBinaryMemcacheRequest actual) {\r\n        assertNotSame(expected, actual);\r\n\r\n        assertEquals(expected.key(), actual.key());\r\n", "            // https://docs.oracle.com/javase/7/docs/api/java/net/doc-files/net-properties.html\r\n            if (NetUtil.isIpV6AddressesPreferred() ||\r\n                    (NetUtil.LOCALHOST instanceof Inet6Address && !NetUtil.isIpV4StackPreferred())) {\r\n                Collections.addAll(\r\n                        defaultNameServers,\r\n", "        }\r\n    }\r\n\r\n    private void doResolveUncached(String hostname,\r\n                                   DnsRecord[] additionals,\r\n", "                            assertTrue(hostname, hostname.endsWith(\".\"));\r\n                            cache.put(hostname, cname);\r\n                        }\r\n\r\n                        @Override\r\n", "            assertEquals(ns1Address, redirected.next());\r\n            assertEquals(ns2Address, redirected.next());\r\n            assertEquals(ns3Address, redirected.next());\r\n            assertEquals(ns4Address, redirected.next());\r\n            assertEquals(ns5Address, redirected.next());\r\n", "import java.net.Inet6Address;\r\nimport java.net.InetAddress;\r\nimport java.util.Comparator;\r\n\r\nfinal class PreferredAddressTypeComparator implements Comparator<InetAddress> {\r\n", "                        !inetAddress.isLoopbackAddress() && !inetAddress.isLinkLocalAddress()) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n", "     * @param maxQueriesPerResolve the maximum allowed number of DNS queries for a given name resolution\r\n     * @param traceEnabled if trace is enabled\r\n     * @param maxPayloadSize the capacity of the datagram packet buffer\r\n     * @param optResourceEnabled if automatic inclusion of a optional records is enabled\r\n     * @param hostsFileEntriesResolver the {@link HostsFileEntriesResolver} used to check for local aliases\r\n", "        } finally {\r\n            b.queryNoAnswer(code);\r\n        }\r\n        return this;\r\n    }\r\n", "package io.netty.resolver.dns;\r\n\r\nimport io.netty.channel.AddressedEnvelope;\r\nimport io.netty.channel.Channel;\r\nimport io.netty.handler.codec.dns.DatagramDnsQuery;\r\n", "\r\n                    if (r.type() == DnsRecordType.A && !parent.supportsARecords() ||\r\n                        r.type() == DnsRecordType.AAAA && !parent.supportsAAAARecords()) {\r\n                        continue;\r\n                    }\r\n", "     */\r\n    public DnsNameResolverBuilder eventLoop(EventLoop eventLoop) {\r\n        this.eventLoop = eventLoop;\r\n        return this;\r\n    }\r\n", "                    assertNull(ns2Cached);\r\n                }\r\n\r\n                List<? extends DnsCacheEntry> expectedCached = cache.get(expected.getHostName(), null);\r\n                assertEquals(1, expectedCached.size());\r\n", "            }\r\n        };\r\n        redirectServer.start();\r\n        EventLoopGroup group = new NioEventLoopGroup(1);\r\n\r\n", "            }\r\n        };\r\n        redirectServer.start();\r\n        EventLoopGroup group = new NioEventLoopGroup(1);\r\n\r\n", "                } else {\r\n                    throw (Throwable) maybeProvider;\r\n                }\r\n            } catch (ClassNotFoundException cause) {\r\n                LOGGER.warn(\"Can not find {} in the classpath, fallback to system defaults. This may result in \"\r\n", "                    if (i >= 0) {\r\n                        // May contain more then one entry, either separated by whitespace or tab.\r\n                        // See https://linux.die.net/man/5/resolver\r\n                        String[] domains = WHITESPACE_PATTERN.split(line.substring(i));\r\n                        Collections.addAll(searchDomains, domains);\r\n", "            cache.cache(\"netty.io\", \"mapping.netty.io\", 10, loop);\r\n            cache.cache(\"netty.io\", \"mapping.netty.io\", 10000, loop);\r\n\r\n            assertEquals(\"mapping.netty.io\", cache.get(\"netty.io\"));\r\n        } finally {\r\n", "        assertThat(result, is(true));\r\n\r\n        ByteBuf written = channel.readOutbound();\r\n        assertThat(written.readableBytes(), is(DEFAULT_HEADER_SIZE + extrasLength));\r\n        written.skipBytes(DEFAULT_HEADER_SIZE);\r\n", " * For example this can be used to represent <a href=\"https://linux.die.net/man/5/resolver\">/etc/resolv.conf</a> and\r\n * <a href=\"https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man5/resolver.5.html\">\r\n * /etc/resolver</a>.\r\n */\r\npublic interface DnsServerAddressStreamProvider {\r\n", "                DnsCacheEntry expectedEntry = expectedCached.get(0);\r\n                assertEquals(expected, expectedEntry.address());\r\n                assertNull(expectedEntry.cause());\r\n            }\r\n        } finally {\r\n", "import io.netty.util.collection.IntObjectMap;\r\nimport io.netty.util.internal.PlatformDependent;\r\n\r\nimport java.net.Inet4Address;\r\nimport java.net.Inet6Address;\r\n", "    }\r\n\r\n    /**\r\n     * Create a new {@link AbstractBinaryMemcacheDecoder} with custom settings.\r\n     *\r\n", "            cache.cache(\"netty.io\", null, addr1, 10000, loop);\r\n            cache.cache(\"netty.io\", null, addr2, 10000, loop);\r\n\r\n            List<? extends DnsCacheEntry> entries = cache.get(\"netty.io\", null);\r\n            assertEquals(2, entries.size());\r\n", "                    rm.setDnsName(name);\r\n                    rm.setDnsTtl(10);\r\n                    rm.setDnsType(RecordType.A);\r\n                    rm.put(DnsAttribute.IP_ADDRESS, \"10.0.0.1\");\r\n                    return Collections.singleton(rm.getEntry());\r\n", "    public void searchDomainsWithMultipleSearchSeperatedByTab() throws IOException {\r\n        File f = buildFile(\"search linecorp.local\\tsquarecorp.local\\n\" +\r\n                \"nameserver 127.0.0.2\\n\");\r\n        List<String> domains = UnixResolverDnsServerAddressStreamProvider.parseEtcResolverSearchDomains(f);\r\n        assertEquals(Arrays.asList(\"linecorp.local\", \"squarecorp.local\"), domains);\r\n", "\r\n    @Override\r\n    FullBinaryMemcacheRequest replace(ByteBuf content);\r\n\r\n    @Override\r\n", "    }\r\n\r\n    @Test\r\n    public void testUnknownSpdySynReplyFrameFlags() throws Exception {\r\n        short type = 2;\r\n", "                String domainName = etcResolverFile.getName();\r\n                boolean rotate = rotateGlobal;\r\n                int port = DNS_PORT;\r\n                String line;\r\n                while ((line = br.readLine()) != null) {\r\n", "package io.netty.resolver.dns;\r\n\r\nimport io.netty.channel.ChannelFuture;\r\nimport io.netty.handler.codec.dns.DnsQuestion;\r\nimport io.netty.handler.codec.dns.DnsResponseCode;\r\n", "package io.netty.resolver.dns;\r\n\r\nimport io.netty.channel.ChannelFuture;\r\nimport io.netty.handler.codec.dns.DnsQuestion;\r\nimport io.netty.handler.codec.dns.DnsResponseCode;\r\n", "package io.netty.resolver.dns;\r\n\r\nimport io.netty.channel.ChannelFuture;\r\nimport io.netty.handler.codec.dns.DnsQuestion;\r\nimport io.netty.handler.codec.dns.DnsResponseCode;\r\n", "     * @param etcResolverFiles List of files of the format defined in\r\n     * <a href=\"\r\n     * https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man5/resolver.5.html\">\r\n     * /etc/resolver</a>.\r\n     * @throws IOException If an error occurs while parsing the input files.\r\n", "\r\nimport static io.netty.util.internal.ObjectUtil.*;\r\n\r\n/**\r\n * Default implementation of {@link AuthoritativeDnsServerCache}, backed by a {@link ConcurrentMap}.\r\n", "\r\n        UnixResolverOptions build() {\r\n            return new UnixResolverOptions(ndots, timeout, attempts);\r\n        }\r\n    }\r\n", "            {DnsRecordType.A, DnsRecordType.AAAA};\r\n    private static final InternetProtocolFamily[] IPV4_PREFERRED_RESOLVED_PROTOCOL_FAMILIES =\r\n            {InternetProtocolFamily.IPv4, InternetProtocolFamily.IPv6};\r\n    private static final DnsRecordType[] IPV6_ONLY_RESOLVED_RECORD_TYPES =\r\n            {DnsRecordType.AAAA};\r\n", "    private final AuthoritativeDnsServerCache authoritativeDnsServerCache;\r\n    private final DnsCnameCache cnameCache;\r\n\r\n    private final FastThreadLocal<DnsServerAddressStream> nameServerAddrStream =\r\n            new FastThreadLocal<DnsServerAddressStream>() {\r\n", "\r\n        final String hostname = hostname(inetHost);\r\n\r\n        InetAddress hostsFileEntry = resolveHostsFileEntry(hostname);\r\n        if (hostsFileEntry != null) {\r\n", "\r\n        final String hostname = hostname(inetHost);\r\n\r\n        InetAddress hostsFileEntry = resolveHostsFileEntry(hostname);\r\n        if (hostsFileEntry != null) {\r\n", "            } catch (NumberFormatException ignore) {\r\n                // skip bad int values from resolv.conf to keep value already set in UnixResolverOptions\r\n            }\r\n        }\r\n    }\r\n", "import org.apache.directory.server.dns.messages.DnsMessage;\r\nimport org.apache.directory.server.dns.messages.DnsMessageModifier;\r\nimport org.apache.directory.server.dns.messages.QuestionRecord;\r\nimport org.apache.directory.server.dns.messages.RecordClass;\r\nimport org.apache.directory.server.dns.messages.RecordType;\r\n", "        } else if (!question().equals(res.recordAt(DnsSection.QUESTION))) {\r\n            logger.warn(\"Received a mismatching DNS response: {}\", envelope);\r\n        } else if (trySuccess(envelope)) {\r\n            return; // Ownership transferred, don't release\r\n        }\r\n", "        this.question = checkNotNull(question, \"question\");\r\n        this.logger = checkNotNull(logger, \"logger\");\r\n        this.level = checkNotNull(level, \"level\");\r\n    }\r\n\r\n", "                \"hao123.com\",\r\n                \"blogspot.com\",\r\n                \"t.co\",\r\n                \"espn.go.com\",\r\n                \"people.com.cn\",\r\n", "            \"yandex.ru\",\r\n            \"netflix.com\",\r\n            \"google.it\",\r\n            \"google.com.hk\",\r\n            \"linkedin.com\",\r\n", "            }\r\n\r\n            if (head != null && head.dots > dots) {\r\n                // We already have a closer match so ignore this one, no need to parse the domainName etc.\r\n                return;\r\n", "    public boolean isOptResourceEnabled() {\r\n        return optResourceEnabled;\r\n    }\r\n\r\n    /**\r\n", "        List<InetSocketAddress> addresses = new ArrayList<InetSocketAddress>(entries.size());\r\n\r\n        int i = 0;\r\n        do {\r\n            InetAddress addr = entries.get(i).address();\r\n", "            assertEquals(1, resolvedAddresses.size());\r\n            assertTrue(resolvedAddresses.contains(InetAddress.getByAddress(new byte[] { 10, 0, 0, 99 })));\r\n\r\n            assertEquals(\"x.netty.io.\", cache.get(\"y.netty.io.\"));\r\n\r\n", "    @Rule\r\n    public final TemporaryFolder folder = new TemporaryFolder();\r\n\r\n    @Test\r\n    public void defaultLookupShouldReturnResultsIfOnlySingleFileSpecified() throws Exception {\r\n", "                    if (!hasNext()) {\r\n                        throw new NoSuchElementException();\r\n                    }\r\n                    i++;\r\n                    return stream.next();\r\n", "\r\n    @Test\r\n    public void testResolveAllHostsFile() {\r\n        final DnsNameResolver resolver = new DnsNameResolverBuilder(group.next())\r\n                .channelType(NioDatagramChannel.class)\r\n", "            final InetAddress hostsFileEntry = resolveHostsFileEntry(hostname);\r\n            if (hostsFileEntry != null) {\r\n                ByteBuf content = null;\r\n                if (hostsFileEntry instanceof Inet4Address) {\r\n                    if (type == DnsRecordType.A) {\r\n", "    @Test\r\n    public void testUnknownSpdySettingsFrameFlags() throws Exception {\r\n        short type = 4;\r\n        byte flags = (byte) 0xFE; // undefined flags\r\n        int numSettings = 0;\r\n", "                return;\r\n            }\r\n\r\n            Bootstrap bs = new Bootstrap();\r\n            bs.option(ChannelOption.SO_REUSEADDR, true)\r\n", "            final String inetHost, final Promise<U> promise, boolean resolveAll) {\r\n\r\n        final Promise<U> earlyPromise = resolveMap.putIfAbsent(inetHost, promise);\r\n        if (earlyPromise != null) {\r\n            // Name resolution for the specified inetHost is in progress already.\r\n", "                        SocketUtils.socketAddress(\"8.8.8.8\", DNS_PORT),\r\n                        SocketUtils.socketAddress(\"8.8.4.4\", DNS_PORT));\r\n            }\r\n\r\n            if (logger.isWarnEnabled()) {\r\n", "        QueryRedirectedEvent(List<InetSocketAddress> nameServers) {\r\n            this.nameServers = nameServers;\r\n        }\r\n    }\r\n\r\n", "\r\n    /**\r\n     * Resolves the {@link DnsRecord}s that are matched by the specified {@link DnsQuestion}. Unlike\r\n     * {@link #query(DnsQuestion)}, this method handles redirection, CNAMEs and multiple name servers.\r\n     * If the specified {@link DnsQuestion} is {@code A} or {@code AAAA}, this method looks up the configured\r\n", "     * @param maxPayloadSize the capacity of the datagram packet buffer\r\n     * @param optResourceEnabled if automatic inclusion of a optional records is enabled\r\n     * @param hostsFileEntriesResolver the {@link HostsFileEntriesResolver} used to check for local aliases\r\n     * @param dnsServerAddressStreamProvider The {@link DnsServerAddressStreamProvider} used to determine the name\r\n     *                                       servers for each hostname lookup.\r\n", "            EventLoop loop = group.next();\r\n            final DefaultDnsCache cache = new DefaultDnsCache();\r\n            cache.cache(\"netty.io\", null, addr1, 1, loop);\r\n            cache.cache(\"netty.io\", null, addr2, 10000, loop);\r\n\r\n", "            super.doSearchDomainQuery(hostname, nextPromise);\r\n        }\r\n    }\r\n\r\n    @Override\r\n", "        final InetSocketAddress nameServerAddr = nameServerAddrStream.next();\r\n        if (nameServerAddr.isUnresolved()) {\r\n            queryUnresolvedNameServer(nameServerAddr, nameServerAddrStream, nameServerAddrStreamIndex, question,\r\n                                      queryLifecycleObserver, promise, cause);\r\n            return;\r\n", "\r\n                    if (toRead > chunkSize) {\r\n                        toRead = chunkSize;\r\n                    }\r\n\r\n", "                \"googleusercontent.com\",\r\n                \"blogspot.in\",\r\n                \"localhost\",\r\n                StringUtil.EMPTY_STRING);\r\n    }\r\n", "\r\n    private short status;\r\n\r\n    /**\r\n     * Create a new {@link DefaultBinaryMemcacheResponse} with the header only.\r\n", "    public static final byte REPLACE = 0x03;\r\n    public static final byte DELETE = 0x04;\r\n    public static final byte INCREMENT = 0x05;\r\n    public static final byte DECREMENT = 0x06;\r\n    public static final byte QUIT = 0x07;\r\n", "        }\r\n    }\r\n\r\n    @Override\r\n    public BinaryMemcacheMessage touch() {\r\n", "    private static List<String> assertResolveAll(DnsNameResolver resolver,\r\n                                                 String inetHost) throws InterruptedException {\r\n        Future<List<InetAddress>> fut = resolver.resolveAll(inetHost);\r\n        assertTrue(fut.await(10, TimeUnit.SECONDS));\r\n        List<String> list = new ArrayList<String>();\r\n", "    public void testExpireWithDifferentTTLs() {\r\n        testExpireWithTTL0(1);\r\n        testExpireWithTTL0(1000);\r\n        testExpireWithTTL0(1000000);\r\n    }\r\n", "\r\n    @Test\r\n    public void testInvalidSpdyHeadersFrameLength() throws Exception {\r\n        short type = 8;\r\n        byte flags = 0;\r\n", "    @Test\r\n    public void testIllegalSpdyWindowUpdateFrameDeltaWindowSize() throws Exception {\r\n        short type = 9;\r\n        byte flags = 0;\r\n        int length = 8;\r\n", "     * You can use {@link DnsNameResolverBuilder#computeResolvedAddressTypes(InternetProtocolFamily...)}\r\n     * to get a {@link ResolvedAddressTypes} out of some {@link InternetProtocolFamily}s.\r\n     *\r\n     * @param resolvedAddressTypes the address types\r\n     * @return {@code this}\r\n", "            logger.info(\"{}: {}\", unresolved, resolved.getHostAddress());\r\n\r\n            assertThat(resolved.getHostName(), is(unresolved));\r\n\r\n            boolean typeMatches = false;\r\n", "    @Test\r\n    public void testIpv4() throws UnknownHostException {\r\n        InetAddress ipv4Address1 = InetAddress.getByName(\"10.0.0.1\");\r\n        InetAddress ipv4Address2 = InetAddress.getByName(\"10.0.0.2\");\r\n        InetAddress ipv4Address3 = InetAddress.getByName(\"10.0.0.3\");\r\n", "    @Test\r\n    public void testCNAMELoopInCache() {\r\n        expectedException.expect(UnknownHostException.class);\r\n        DnsNameResolver resolver = null;\r\n        try {\r\n", "    abstract List<T> filterResults(List<T> unfiltered);\r\n\r\n    abstract boolean isCompleteEarly(T resolved);\r\n\r\n    /**\r\n", "\r\n    /**\r\n     * Sets the cache for resolution results.\r\n     *\r\n     * @param resolveCache the DNS resolution results cache\r\n", "\r\n        List<InetAddress> addressList = new ArrayList<InetAddress>();\r\n        Collections.addAll(addressList, ipv4Address1, ipv4Address2, ipv6Address1,\r\n                ipv6Address2, ipv4Address3, ipv6Address3);\r\n        Collections.sort(addressList, ipv4);\r\n", "\r\n        List<InetAddress> addressList = new ArrayList<InetAddress>();\r\n        Collections.addAll(addressList, ipv4Address1, ipv4Address2, ipv6Address1,\r\n                ipv6Address2, ipv4Address3, ipv6Address3);\r\n        Collections.sort(addressList, ipv4);\r\n", "     * @param hostsFileEntriesResolver the {@link HostsFileEntriesResolver} used to first check\r\n     *                                 if the hostname is locally aliased.\r\n     * @return {@code this}\r\n     */\r\n    public DnsNameResolverBuilder hostsFileEntriesResolver(HostsFileEntriesResolver hostsFileEntriesResolver) {\r\n", "     * @param reserved the reserved field value.\r\n     */\r\n    BinaryMemcacheRequest setReserved(short reserved);\r\n\r\n    @Override\r\n", "import java.util.Map;\r\nimport java.util.NoSuchElementException;\r\nimport java.util.Set;\r\n\r\nimport static io.netty.resolver.dns.DnsAddressDecoder.decodeAddress;\r\n", "package io.netty.resolver.dns;\r\n\r\nimport java.net.IDN;\r\nimport java.net.InetAddress;\r\nimport java.net.UnknownHostException;\r\n", "    }\r\n\r\n    /**\r\n     * Sets the {@link ChannelFactory} that will create a {@link SocketChannel} for\r\n     * <a href=\"https://tools.ietf.org/html/rfc7766\">TCP fallback</a> if needed.\r\n", "\r\n    private void queryUnresolvedNameServer(final InetSocketAddress nameServerAddr,\r\n                                           final DnsServerAddressStream nameServerAddrStream,\r\n                                           final int nameServerAddrStreamIndex,\r\n                                           final DnsQuestion question,\r\n", "import static org.hamcrest.CoreMatchers.*;\r\nimport static org.hamcrest.MatcherAssert.*;\r\nimport static org.hamcrest.core.IsNull.notNullValue;\r\nimport static org.hamcrest.core.IsNull.nullValue;\r\nimport static org.junit.Assert.assertFalse;\r\n", "\r\npublic class SpdyFrameDecoderTest {\r\n\r\n    private static final Random RANDOM = new Random();\r\n\r\n", "        int length = 4;\r\n        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;\r\n\r\n        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeControlFrameHeader(buf, type, flags, length);\r\n", "        byte[] b4 = { b6[12], b6[13], b6[14], b6[15] };\r\n        try {\r\n            return (Inet4Address) InetAddress.getByAddress(b4);\r\n        } catch (UnknownHostException e) {\r\n            throw new Error(e);\r\n", "\r\n    @Override\r\n    FullBinaryMemcacheResponse replace(ByteBuf content);\r\n\r\n    @Override\r\n", "    public NameServerComparator(Class<? extends InetAddress> preferredAddressType) {\r\n        this.preferredAddressType = ObjectUtil.checkNotNull(preferredAddressType, \"preferredAddressType\");\r\n    }\r\n\r\n    @Override\r\n", "\r\n        assertEquals(-1, x);\r\n        assertEquals(x, -y);\r\n        assertEquals(0, comparator.compare(IPV4ADDRESS1, IPV4ADDRESS1));\r\n        assertEquals(0, comparator.compare(UNRESOLVED1, UNRESOLVED1));\r\n", " * An object aggregator for the memcache binary protocol.\r\n *\r\n * It aggregates {@link BinaryMemcacheMessage}s and {@link MemcacheContent} into {@link FullBinaryMemcacheRequest}s\r\n * or {@link FullBinaryMemcacheResponse}s.\r\n */\r\n", "     */\r\n    private boolean handleRedirect(\r\n            DnsQuestion question, AddressedEnvelope<DnsResponse, InetSocketAddress> envelope,\r\n            final DnsQueryLifecycleObserver queryLifecycleObserver, Promise<List<T>> promise) {\r\n        final DnsResponse res = envelope.content();\r\n", "\r\n    /**\r\n     * Converts the given {@link DnsRecord} into {@code T}.\r\n     */\r\n    abstract T convertRecord(DnsRecord record, String hostname, DnsRecord[] additionals, EventLoop eventLoop);\r\n", " * ...\r\n * p.addLast(\"decoder\", new {@link BinaryMemcacheRequestDecoder}());\r\n * p.addLast(\"aggregator\", <b>new {@link io.netty.handler.codec.memcache.binary.BinaryMemcacheObjectAggregator}(1048576)\r\n * </b>);\r\n * ...\r\n", "        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeControlFrameHeader(buf, type, flags, length);\r\n\r\n        decoder.decode(buf);\r\n        verify(delegate).readFrameError(anyString());\r\n", "import java.net.InetAddress;\r\nimport java.util.List;\r\n\r\n/**\r\n * A cache for DNS resolution entries.\r\n", "    }\r\n\r\n    private void onExpectedResponse(\r\n            DnsQuestion question, AddressedEnvelope<DnsResponse, InetSocketAddress> envelope,\r\n            final DnsQueryLifecycleObserver queryLifecycleObserver, Promise<List<T>> promise) {\r\n", "    public void testIpv6PreferredWhenIpv4First() throws Exception {\r\n        testResolvesPreferredWhenNonPreferredFirst0(ResolvedAddressTypes.IPV6_PREFERRED);\r\n    }\r\n\r\n    private static void testResolvesPreferredWhenNonPreferredFirst0(ResolvedAddressTypes types) throws Exception {\r\n", "                dnsQueryLifecycleObserverFactory instanceof NoopDnsQueryLifecycleObserverFactory ?\r\n                        new LoggingDnsQueryLifeCycleObserverFactory() :\r\n                        new BiDnsQueryLifecycleObserverFactory(new LoggingDnsQueryLifeCycleObserverFactory(),\r\n                                                               dnsQueryLifecycleObserverFactory) :\r\n                checkNotNull(dnsQueryLifecycleObserverFactory, \"dnsQueryLifecycleObserverFactory\");\r\n", "    @Test\r\n    public void testSortAlreadySortedPreferred() {\r\n        List<InetSocketAddress> expected = Arrays.asList(IPV4ADDRESS1, IPV4ADDRESS2, IPV4ADDRESS3);\r\n        List<InetSocketAddress> addresses = new ArrayList<InetSocketAddress>(expected);\r\n        NameServerComparator comparator = new NameServerComparator(Inet4Address.class);\r\n", "     */\r\n    BinaryMemcacheMessage setExtras(ByteBuf extras);\r\n\r\n    /**\r\n     * Increases the reference count by {@code 1}.\r\n", "        assertThat(\r\n                written.readSlice(content1.content().readableBytes()).toString(CharsetUtil.UTF_8),\r\n                is(\"Netty\")\r\n        );\r\n        written.release();\r\n", "    static boolean doResolveAllCached(String hostname,\r\n                                      DnsRecord[] additionals,\r\n                                      Promise<List<InetAddress>> promise,\r\n                                      DnsCache resolveCache,\r\n                                      InternetProtocolFamily[] resolvedInternetProtocolFamilies) {\r\n", "        final String hostname = \"test.netty.io\";\r\n        final String ns0Name = \"ns0.\" + domain + '.';\r\n        final String ns1Name = \"ns1.\" + domain + '.';\r\n        final String ns2Name = \"ns2.\" + domain + '.';\r\n\r\n", "        byte flags = 0;\r\n        int length = 4;\r\n        int id = RANDOM.nextInt();\r\n\r\n        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n", "            case BAD_MESSAGE:\r\n                in.skipBytes(actualReadableBytes());\r\n                return;\r\n            default:\r\n                throw new Error(\"Unknown state reached: \" + state);\r\n", "        }\r\n    }\r\n\r\n    @Override\r\n    public void querySucceed() {\r\n", "\r\n        @Override\r\n        public void cache(String hostname, InetSocketAddress address, long originalTtl, EventLoop loop) {\r\n            cache.cache(hostname, address, originalTtl, loop);\r\n        }\r\n", "        ByteBuf headerBlock = Unpooled.buffer(headerBlockLength);\r\n        for (int i = 0; i < 256; i ++) {\r\n            headerBlock.writeInt(RANDOM.nextInt());\r\n        }\r\n\r\n", "        int length = 0;\r\n\r\n        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeControlFrameHeader(buf, type, flags, length);\r\n\r\n", "    @Override\r\n    boolean isDuplicateAllowed() {\r\n        return true;\r\n    }\r\n\r\n", "\r\nimport java.net.InetAddress;\r\nimport java.net.UnknownHostException;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\n", "            name = mapping;\r\n            if (advance) {\r\n                first = cnameCache.get(first);\r\n            }\r\n            advance = !advance;\r\n", "    }\r\n\r\n    DnsQueryContext remove(InetSocketAddress nameServerAddr, int id) {\r\n        final IntObjectMap<DnsQueryContext> contexts = getContextMap(nameServerAddr);\r\n        if (contexts == null) {\r\n", "/**\r\n * Able to parse files such as <a href=\"https://linux.die.net/man/5/resolver\">/etc/resolv.conf</a> and\r\n * <a href=\"https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man5/resolver.5.html\">\r\n * /etc/resolver</a> to respect the system default domain servers.\r\n */\r\n", "     * @return {@code this}\r\n     */\r\n    public DnsNameResolverBuilder resolveCache(DnsCache resolveCache) {\r\n        this.resolveCache  = resolveCache;\r\n        return this;\r\n", "        }\r\n    }\r\n\r\n    /**\r\n     * Handles a redirect answer if needed and returns {@code true} if a redirect query has been made.\r\n", "\r\n        @Override\r\n        public List<? extends DnsCacheEntry> get(String hostname, DnsRecord[] additionals) {\r\n            List<? extends DnsCacheEntry> cached = cache.get(hostname, additionals);\r\n            cacheHits.put(hostname, cached);\r\n", "                    if (alreadyReadChunkSize < valueLength) {\r\n                        return;\r\n                    }\r\n                } else {\r\n                    out.add(LastMemcacheContent.EMPTY_LAST_CONTENT);\r\n", "            out.close();\r\n        }\r\n        return f;\r\n    }\r\n\r\n", "                InetAddress.getByAddress(\"ns1\", new byte[] { 10, 0, 0, 1 }), 53);\r\n        EventLoopGroup group = new DefaultEventLoopGroup(1);\r\n\r\n        try {\r\n            EventLoop loop = group.next();\r\n", "            assertNotEmptyAndRelease(resolver.resolveAll(new DefaultDnsQuestion(\"service.netty.io\", SRV)));\r\n            alias.set(false);\r\n            assertNotEmptyAndRelease(resolver.resolveAll(new DefaultDnsQuestion(\"service.netty.io\", SRV)));\r\n        } finally {\r\n            dnsServer2.stop();\r\n", "        int id = RANDOM.nextInt() & 0x00FFFFFF;\r\n        int value = RANDOM.nextInt();\r\n\r\n        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeControlFrameHeader(buf, type, flags, length);\r\n", "        int id = RANDOM.nextInt() & 0x00FFFFFF;\r\n        int value = RANDOM.nextInt();\r\n\r\n        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeControlFrameHeader(buf, type, flags, length);\r\n", "        int id = RANDOM.nextInt() & 0x00FFFFFF;\r\n        int value = RANDOM.nextInt();\r\n\r\n        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeControlFrameHeader(buf, type, flags, length);\r\n", "        DnsNameResolverBuilder builder = new DnsNameResolverBuilder()\r\n                .eventLoop(loop).channelType(NioDatagramChannel.class);\r\n        DnsAddressResolverGroup resolverGroup = new DnsAddressResolverGroup(builder);\r\n        try {\r\n            final Promise<?> promise = loop.newPromise();\r\n", "import static io.netty.resolver.dns.DnsServerAddresses.sequential;\r\n\r\n/**\r\n * A {@link DnsServerAddressStreamProvider} which will use predefined default DNS servers to use for DNS resolution.\r\n * These defaults do not respect your host's machines defaults.\r\n", "package io.netty.handler.codec.memcache;\r\n\r\nimport io.netty.buffer.ByteBuf;\r\nimport io.netty.buffer.Unpooled;\r\nimport io.netty.handler.codec.DecoderResult;\r\n", "    public final Future<List<InetAddress>> resolveAll(String inetHost, Iterable<DnsRecord> additionals) {\r\n        return resolveAll(inetHost, additionals, executor().<List<InetAddress>>newPromise());\r\n    }\r\n\r\n    /**\r\n", "    /**\r\n     * Return the number of hostames for which we have cached something.\r\n     */\r\n    final int size() {\r\n        return resolveCache.size();\r\n", "         * Update the server with the given address and TTL if needed.\r\n         */\r\n        void update(InetSocketAddress address, long ttl) {\r\n            assert this.address == null || this.address.isUnresolved();\r\n            this.address = address;\r\n", "     * @param hostname the hostname\r\n     * @param additionals the additional records\r\n     * @return the cached entries\r\n     */\r\n    List<? extends DnsCacheEntry> get(String hostname, DnsRecord[] additionals);\r\n", "    public static DnsServerAddressStreamProvider unixDefault() {\r\n        return DefaultProviderHolder.DEFAULT_DNS_SERVER_ADDRESS_STREAM_PROVIDER;\r\n    }\r\n\r\n    // We use a Holder class to only initialize DEFAULT_DNS_SERVER_ADDRESS_STREAM_PROVIDER if we really\r\n", "        byte flags = 0;\r\n        int length = 8;\r\n        int streamId = RANDOM.nextInt() & 0x7FFFFFFF;\r\n        int deltaWindowSize = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;\r\n\r\n", "        Set<InetSocketAddress> set = Collections.newSetFromMap(new IdentityHashMap<InetSocketAddress, Boolean>());\r\n        DnsServerAddressStream i = seq.stream();\r\n        for (int j = 0; j < 1048576; j ++) {\r\n            set.add(i.next());\r\n        }\r\n", "import java.util.concurrent.TimeUnit;\r\n\r\nimport static io.netty.resolver.dns.DefaultDnsServerAddressStreamProvider.DNS_PORT;\r\nimport static io.netty.util.internal.ObjectUtil.checkNotNull;\r\nimport static io.netty.util.internal.ObjectUtil.checkPositive;\r\n", "\r\n    @After\r\n    public void teardown() throws Exception {\r\n        assertFalse(channel.finish());\r\n    }\r\n", "\r\nimport static io.netty.util.internal.ObjectUtil.checkNotNull;\r\n\r\nfinal class LoggingDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\r\n    private final InternalLogger logger;\r\n", "                       final Throwable cause) {\r\n        if (completeEarly || nameServerAddrStreamIndex >= nameServerAddrStream.size() ||\r\n                allowedQueries == 0 || originalPromise.isCancelled() || promise.isCancelled()) {\r\n            tryToFinishResolve(nameServerAddrStream, nameServerAddrStreamIndex, question, queryLifecycleObserver,\r\n                               promise, cause);\r\n", "        dnsServer.start();\r\n\r\n        TestAuthoritativeDnsServerCache nsCache = new TestAuthoritativeDnsServerCache(\r\n                cache ? new DefaultAuthoritativeDnsServerCache() : NoopAuthoritativeDnsServerCache.INSTANCE);\r\n        TestRecursiveCacheDnsQueryLifecycleObserverFactory lifecycleObserverFactory =\r\n", "        @Override\r\n        protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\r\n            int oldSize = out.size();\r\n            super.decode(ctx, in, out);\r\n\r\n", "\r\nimport org.junit.Assert;\r\nimport org.junit.Test;\r\n\r\npublic class DnsServerAddressStreamProvidersTest {\r\n", "    public void testClear() throws Exception {\r\n        EventLoopGroup group = new DefaultEventLoopGroup(1);\r\n\r\n        try {\r\n            EventLoop loop = group.next();\r\n", "        @Override\r\n        protected void sortEntries(String hostname, List<InetSocketAddress> entries) {\r\n            if (comparator != null) {\r\n                Collections.sort(entries, comparator);\r\n            }\r\n", "        FullBinaryMemcacheRequest read = channel.readInbound();\r\n        assertEquals(\"key\", read.key().toString(CharsetUtil.UTF_8));\r\n        assertEquals(\"content\", read.content().toString(CharsetUtil.UTF_8));\r\n        assertEquals(\"extras\", read.extras().toString(CharsetUtil.UTF_8));\r\n        read.release();\r\n", "        byte flags = 0x01; // FLAG_FIN\r\n        int length = 4;\r\n        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;\r\n\r\n        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n", "package io.netty.resolver.dns;\r\n\r\nimport io.netty.util.internal.ObjectUtil;\r\n\r\nimport java.io.Serializable;\r\n", "\r\n    @Test\r\n    public void testSpdySettingsPersistValues() throws Exception {\r\n        short type = 4;\r\n        byte flags = 0;\r\n", "                            }\r\n                        } while (++i < entries.size());\r\n                        if (replacedEntry == null) {\r\n                            newEntries.add(e);\r\n                        }\r\n", "\r\n    private static Map<String, String> buildAliasMap(DnsResponse response, DnsCnameCache cache, EventLoop loop) {\r\n        final int answerCount = response.count(DnsSection.ANSWER);\r\n        Map<String, String> cnames = null;\r\n        for (int i = 0; i < answerCount; i ++) {\r\n", "            .optResourceEnabled(false)\r\n            .ndots(1);\r\n    }\r\n\r\n    private TestDnsServer dnsServer;\r\n", "    }\r\n\r\n    private static final class QueryRedirectedEvent {\r\n        final List<InetSocketAddress> nameServers;\r\n\r\n", "        int associatedToStreamId = RANDOM.nextInt() & 0x7FFFFFFF;\r\n        byte priority = (byte) (RANDOM.nextInt() & 0x07);\r\n\r\n        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeControlFrameHeader(buf, type, flags, length);\r\n", "        int associatedToStreamId = RANDOM.nextInt() & 0x7FFFFFFF;\r\n        byte priority = (byte) (RANDOM.nextInt() & 0x07);\r\n\r\n        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeControlFrameHeader(buf, type, flags, length);\r\n", "    private static class RedirectingTestDnsServer extends TestDnsServer {\r\n\r\n        private final String dnsAddress;\r\n        private final String domain;\r\n\r\n", "        @Override\r\n        protected DnsResponse decodeResponse(ChannelHandlerContext ctx, DatagramPacket packet) throws Exception {\r\n            DnsResponse response = super.decodeResponse(ctx, packet);\r\n            if (packet.content().isReadable()) {\r\n                // If there is still something to read we did stop parsing because of a truncated message.\r\n", "            assertEntry(entries.get(1), addr2);\r\n\r\n            List<? extends DnsCacheEntry> entries2 = cache.get(\"netty.io.\", null);\r\n            assertEquals(2, entries2.size());\r\n            assertEntry(entries2.get(0), addr1);\r\n", "            dst.trySuccess(src.getNow());\r\n        } else {\r\n            dst.tryFailure(src.cause());\r\n        }\r\n    }\r\n", "        public InetAddress address() {\r\n            return address;\r\n        }\r\n\r\n        @Override\r\n", "        for (InetAddress addr : fut.getNow()) {\r\n            list.add(addr.getHostAddress());\r\n        }\r\n        return list;\r\n    }\r\n", "                    new TestRecursiveCacheDnsQueryLifecycleObserverFactory();\r\n\r\n            DnsNameResolverBuilder builder = new DnsNameResolverBuilder(group.next())\r\n                    .dnsQueryLifecycleObserverFactory(lifecycleObserverFactory)\r\n                    .resolvedAddressTypes(ResolvedAddressTypes.IPV4_ONLY)\r\n", "import static org.hamcrest.core.IsEqual.equalTo;\r\n\r\n/**\r\n * Verifies the correct functionality of the {@link AbstractBinaryMemcacheEncoder}.\r\n */\r\n", "        public boolean release(int decrement) {\r\n            return false;\r\n        }\r\n    };\r\n\r\n", "            assertEquals(\"mapping.netty.io\", cache.get(\"y.netty.io\"));\r\n\r\n            assertTrue(cache.clear(\"x.netty.io\"));\r\n            assertNull(cache.get(\"x.netty.io\"));\r\n            assertEquals(\"mapping.netty.io\", cache.get(\"y.netty.io\"));\r\n", "     * @param cnameCache the cache used to cache {@code CNAME} mappings for a domain.\r\n     * @return {@code this}\r\n     */\r\n    public DnsNameResolverBuilder cnameCache(DnsCnameCache cnameCache) {\r\n        this.cnameCache  = cnameCache;\r\n", "import java.net.InetSocketAddress;\r\nimport java.net.UnknownHostException;\r\nimport java.util.AbstractList;\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\n", "\r\nimport java.net.InetSocketAddress;\r\nimport java.util.Collections;\r\nimport java.util.IdentityHashMap;\r\nimport java.util.Set;\r\n", "import java.net.Inet4Address;\r\nimport java.net.Inet6Address;\r\nimport java.net.InetAddress;\r\nimport java.net.InetSocketAddress;\r\nimport java.net.UnknownHostException;\r\n", "public class BinaryMemcacheObjectAggregatorTest {\r\n\r\n    private static final byte[] SET_REQUEST_WITH_CONTENT = {\r\n        (byte) 0x80, 0x01, 0x00, 0x03,\r\n        0x00, 0x00, 0x00, 0x00,\r\n", "        assertTrue(DnsNameResolver.isTransportOrTimeoutError(cause));\r\n        resolver.close();\r\n    }\r\n\r\n    @Test\r\n", "        public boolean release() {\r\n            return false;\r\n        }\r\n\r\n        @Override\r\n", "    }\r\n\r\n    @Test\r\n    public void testLastSpdySynStreamFrame() throws Exception {\r\n        short type = 1;\r\n", "     * <p>\r\n     * This may be null if the resolution failed, and in that case {@link #cause()} will describe the failure.\r\n     * @return the resolved address.\r\n     */\r\n    InetAddress address();\r\n", "        // Third message\r\n        response = channel.readInbound();\r\n        assertThat(response.status(), is(BinaryMemcacheResponseStatus.KEY_ENOENT));\r\n        assertThat(response.totalBodyLength(), is(msgBody.length()));\r\n        response.release();\r\n", "    @Test\r\n    public void testFollowCNAMEEvenIfARecordIsPresent() throws IOException {\r\n        TestDnsServer dnsServer2 = new TestDnsServer(new RecordStore() {\r\n\r\n            @Override\r\n", "\r\n        for (int j = 0; j < 2; j ++) {\r\n            DnsServerAddressStream i = seq.stream();\r\n            assertNext(i, ADDR1);\r\n            assertNext(i, ADDR2);\r\n", "            // Note that we do not break from the loop here, so we decode/cache all A/AAAA records.\r\n        }\r\n\r\n        if (cnames.isEmpty()) {\r\n            if (found) {\r\n", "            boolean optResourceEnabled,\r\n            HostsFileEntriesResolver hostsFileEntriesResolver,\r\n            DnsServerAddressStreamProvider dnsServerAddressStreamProvider,\r\n            String[] searchDomains,\r\n            int ndots,\r\n", "    public Future<AddressedEnvelope<DnsResponse, InetSocketAddress>> query(\r\n            InetSocketAddress nameServerAddr, DnsQuestion question,\r\n            Iterable<DnsRecord> additionals,\r\n            Promise<AddressedEnvelope<? extends DnsResponse, InetSocketAddress>> promise) {\r\n\r\n", "                            rm.put(DnsAttribute.IP_ADDRESS, ipv6Addr);\r\n                            break;\r\n                        default:\r\n                            return null;\r\n                    }\r\n", "    private final InternalLogLevel level;\r\n    private final DnsQuestion question;\r\n    private InetSocketAddress dnsServerAddress;\r\n\r\n    LoggingDnsQueryLifecycleObserver(DnsQuestion question, InternalLogger logger, InternalLogLevel level) {\r\n", "    @Test\r\n    public void testIpv6() throws UnknownHostException {\r\n        InetAddress ipv4Address1 = InetAddress.getByName(\"10.0.0.1\");\r\n        InetAddress ipv4Address2 = InetAddress.getByName(\"10.0.0.2\");\r\n        InetAddress ipv4Address3 = InetAddress.getByName(\"10.0.0.3\");\r\n", "    private final DnsRecordType[] resolveRecordTypes;\r\n    private final boolean decodeIdn;\r\n    private final DnsQueryLifecycleObserverFactory dnsQueryLifecycleObserverFactory;\r\n    private final boolean completeOncePreferredResolved;\r\n    private final ChannelFactory<? extends SocketChannel> socketChannelFactory;\r\n", "        }\r\n    }\r\n\r\n    @Test\r\n    public void testMultipleAdditionalRecordsForSameNSRecord() throws Exception {\r\n", "    }\r\n\r\n    private static void assertQueryObserver(DnsNameResolver resolver, DnsRecordType cancelledType) {\r\n        TestRecursiveCacheDnsQueryLifecycleObserverFactory lifecycleObserverFactory =\r\n                (TestRecursiveCacheDnsQueryLifecycleObserverFactory) resolver.dnsQueryLifecycleObserverFactory();\r\n", "package io.netty.resolver.dns;\r\n\r\nimport io.netty.handler.codec.dns.DnsQuestion;\r\n\r\nimport static io.netty.util.internal.ObjectUtil.checkNotNull;\r\n", "import java.net.InetSocketAddress;\r\nimport java.util.Collections;\r\nimport java.util.List;\r\n\r\nfinal class ShuffledDnsServerAddressStream implements DnsServerAddressStream {\r\n", "                intValue(minTtl, 0), intValue(maxTtl, Integer.MAX_VALUE),\r\n                // Let us use the sane ordering as DnsNameResolver will be used when returning\r\n                // nameservers from the cache.\r\n                new NameServerComparator(DnsNameResolver.preferredAddressType(resolvedAddressTypes).addressType()));\r\n    }\r\n", "                } else if (question.getDomainName().equals(secondName)) {\r\n                    rm.put(DnsAttribute.DOMAIN_NAME, lastName);\r\n                } else if (question.getDomainName().equals(lastName)) {\r\n                    rm.setDnsType(question.getRecordType());\r\n                    switch (question.getRecordType()) {\r\n", "                        UnknownHostException cause);\r\n\r\n    void resolve(final Promise<List<T>> promise) {\r\n        final String[] searchDomains = parent.searchDomains();\r\n        if (searchDomains.length == 0 || parent.ndots() == 0 || StringUtil.endsWith(hostname, '.')) {\r\n", "                    promise.addListener(new FutureListener<U>() {\r\n                        @Override\r\n                        public void operationComplete(Future<U> f) throws Exception {\r\n                            resolveMap.remove(inetHost);\r\n                        }\r\n", "        @Override\r\n        public InetAddress address() {\r\n            return address;\r\n        }\r\n\r\n", "        return parent.resolveCache();\r\n    }\r\n\r\n    /**\r\n     * The {@link DnsCnameCache} that is used for resolving.\r\n", "    public void testFollowCNAMELoop() throws IOException {\r\n        expectedException.expect(UnknownHostException.class);\r\n        TestDnsServer dnsServer2 = new TestDnsServer(new RecordStore() {\r\n\r\n            @Override\r\n", "    @Test\r\n    public void testSpdyWindowUpdateFrame() throws Exception {\r\n        short type = 9;\r\n        byte flags = 0;\r\n        int length = 8;\r\n", "    public static final byte ADDQ = 0x12;\r\n    public static final byte REPLACEQ = 0x13;\r\n    public static final byte DELETEQ = 0x14;\r\n    public static final byte INCREMENTQ = 0x15;\r\n    public static final byte DECREMENTQ = 0x16;\r\n", "\r\n/**\r\n * An interface that defines a binary Memcache message, providing common properties for\r\n * {@link BinaryMemcacheRequest} and {@link BinaryMemcacheResponse}.\r\n * <p/>\r\n", "    /**\r\n     * Resolves the {@link DnsRecord}s that are matched by the specified {@link DnsQuestion}. Unlike\r\n     * {@link #query(DnsQuestion)}, this method handles redirection, CNAMEs and multiple name servers.\r\n     * If the specified {@link DnsQuestion} is {@code A} or {@code AAAA}, this method looks up the configured\r\n     * {@link HostsFileEntries} before sending a query to the name servers. If a match is found in the\r\n", "    /**\r\n     * Resolves the {@link DnsRecord}s that are matched by the specified {@link DnsQuestion}. Unlike\r\n     * {@link #query(DnsQuestion)}, this method handles redirection, CNAMEs and multiple name servers.\r\n     * If the specified {@link DnsQuestion} is {@code A} or {@code AAAA}, this method looks up the configured\r\n     * {@link HostsFileEntries} before sending a query to the name servers. If a match is found in the\r\n", "public class BinaryMemcacheDecoderTest {\r\n\r\n    /**\r\n     * Represents a GET request header with a key size of three.\r\n     */\r\n", "import java.net.InetSocketAddress;\r\nimport java.net.URI;\r\nimport java.net.URISyntaxException;\r\nimport java.util.Hashtable;\r\nimport java.util.List;\r\n", "        };\r\n        redirectServer.start();\r\n        EventLoopGroup group = new NioEventLoopGroup(1);\r\n        final DnsNameResolver resolver = new DnsNameResolver(\r\n                group.next(), new ReflectiveChannelFactory<DatagramChannel>(NioDatagramChannel.class),\r\n", "    }\r\n\r\n    final DnsQueryLifecycleObserverFactory dnsQueryLifecycleObserverFactory() {\r\n        return dnsQueryLifecycleObserverFactory;\r\n    }\r\n", "\r\n        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeControlFrameHeader(buf, type, flags, length);\r\n        buf.writeInt(numSettings);\r\n        for (int i = 0; i < numSettings; i++) {\r\n", "import io.netty.buffer.Unpooled;\r\nimport io.netty.channel.ChannelHandlerContext;\r\nimport io.netty.handler.codec.DecoderResult;\r\nimport io.netty.handler.codec.memcache.AbstractMemcacheObjectDecoder;\r\nimport io.netty.handler.codec.memcache.DefaultLastMemcacheContent;\r\n", "            // fallback name server provider.\r\n            nsCache.cache(\"nettyfoo.com.\", dnsServer2.localAddress(), 10000, group.next());\r\n            resolver = new DnsNameResolver(\r\n                    group.next(), new ReflectiveChannelFactory<DatagramChannel>(NioDatagramChannel.class),\r\n                    NoopDnsCache.INSTANCE, nsCache, NoopDnsQueryLifecycleObserverFactory.INSTANCE, 3000,\r\n", "        for (int i = 1; i < 128; i++) {\r\n            try {\r\n                DnsResolveContext.cnameResolveFromCache(buildCache(i), HOSTNAME);\r\n                fail();\r\n            } catch (UnknownHostException expected) {\r\n", "\r\n    private static final PreferredAddressTypeComparator IPv4 = new PreferredAddressTypeComparator(Inet4Address.class);\r\n    private static final PreferredAddressTypeComparator IPv6 = new PreferredAddressTypeComparator(Inet6Address.class);\r\n\r\n    static PreferredAddressTypeComparator comparator(InternetProtocolFamily family) {\r\n", "            \"nicovideo.jp\",\r\n            \"google.co.th\",\r\n            \"dropbox.com\",\r\n            \"thepiratebay.org\",\r\n            \"google.com.sa\",\r\n", "import io.netty.channel.ChannelFactory;\r\nimport io.netty.channel.ChannelFuture;\r\nimport io.netty.channel.ChannelHandlerContext;\r\nimport io.netty.channel.ChannelInboundHandlerAdapter;\r\nimport io.netty.channel.EventLoop;\r\n", "    BinaryMemcacheMessage setKeyLength(short keyLength) {\r\n        this.keyLength = keyLength;\r\n        return this;\r\n    }\r\n\r\n", "    private static String cnameResolveFromCacheLoop(\r\n            DnsCnameCache cnameCache, String hostname, String first, String mapping) throws UnknownHostException {\r\n        // Detect loops by advance only every other iteration.\r\n        // See https://en.wikipedia.org/wiki/Cycle_detection#Floyd's_Tortoise_and_Hare\r\n        boolean advance = false;\r\n", "    }\r\n\r\n    @Override\r\n    public DnsCacheEntry cache(String hostname, DnsRecord[] additional, Throwable cause, EventLoop loop) {\r\n        return null;\r\n", "        }\r\n    }\r\n\r\n    private static final class QueryNoAnswerEvent {\r\n        final DnsResponseCode code;\r\n", "    @Test\r\n    public void testResolveACachedWithDot() {\r\n        final DnsCache cache = new DefaultDnsCache();\r\n        DnsNameResolver resolver = newResolver(ResolvedAddressTypes.IPV4_ONLY)\r\n                .resolveCache(cache).build();\r\n", "\r\n    /**\r\n     * Parse a file of the format <a href=\"https://linux.die.net/man/5/resolver\">/etc/resolv.conf</a> and return the\r\n     * list of search domains found in it or an empty list if not found.\r\n     * @param etcResolvConf a file of the format <a href=\"https://linux.die.net/man/5/resolver\">/etc/resolv.conf</a>.\r\n", "        testResolveAll0(ResolvedAddressTypes.IPV6_ONLY, NetUtil.LOCALHOST6, StringUtil.EMPTY_STRING);\r\n    }\r\n\r\n    @Test\r\n    public void testCNAMEResolveAllIpv4() throws IOException {\r\n", "\r\n    /**\r\n     * Create a new {@link DefaultFullBinaryMemcacheResponse} with the header, key, extras and content.\r\n     *\r\n     * @param key     the key to use.\r\n", "                // We are not interested in handling '.TLD.' as we should never serve the root servers from cache.\r\n                return null;\r\n            }\r\n            idx = idx2;\r\n\r\n", "     *\r\n     * @param dataType the data type of the message.\r\n     */\r\n    BinaryMemcacheMessage setDataType(byte dataType);\r\n\r\n", "import io.netty.handler.codec.dns.DnsResponse;\r\nimport io.netty.handler.codec.dns.DnsResponseCode;\r\nimport io.netty.handler.codec.dns.DnsSection;\r\nimport io.netty.util.NetUtil;\r\nimport io.netty.util.ReferenceCountUtil;\r\n", "import java.net.Socket;\r\nimport java.net.UnknownHostException;\r\nimport java.nio.ByteBuffer;\r\nimport java.util.ArrayDeque;\r\nimport java.util.ArrayList;\r\n", "    public BinaryMemcacheMessage touch(Object hint) {\r\n        if (key != null) {\r\n            key.touch(hint);\r\n        }\r\n        if (extras != null) {\r\n", "            initCause(cause.getCause());\r\n        }\r\n\r\n        // Suppress a warning since this method doesn't need synchronization\r\n        @Override\r\n", "\r\n/**\r\n * Default implementation of a {@link BinaryMemcacheMessage}.\r\n */\r\n@UnstableApi\r\n", "            // Only try if not empty as otherwise we will produce an exception\r\n            if (dnsUrls != null && !dnsUrls.isEmpty()) {\r\n                String[] servers = dnsUrls.split(\" \");\r\n                for (String server : servers) {\r\n                    try {\r\n", "            DnsNameResolverBuilder builder = new DnsNameResolverBuilder(group.next())\r\n                    .resolvedAddressTypes(ResolvedAddressTypes.IPV4_ONLY)\r\n                    .dnsQueryLifecycleObserverFactory(lifecycleObserverFactory)\r\n                    .channelType(NioDatagramChannel.class)\r\n                    .optResourceEnabled(false)\r\n", "package io.netty.handler.codec.memcache;\r\n\r\nimport io.netty.handler.codec.DecoderResult;\r\nimport io.netty.util.AbstractReferenceCounted;\r\nimport io.netty.util.internal.ObjectUtil;\r\n", "        assertTrue(channel.writeOutbound(req));\r\n        // header + content\r\n        assertEquals(2, channel.outboundMessages().size());\r\n        assertTrue(channel.writeInbound(channel.readOutbound(), channel.readOutbound()));\r\n\r\n", "        int length = 8;\r\n        int lastGoodStreamId = RANDOM.nextInt() & 0x7FFFFFFF;\r\n        int statusCode = RANDOM.nextInt() | 0x01;\r\n\r\n        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n", "\r\n    @Override\r\n    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\r\n        logger.log(level, \"from {} : {} redirected\", dnsServerAddress, question);\r\n        return this;\r\n", "    }\r\n\r\n    @Override\r\n    public ByteBuf extras() {\r\n        return extras;\r\n", "package io.netty.resolver.dns;\r\n\r\nimport io.netty.util.NetUtil;\r\nimport io.netty.util.internal.PlatformDependent;\r\nimport org.apache.directory.server.dns.DnsServer;\r\n", "    MemcacheContent retainedDuplicate();\r\n\r\n    @Override\r\n    MemcacheContent replace(ByteBuf content);\r\n\r\n", "     * <p>\r\n     * Note that only macOS and Linux are currently supported.\r\n     * @return A {@link DnsServerAddressStreamProvider} which inherits the DNS servers from your local host's\r\n     * configuration.\r\n     */\r\n", "                lenBuffer.putShort((short) ioBuffer.remaining());\r\n                lenBuffer.flip();\r\n\r\n                while (lenBuffer.hasRemaining()) {\r\n                    socket.getOutputStream().write(lenBuffer.get());\r\n", "package io.netty.handler.codec.memcache.binary;\r\n\r\nimport io.netty.buffer.ByteBuf;\r\nimport io.netty.handler.codec.memcache.FullMemcacheMessage;\r\nimport io.netty.util.internal.UnstableApi;\r\n", "package io.netty.handler.codec.memcache.binary;\r\n\r\nimport io.netty.buffer.ByteBuf;\r\nimport io.netty.handler.codec.memcache.FullMemcacheMessage;\r\nimport io.netty.util.internal.UnstableApi;\r\n", "package io.netty.handler.codec.memcache.binary;\r\n\r\nimport io.netty.buffer.ByteBuf;\r\nimport io.netty.channel.ChannelHandlerContext;\r\nimport io.netty.handler.codec.MessageToByteEncoder;\r\n", "     * {@link HostsFileEntries} before sending a query to the name servers. If a match is found in the\r\n     * {@link HostsFileEntries}, a synthetic {@code A} or {@code AAAA} record will be returned.\r\n     *\r\n     * @param question the question\r\n     * @param additionals additional records ({@code OPT})\r\n", "                new DefaultFullBinaryMemcacheRequest(key, extras, content);\r\n\r\n        fullRequest.setMagic(request.magic());\r\n        fullRequest.setOpcode(request.opcode());\r\n        fullRequest.setKeyLength(request.keyLength());\r\n", "            // We should always have the same order in the cache.\r\n            assertEquals(ns1Address, cached.get(0));\r\n            assertEquals(ns2Address, cached.get(1));\r\n            assertEquals(ns3Address, cached.get(2));\r\n            assertEquals(ns4Address, cached.get(3));\r\n", "            public void operationComplete(final Future<List<InetAddress>> future) {\r\n                // Remove placeholder.\r\n                queriesInProgress.remove(resolveFuture);\r\n\r\n                if (future.isSuccess()) {\r\n", "        assertThat(request.extras(), nullValue());\r\n\r\n        assertThat(request.keyLength(), is((short) 3));\r\n        assertThat(request.extrasLength(), is((byte) 0));\r\n        assertThat(request.totalBodyLength(), is(11));\r\n", "        return this;\r\n    }\r\n\r\n    /**\r\n     * Compute a {@link ResolvedAddressTypes} from some {@link InternetProtocolFamily}s.\r\n", "                                           final DnsQueryLifecycleObserver queryLifecycleObserver,\r\n                                           final Promise<List<T>> promise,\r\n                                           final Throwable cause) {\r\n        final String nameServerName = PlatformDependent.javaVersion() >= 7 ?\r\n                nameServerAddr.getHostString() : nameServerAddr.getHostName();\r\n", "        content.release();\r\n    }\r\n\r\n    @Test\r\n    public void shouldRetainCurrentMessageWhenSendingItOut() {\r\n", "            List<InetAddress> addrs = resolver.resolveAll(inetHost).syncUninterruptibly().getNow();\r\n            assertEquals(Arrays.asList(\r\n                    SocketUtils.allAddressesByName(inetHost)), addrs);\r\n        } finally {\r\n            resolver.close();\r\n", "\r\n    @Test\r\n    public void testDefaultAddresses() {\r\n        assertThat(defaultAddressList().size(), is(greaterThan(0)));\r\n    }\r\n", "\r\npackage io.netty.handler.codec.memcache;\r\n\r\nimport io.netty.buffer.ByteBuf;\r\nimport io.netty.buffer.Unpooled;\r\n", "import io.netty.util.concurrent.EventExecutor;\r\nimport io.netty.util.concurrent.Promise;\r\nimport io.netty.util.internal.StringUtil;\r\n\r\nimport java.net.InetAddress;\r\n", "                for (int i = 0; i < stream.size(); i++) {\r\n                    addresses.add(stream.next());\r\n                }\r\n            }\r\n            return addresses.get(index);\r\n", "    }\r\n\r\n    @Override\r\n    protected boolean isLastContentMessage(MemcacheContent msg) throws Exception {\r\n        return msg instanceof LastMemcacheContent;\r\n", "            EventLoop eventLoop,\r\n            ChannelFactory<? extends DatagramChannel> channelFactory,\r\n            ChannelFactory<? extends SocketChannel> socketChannelFactory,\r\n            final DnsCache resolveCache,\r\n            final DnsCnameCache cnameCache,\r\n", "        } else {\r\n            logger.log(level, \"{} query never written and cancelled with {} queries remaining\", question,\r\n                        queriesRemaining);\r\n        }\r\n    }\r\n", "        final Future<AddressedEnvelope<DnsResponse, InetSocketAddress>> f =\r\n                parent.query0(nameServerAddr, question, additionals, flush, writePromise, queryPromise);\r\n\r\n        queriesInProgress.add(f);\r\n\r\n", "        public DnsCacheEntry cache(String hostname, DnsRecord[] additionals, Throwable cause, EventLoop loop) {\r\n            return cache.cache(hostname, additionals, cause, loop);\r\n        }\r\n    }\r\n\r\n", "                } else {\r\n                    assertEquals(ns1Address, cached.next());\r\n                    assertEquals(ns2Address, cached.next());\r\n                }\r\n            }\r\n", "\r\n/**\r\n * Implementations and Interfaces for the Memcache Binary protocol.\r\n */\r\n@UnstableApi\r\n", "        if (key != null) {\r\n            key = key.retainedDuplicate();\r\n        }\r\n        ByteBuf extras = extras();\r\n        if (extras != null) {\r\n", "        if (key != null) {\r\n            key = key.retainedDuplicate();\r\n        }\r\n        ByteBuf extras = extras();\r\n        if (extras != null) {\r\n", "            \"diply.com\",\r\n            \"amazon.co.uk\",\r\n            \"so.com\",\r\n            \"google.com.ar\",\r\n            \"coccoc.com\",\r\n", "        assertNext(i, ADDR2);\r\n        assertNext(i, ADDR3);\r\n        assertNext(i, ADDR1);\r\n        assertNext(i, ADDR2);\r\n        assertNext(i, ADDR3);\r\n", "    @Override\r\n    public void cache(String hostname, InetSocketAddress address, long originalTtl, EventLoop loop) {\r\n        // We only cache resolved addresses.\r\n        if (!address.isUnresolved()) {\r\n            cache.cache(hostname, EMPTY, address.getAddress(), originalTtl, loop);\r\n", "                    buf.append(r.type().name());\r\n                    buf.append(' ');\r\n                    buf.append(recordContent.readUnsignedShort());\r\n                    buf.append(' ');\r\n                    buf.append(DnsResolveContext.decodeDomainName(recordContent));\r\n", "\r\n        TestDnsQueryLifecycleObserver(DnsQuestion question) {\r\n            this.question = question;\r\n        }\r\n\r\n", "        final String hostname = \"txt.netty.io\";\r\n        final String txt1 = \"some text\";\r\n        final String txt2 = \"some more text\";\r\n\r\n        TestDnsServer server = new TestDnsServer(new RecordStore() {\r\n", "        try {\r\n            UnixResolverDnsServerAddressStreamProvider nameServerCache =\r\n                    new UnixResolverDnsServerAddressStreamProvider(ETC_RESOLV_CONF_FILE, ETC_RESOLVER_DIR);\r\n            return nameServerCache.mayOverrideNameServers() ? nameServerCache\r\n                                                            : DefaultDnsServerAddressStreamProvider.INSTANCE;\r\n", "\r\n    private static final byte[] GET_RESPONSE_CHUNK_1 =  {\r\n        (byte) 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00,\r\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e, 0x6f, 0x74, 0x20, 0x66, 0x6f, 0x75, 0x6e,\r\n        0x64, (byte) 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,\r\n", "    FullMemcacheMessage retain(int increment);\r\n\r\n    @Override\r\n    FullMemcacheMessage retain();\r\n\r\n", "                throw error;\r\n            }\r\n        } finally {\r\n            group.shutdownGracefully();\r\n        }\r\n", "                throw error;\r\n            }\r\n        } finally {\r\n            group.shutdownGracefully();\r\n        }\r\n", "            final DefaultAuthoritativeDnsServerCache cache = new DefaultAuthoritativeDnsServerCache();\r\n            cache.cache(\"netty.io\", unresolved, 100, loop);\r\n            cache.cache(\"netty.io\", resolved1, 10000, loop);\r\n\r\n            DnsServerAddressStream entries = cache.get(\"netty.io\");\r\n", "            \"nameserver 127.0.0.11\\n\");\r\n        assertEquals(16, parseEtcResolverOptions(f).attempts());\r\n    }\r\n\r\n    @Test\r\n", "    /**\r\n     * @deprecated Use {@link DefaultDnsServerAddressStreamProvider#defaultAddressList()}.\r\n     * <p>\r\n     * Returns the list of the system DNS server addresses. If it failed to retrieve the list of the system DNS server\r\n     * addresses from the environment, it will return {@code \"8.8.8.8\"} and {@code \"8.8.4.4\"}, the addresses of the\r\n", "\r\n    @BeforeClass\r\n    public static void before() throws UnknownHostException {\r\n        IPV4ADDRESS1 = new InetSocketAddress(InetAddress.getByAddress(\"ns1\", new byte[] { 10, 0, 0, 1 }), 53);\r\n        IPV4ADDRESS2 = new InetSocketAddress(InetAddress.getByAddress(\"ns2\", new byte[] { 10, 0, 0, 2 }), 53);\r\n", "\r\n        DnsCache resolveCache = this.resolveCache != null ? this.resolveCache : newCache();\r\n        DnsCnameCache cnameCache = this.cnameCache != null ? this.cnameCache : newCnameCache();\r\n        AuthoritativeDnsServerCache authoritativeDnsServerCache = this.authoritativeDnsServerCache != null ?\r\n                this.authoritativeDnsServerCache : newAuthoritativeDnsServerCache();\r\n", "    }\r\n\r\n    @Test\r\n    public void defaultReturnedWhenNoBetterMatch() throws Exception {\r\n        File f = buildFile(\"domain linecorp.local\\n\" +\r\n", "            List<InetAddress> addresses = resolver.resolveAll(host).syncUninterruptibly().getNow();\r\n            assertEquals(2, addresses.size());\r\n            for (InetAddress address: addresses) {\r\n                assertThat(address, instanceOf(Inet4Address.class));\r\n                assertEquals(host, address.getHostName());\r\n", "\r\n    @BeforeClass\r\n    public static void init() throws Exception {\r\n        dnsServer.start();\r\n    }\r\n", "import io.netty.handler.codec.memcache.AbstractMemcacheObjectEncoder;\r\nimport io.netty.util.internal.UnstableApi;\r\n\r\n/**\r\n * A {@link MessageToByteEncoder} that encodes binary memcache messages into bytes.\r\n", "/**\r\n * Marker interface for both ascii and binary messages.\r\n */\r\n@UnstableApi\r\npublic interface MemcacheMessage extends MemcacheObject, ReferenceCounted {\r\n", "                logger.debug(\"Unable to decode DNS response: UDP [{}]\", ctx.channel(), cause);\r\n            } else {\r\n                logger.warn(\"Unexpected exception: UDP [{}]\", ctx.channel(), cause);\r\n            }\r\n        }\r\n", "        int length = 8 * numSettings + 4;\r\n\r\n        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeControlFrameHeader(buf, type, flags, length);\r\n        buf.writeInt(numSettings);\r\n", "        int length = 8 * numSettings + 4;\r\n\r\n        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeControlFrameHeader(buf, type, flags, length);\r\n        buf.writeInt(numSettings);\r\n", "\r\n    private static InternalLogLevel checkAndConvertLevel(LogLevel level) {\r\n        return checkNotNull(level, \"level\").toInternalLevel();\r\n    }\r\n\r\n", "import io.netty.handler.codec.memcache.DefaultMemcacheContent;\r\nimport io.netty.handler.codec.memcache.LastMemcacheContent;\r\nimport io.netty.handler.codec.memcache.MemcacheContent;\r\nimport io.netty.util.internal.UnstableApi;\r\n\r\n", "        byte flags = 0;\r\n        int length = 8; // invalid length\r\n        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;\r\n        int associatedToStreamId = RANDOM.nextInt() & 0x7FFFFFFF;\r\n\r\n", "        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeControlFrameHeader(buf, type, flags, length);\r\n        buf.writeInt(numSettings);\r\n        for (int i = 0; i < numSettings; i++) {\r\n            buf.writeByte(idFlags);\r\n", "        switch (family) {\r\n            case IPv4:\r\n                return IPv4;\r\n            case IPv6:\r\n                return IPv6;\r\n", "                \"google.de\",\r\n                \"google.co.jp\",\r\n                \"google.co.uk\",\r\n                \"google.fr\",\r\n                \"google.com.br\",\r\n", "import java.net.DatagramSocket;\r\nimport java.net.Inet4Address;\r\nimport java.net.InetAddress;\r\nimport java.net.InetSocketAddress;\r\nimport java.net.ServerSocket;\r\n", "        assertEquals(expected, addresses);\r\n    }\r\n\r\n    @Test\r\n    public void testSortAlreadySortedMixed() {\r\n", "\r\n    @Test\r\n    public void testResolveA() throws Exception {\r\n        DnsNameResolver resolver = newResolver(ResolvedAddressTypes.IPV4_ONLY)\r\n                // Cache for eternity\r\n", "        public Throwable cause() {\r\n            return null;\r\n        }\r\n\r\n        @Override\r\n", "\r\n    private static final String HOSTNAME = \"netty.io.\";\r\n\r\n    @Test\r\n    public void testCnameLoop() {\r\n", "        return new DnsNameResolverBuilder(group.next())\r\n                .channelType(NioDatagramChannel.class)\r\n                .nameServerProvider(\r\n                        new SingletonDnsServerAddressStreamProvider(SocketUtils.socketAddress(\"8.8.8.8\", 53)))\r\n                .maxQueriesPerResolve(1)\r\n", "\r\n        @Override\r\n        public boolean cancel(boolean mayInterruptIfRunning) {\r\n            return false;\r\n        }\r\n", "        int length = 4;\r\n        int streamId = 0; // invalid stream identifier\r\n\r\n        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeControlFrameHeader(buf, type, flags, length);\r\n", "import static java.lang.Math.min;\r\n\r\nabstract class DnsResolveContext<T> {\r\n\r\n    private static final RuntimeException NXDOMAIN_QUERY_FAILED_EXCEPTION =\r\n", "    }\r\n\r\n    private static void encodeControlFrameHeader(ByteBuf buffer, short type, byte flags, int length) {\r\n        buffer.writeShort(0x8000 | SpdyVersion.SPDY_3_1.getVersion());\r\n        buffer.writeShort(type);\r\n", "                                   final Promise<InetAddress> promise,\r\n                                   DnsCache resolveCache, boolean completeEarlyIfPossible) {\r\n        final Promise<List<InetAddress>> allPromise = executor().newPromise();\r\n        doResolveAllUncached(hostname, additionals, promise, allPromise, resolveCache, true);\r\n        allPromise.addListener(new FutureListener<List<InetAddress>>() {\r\n", "        public LastMemcacheContent touch(Object hint) {\r\n            return this;\r\n        }\r\n\r\n        @Override\r\n", "            return cached;\r\n        }\r\n\r\n        @Override\r\n        public DnsCacheEntry cache(String hostname, DnsRecord[] additionals, InetAddress address,\r\n", "    private boolean recursionDesired = true;\r\n    private int maxQueriesPerResolve = -1;\r\n    private boolean traceEnabled;\r\n    private int maxPayloadSize = 4096;\r\n    private boolean optResourceEnabled = true;\r\n", "        assertTrue(channel.writeInbound(channel.readOutbound(), channel.readOutbound()));\r\n\r\n        FullBinaryMemcacheResponse read = channel.readInbound();\r\n        assertEquals(\"key\", read.key().toString(CharsetUtil.UTF_8));\r\n        assertEquals(\"content\", read.content().toString(CharsetUtil.UTF_8));\r\n", "\r\n    @Test\r\n    public void testAddMultipleAddressesForSameHostname() throws Exception {\r\n        InetAddress addr1 = InetAddress.getByAddress(new byte[] { 10, 0, 0, 1 });\r\n        InetAddress addr2 = InetAddress.getByAddress(new byte[] { 10, 0, 0, 2 });\r\n", "    public static final byte FLUSH = 0x08;\r\n    public static final byte GETQ = 0x09;\r\n    public static final byte NOOP = 0x0a;\r\n    public static final byte VERSION = 0x0b;\r\n    public static final byte GETK = 0x0c;\r\n", "    public void testIllegalSpdyRstStreamFrameStatusCode() throws Exception {\r\n        short type = 3;\r\n        byte flags = 0;\r\n        int length = 8;\r\n        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;\r\n", "                DEFAULT_RESOLVE_ADDRESS_TYPES = ResolvedAddressTypes.IPV4_PREFERRED;\r\n                LOCALHOST_ADDRESS = NetUtil.LOCALHOST4;\r\n            }\r\n        }\r\n    }\r\n", "        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeControlFrameHeader(buf, type, flags, length);\r\n        buf.writeInt(0); // invalid num_settings\r\n        for (int i = 0; i < numSettings; i++) {\r\n            buf.writeByte(idFlags);\r\n", "                continue;\r\n            }\r\n\r\n            resolve(resolver, futures, name);\r\n        }\r\n", "\r\n    @Test\r\n    public void testCancelPromise() throws Exception {\r\n        final EventLoop eventLoop = group.next();\r\n        final Promise<InetAddress> promise = eventLoop.newPromise();\r\n", "    protected abstract Channel channel();\r\n    protected abstract String protocol();\r\n\r\n    void query(boolean flush, ChannelPromise writePromise) {\r\n        final DnsQuestion question = question();\r\n", "/**\r\n * A {@link DnsQueryLifecycleObserverFactory} that enables detailed logging in the {@link DnsNameResolver}.\r\n * <p>\r\n * When {@linkplain DnsNameResolverBuilder#dnsQueryLifecycleObserverFactory(DnsQueryLifecycleObserverFactory)\r\n * configured on the resolver}, detailed trace information will be generated so that it is easier to understand the\r\n", "    }\r\n\r\n    private static void assertNotResolve(DnsNameResolver resolver, String inetHost) throws InterruptedException {\r\n        Future<InetAddress> fut = resolver.resolve(inetHost);\r\n        assertTrue(fut.await(10, TimeUnit.SECONDS));\r\n", "import org.apache.directory.server.dns.io.decoder.DnsMessageDecoder;\r\nimport org.apache.directory.server.dns.io.encoder.DnsMessageEncoder;\r\nimport org.apache.directory.server.dns.io.encoder.ResourceRecordEncoder;\r\nimport org.apache.directory.server.dns.messages.DnsMessage;\r\nimport org.apache.directory.server.dns.messages.QuestionRecord;\r\n", "    public LastMemcacheContent touch(Object hint) {\r\n        super.touch(hint);\r\n        return this;\r\n    }\r\n\r\n", "                }\r\n            }\r\n        } catch (NamingException ignore) {\r\n            // Will try reflection if this fails.\r\n        }\r\n", "\r\n        DnsServerAddresses defaultNameServerAddresses\r\n                = etcResolvConfMap.get(etcResolvConf.getName());  // lgtm[java/dereferenced-value-may-be-null]\r\n        if (defaultNameServerAddresses == null) {\r\n            Collection<DnsServerAddresses> values = etcResolvConfMap.values();\r\n", "                                    int allowedQueries) {\r\n        super(parent, originalPromise, hostname, dnsClass, expectedTypes, additionals, nameServerAddrs, allowedQueries);\r\n    }\r\n\r\n    @Override\r\n", "\r\n    /**\r\n     * Parse a file of the format <a href=\"https://linux.die.net/man/5/resolver\">/etc/resolv.conf</a> and return the\r\n     * list of search domains found in it or an empty list if not found.\r\n     * @return List of search domains.\r\n", "    }\r\n\r\n    @Override\r\n    public BinaryMemcacheMessage setCas(long cas) {\r\n        this.cas = cas;\r\n", "\r\n    @Override\r\n    public byte extrasLength() {\r\n        return extrasLength;\r\n    }\r\n", "    }\r\n\r\n    private static void testNonCachedResolveEmptyHostName(String inetHost) throws Exception {\r\n        DnsNameResolver resolver = newNonCachedResolver(ResolvedAddressTypes.IPV4_ONLY).build();\r\n        try {\r\n", "                   .append(\" queries \");\r\n            } else {\r\n                buf.append(\". Exceeded max queries per resolve \")\r\n                .append(maxAllowedQueries)\r\n                .append(' ');\r\n", "\r\n    InternetProtocolFamily[] resolvedInternetProtocolFamiliesUnsafe() {\r\n        return resolvedInternetProtocolFamilies;\r\n    }\r\n\r\n", "                }\r\n            } finally {\r\n                if (promise.isDone()) {\r\n                    resolveMap.remove(inetHost);\r\n                } else {\r\n", "\r\n                    currentMessage.setExtras(in.readRetainedSlice(extrasLength));\r\n                }\r\n\r\n                state = State.READ_KEY;\r\n", "        @Override\r\n        public InetSocketAddress next() {\r\n            return address;\r\n        }\r\n\r\n", "import io.netty.resolver.InetNameResolver;\r\nimport io.netty.resolver.ResolvedAddressTypes;\r\nimport io.netty.util.NetUtil;\r\nimport io.netty.util.concurrent.EventExecutor;\r\nimport io.netty.util.concurrent.FastThreadLocal;\r\n", "    private int opaque;\r\n    private long cas;\r\n\r\n    /**\r\n     * Create a new instance with all properties set.\r\n", "     * @param a The {@link DnsQueryLifecycleObserver} that will receive events first.\r\n     * @param b The {@link DnsQueryLifecycleObserver} that will receive events second.\r\n     */\r\n    public BiDnsQueryLifecycleObserver(DnsQueryLifecycleObserver a, DnsQueryLifecycleObserver b) {\r\n        this.a = checkNotNull(a, \"a\");\r\n", "                // We may want to remove this in the future and let the user just specify the opt record in the query.\r\n            };\r\n        } else {\r\n            optResource = null;\r\n        }\r\n", "\r\n/**\r\n * Combines two {@link DnsQueryLifecycleObserverFactory} into a single {@link DnsQueryLifecycleObserverFactory}.\r\n */\r\npublic final class BiDnsQueryLifecycleObserverFactory implements DnsQueryLifecycleObserverFactory {\r\n", "        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the minimum and maximum TTL of the cached DNS resource records (in seconds). If the TTL of the DNS\r\n", "     * @param nameServers The name servers the query has been redirected to.\r\n     * @return An observer for the new query which we may issue.\r\n     */\r\n    DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers);\r\n\r\n", "        String resolved = question.name().toLowerCase(Locale.US);\r\n        boolean found = false;\r\n        while (!cnames.isEmpty()) { // Do not attempt to call Map.remove() when the Map is empty\r\n                                    // because it can be Collections.emptyMap()\r\n                                    // whose remove() throws a UnsupportedOperationException.\r\n", "        this.optResourceEnabled = optResourceEnabled;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n", "                    query(nameServerAddrStream, nameServerAddrStreamIndex + 1, question, queryLifecycleObserver,\r\n                          true, promise, cause);\r\n                }\r\n                return;\r\n            }\r\n", "     * Returns the {@link InetSocketAddress} of the DNS query that has failed.\r\n     */\r\n    public InetSocketAddress remoteAddress() {\r\n        return remoteAddress;\r\n    }\r\n", "                assertEquals(ipv6Addr, NetUtil.toAddressString(resolvedAddress));\r\n            }\r\n            assertEquals(firstName, resolvedAddress.getHostName());\r\n        } finally {\r\n            dnsServer2.stop();\r\n", "        String hostname() {\r\n            return hostname;\r\n        }\r\n\r\n        @Override\r\n", "import org.junit.rules.TemporaryFolder;\r\n\r\nimport java.io.File;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\n", "    }\r\n\r\n    @Override\r\n    public void cache(String hostname, String cname, long originalTtl, EventLoop loop) {\r\n        checkNotNull(hostname, \"hostname\");\r\n", "import io.netty.util.concurrent.Future;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.List;\r\n", "        ByteBuf segment2 = Unpooled.buffer(segment);\r\n        encodeControlFrameHeader(header, type, flags, length);\r\n        segment1.writeInt(RANDOM.nextInt());\r\n        segment2.writeInt(RANDOM.nextInt());\r\n\r\n", "                resetDecoder();\r\n\r\n                currentMessage = decodeHeader(in);\r\n                state = State.READ_EXTRAS;\r\n            } catch (Exception e) {\r\n", "                eventLoop,\r\n                newNameResolver(eventLoop, channelFactory, nameServerProvider),\r\n                resolvesInProgress,\r\n                resolveAllsInProgress);\r\n\r\n", "    LastMemcacheContent replace(ByteBuf content);\r\n\r\n    @Override\r\n    LastMemcacheContent retain(int increment);\r\n\r\n", "@UnstableApi\r\npublic class DefaultLastMemcacheContent extends DefaultMemcacheContent implements LastMemcacheContent {\r\n\r\n    public DefaultLastMemcacheContent() {\r\n        super(Unpooled.buffer());\r\n", "        headerBlock.release();\r\n    }\r\n\r\n    @Test\r\n    public void testMissingNameLength() throws Exception {\r\n", "\r\n    private static final Set<String> DOMAINS_ALL;\r\n\r\n    static {\r\n        Set<String> all = new HashSet<String>(DOMAINS.size() + DOMAINS_PUNYCODE.size());\r\n", "     * The default value depends on the value of the system property {@code \"java.net.preferIPv6Addresses\"}.\r\n     */\r\n    public ResolvedAddressTypes resolvedAddressTypes() {\r\n        return resolvedAddressTypes;\r\n    }\r\n", "    @Override\r\n    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\r\n    }\r\n\r\n    @Override\r\n", "\r\n/**\r\n * A {@link DnsServerAddressStreamProvider} which is backed by a sequential list of DNS servers.\r\n */\r\npublic final class SequentialDnsServerAddressStreamProvider extends UniSequentialDnsServerAddressStreamProvider {\r\n", "     */\r\n    ByteBuf key();\r\n\r\n    /**\r\n     * Sets the key of the document. {@link ByteBuf#release()} ownership of {@code key}\r\n", "        super.touch();\r\n        return this;\r\n    }\r\n\r\n    @Override\r\n", "        super.touch();\r\n        return this;\r\n    }\r\n\r\n    @Override\r\n", "        super.touch();\r\n        return this;\r\n    }\r\n\r\n    @Override\r\n", "        super.touch();\r\n        return this;\r\n    }\r\n\r\n    @Override\r\n", "    public Future<AddressedEnvelope<DnsResponse, InetSocketAddress>> query(\r\n            InetSocketAddress nameServerAddr, DnsQuestion question) {\r\n\r\n        return query0(nameServerAddr, question, EMPTY_ADDITIONALS, true, ch.newPromise(),\r\n                      ch.eventLoop().<AddressedEnvelope<? extends DnsResponse, InetSocketAddress>>newPromise());\r\n", "        RedirectingTestDnsServer(String domain, String dnsAddress) {\r\n            super(Collections.singleton(domain));\r\n            this.domain = domain;\r\n            this.dnsAddress = dnsAddress;\r\n        }\r\n", "        }\r\n        return name;\r\n    }\r\n\r\n    private static void checkCnameLoop(String hostname, String first, String second) throws UnknownHostException {\r\n", "package io.netty.resolver.dns;\r\n\r\n/**\r\n * Provides an opportunity to override which {@link DnsServerAddressStream} is used to resolve a specific hostname.\r\n * <p>\r\n", "        }\r\n        return stream;\r\n    }\r\n\r\n    private void followCname(DnsQuestion question, String cname, DnsQueryLifecycleObserver queryLifecycleObserver,\r\n", "    private final DnsNameResolver parent;\r\n    private final Promise<AddressedEnvelope<DnsResponse, InetSocketAddress>> promise;\r\n    private final int id;\r\n    private final DnsQuestion question;\r\n    private final DnsRecord[] additionals;\r\n", "    }\r\n\r\n    @Override\r\n    protected boolean ignoreContentAfterContinueResponse(Object msg) throws Exception {\r\n        throw new UnsupportedOperationException();\r\n", "import io.netty.channel.socket.DatagramChannel;\r\nimport io.netty.channel.socket.InternetProtocolFamily;\r\nimport io.netty.channel.socket.SocketChannel;\r\nimport io.netty.resolver.HostsFileEntriesResolver;\r\nimport io.netty.resolver.ResolvedAddressTypes;\r\n", "        assertThat(content.readInt(), is(0x01020304));\r\n        record.release();\r\n    }\r\n\r\n    @Test\r\n", "package io.netty.handler.codec.memcache;\r\n\r\nimport io.netty.buffer.ByteBuf;\r\nimport io.netty.buffer.ByteBufHolder;\r\nimport io.netty.channel.ChannelPipeline;\r\n", "    public static final short KEY_ENOENT = 0x01;\r\n    public static final short KEY_EEXISTS = 0x02;\r\n    public static final short E2BIG = 0x03;\r\n    public static final short EINVA = 0x04;\r\n    public static final short NOT_STORED = 0x05;\r\n", "            return Long.MIN_VALUE;\r\n        }\r\n\r\n        @Override\r\n        public int compareTo(Delayed o) {\r\n", "        try {\r\n            resolver = newResolver()\r\n                    .resolveCache(NoopDnsCache.INSTANCE)\r\n                    .cnameCache(NoopDnsCnameCache.INSTANCE)\r\n                    .recursionDesired(true)\r\n", "        try {\r\n            resolver = newResolver()\r\n                    .resolveCache(NoopDnsCache.INSTANCE)\r\n                    .cnameCache(NoopDnsCnameCache.INSTANCE)\r\n                    .recursionDesired(true)\r\n", "            if (r.type() != DnsRecordType.NS || !(r instanceof DnsRawRecord)) {\r\n                return;\r\n            }\r\n\r\n            // Only include servers that serve the correct domain.\r\n", "                    .maxQueriesPerResolve(16)\r\n                    .nameServerProvider(new DnsServerAddressStreamProvider() {\r\n                        @Override\r\n                        public DnsServerAddressStream nameServerAddressStream(String hostname) {\r\n                            if (hostname.equals(secondName + '.')) {\r\n", "    public void testSort2() {\r\n        List<InetSocketAddress> expected = Arrays.asList(\r\n                IPV4ADDRESS1, IPV4ADDRESS2, IPV6ADDRESS1, IPV6ADDRESS2, UNRESOLVED1, UNRESOLVED2);\r\n        List<InetSocketAddress> addresses = new ArrayList<InetSocketAddress>(\r\n                Arrays.asList(IPV4ADDRESS1, IPV6ADDRESS1, IPV6ADDRESS2, UNRESOLVED1, IPV4ADDRESS2, UNRESOLVED2));\r\n", "        this.resolveAllsInProgress = checkNotNull(resolveAllsInProgress, \"resolveAllsInProgress\");\r\n    }\r\n\r\n    @Override\r\n    public Future<T> resolve(String inetHost) {\r\n", "     * {@link HostsFileEntries}, a synthetic {@code A} or {@code AAAA} record will be returned.\r\n     *\r\n     * @param question the question\r\n     * @param additionals additional records ({@code OPT})\r\n     *\r\n", "        short type = 3;\r\n        byte flags = 0;\r\n        int length = 8;\r\n        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;\r\n        int statusCode = RANDOM.nextInt() | 0x01;\r\n", "                return null;\r\n            }\r\n\r\n            @Override\r\n            public DnsCacheEntry cache(\r\n", "\r\n    @Test\r\n    public void testPipelinedSpdyDataFrames() throws Exception {\r\n        int streamId1 = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;\r\n        int streamId2 = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;\r\n", "        request.setTotalBodyLength(totalBodyLength);\r\n\r\n        boolean result = channel.writeOutbound(request);\r\n        assertThat(result, is(true));\r\n        result = channel.writeOutbound(content1);\r\n", "\r\n    @Override\r\n    public DnsServerAddressStream nameServerAddressStream(String hostname) {\r\n        for (;;) {\r\n            int i = hostname.indexOf('.', 1);\r\n", "        return resolve(inetHost, executor.<T>newPromise());\r\n    }\r\n\r\n    @Override\r\n    public Future<List<T>> resolveAll(String inetHost) {\r\n", "import io.netty.util.concurrent.Future;\r\nimport io.netty.util.concurrent.FutureListener;\r\nimport io.netty.util.concurrent.Promise;\r\nimport io.netty.util.internal.StringUtil;\r\n\r\n", "\r\n            if (cnames == null) {\r\n                cnames = new HashMap<String, String>(min(8, answerCount));\r\n            }\r\n\r\n", "            assertEquals(dnsServer.localAddress(), writtenEvent1.dnsServerAddress);\r\n            QueryRedirectedEvent redirectedEvent = (QueryRedirectedEvent) observer.events.poll();\r\n\r\n            assertEquals(expectedDnsName, redirectedEvent.nameServers.get(0).getHostName());\r\n            assertEquals(dnsServerAuthority.localAddress(), redirectedEvent.nameServers.get(0));\r\n", "                public void operationComplete(Future<Object> future) {\r\n                    try {\r\n                        assertThat(future.cause(),\r\n                                instanceOf(UnsupportedAddressTypeException.class));\r\n                        assertTrue(loop.inEventLoop());\r\n", "        assertNext(i, ADDR2);\r\n        assertNext(i, ADDR3);\r\n        assertNext(i, ADDR1);\r\n        assertNext(i, ADDR2);\r\n\r\n", "        checkNotNull(cname, \"cname\");\r\n        checkNotNull(loop, \"loop\");\r\n        cache.cache(hostname, cname, Math.max(minTtl, (int) Math.min(maxTtl, originalTtl)), loop);\r\n    }\r\n\r\n", "    // guards against loops in the cache but early return once a loop is detected.\r\n    //\r\n    // Visible for testing only\r\n    static String cnameResolveFromCache(DnsCnameCache cnameCache, String name) throws UnknownHostException {\r\n        String first = cnameCache.get(hostnameWithDot(name));\r\n", "            protected DnsMessage filterMessage(DnsMessage message) {\r\n                for (QuestionRecord record: message.getQuestionRecords()) {\r\n                    if (record.getDomainName().equals(hostname)) {\r\n                        message.getAdditionalRecords().clear();\r\n                        message.getAnswerRecords().clear();\r\n", " * A {@link DnsServerAddressStreamProvider} which iterates through a collection of\r\n * {@link DnsServerAddressStreamProvider} until the first non-{@code null} result is found.\r\n */\r\npublic final class MultiDnsServerAddressStreamProvider implements DnsServerAddressStreamProvider {\r\n    private final DnsServerAddressStreamProvider[] providers;\r\n", "        }\r\n    }\r\n\r\n    /**\r\n     * Parse a file of the format <a href=\"https://linux.die.net/man/5/resolver\">/etc/resolv.conf</a> which may contain\r\n", "        }\r\n    }\r\n\r\n    /**\r\n     * Parse a file of the format <a href=\"https://linux.die.net/man/5/resolver\">/etc/resolv.conf</a> which may contain\r\n", "package io.netty.handler.codec.memcache.binary;\r\n\r\nimport io.netty.buffer.ByteBuf;\r\nimport io.netty.handler.codec.memcache.MemcacheMessage;\r\nimport io.netty.util.internal.UnstableApi;\r\n", "     * @param address the nameserver address (which may be unresolved).\r\n     * @param originalTtl the TTL as returned by the DNS server\r\n     * @param loop the {@link EventLoop} used to register the TTL timeout\r\n     */\r\n    void cache(String hostname, InetSocketAddress address, long originalTtl, EventLoop loop);\r\n", "    private final InetSocketAddress remoteAddress;\r\n    private final DnsQuestion question;\r\n\r\n    public DnsNameResolverException(InetSocketAddress remoteAddress, DnsQuestion question, String message) {\r\n        super(message);\r\n", "\r\n    public static final int DEFAULT_MAX_CHUNK_SIZE = 8192;\r\n\r\n    private final int chunkSize;\r\n\r\n", "        assertTrue(fut.await(10, TimeUnit.SECONDS));\r\n        assertFalse(fut.isSuccess());\r\n        final Throwable cause = fut.cause();\r\n        assertThat(cause, instanceOf(UnknownHostException.class));\r\n        assertThat(\"search domain is included in UnknownHostException\", cause.getMessage(),\r\n", "            InetAddress ipv4InetAddress = InetAddress.getByAddress(\"netty.com\",\r\n                    InetAddress.getByName(ipv4Address).getAddress());\r\n            InetAddress ipv6InetAddress = InetAddress.getByAddress(\"netty.com\",\r\n                    InetAddress.getByName(ipv6Address).getAddress());\r\n\r\n", "     * Google public DNS servers.\r\n     */\r\n    @Deprecated\r\n    public static List<InetSocketAddress> defaultAddressList() {\r\n        return DefaultDnsServerAddressStreamProvider.defaultAddressList();\r\n", "\r\n    static {\r\n        DOMAINS_PUNYCODE.put(\"b\u00fcchner.de\", \"xn--bchner-3ya.de\");\r\n        DOMAINS_PUNYCODE.put(\"m\u00fcller.de\", \"xn--mller-kva.de\");\r\n    }\r\n", "    @Override\r\n    public LastMemcacheContent retainedDuplicate() {\r\n        return replace(content().retainedDuplicate());\r\n    }\r\n\r\n", "    public Future<AddressedEnvelope<DnsResponse, InetSocketAddress>> query(\r\n            InetSocketAddress nameServerAddr, DnsQuestion question, Iterable<DnsRecord> additionals) {\r\n\r\n        return query0(nameServerAddr, question, toArray(additionals, false), true, ch.newPromise(),\r\n                     ch.eventLoop().<AddressedEnvelope<? extends DnsResponse, InetSocketAddress>>newPromise());\r\n", "        final List<InetSocketAddress> cached = new CopyOnWriteArrayList<InetSocketAddress>();\r\n        final AuthoritativeDnsServerCache authoritativeDnsServerCache = new AuthoritativeDnsServerCache() {\r\n            @Override\r\n            public DnsServerAddressStream get(String hostname) {\r\n                return null;\r\n", "        final List<InetSocketAddress> cached = new CopyOnWriteArrayList<InetSocketAddress>();\r\n        final AuthoritativeDnsServerCache authoritativeDnsServerCache = new AuthoritativeDnsServerCache() {\r\n            @Override\r\n            public DnsServerAddressStream get(String hostname) {\r\n                return null;\r\n", "\r\n    @After\r\n    public void tearDown() {\r\n        decoder.end();\r\n    }\r\n", "     * @param decodeChunkSize the maximum chunk size.\r\n     */\r\n    public BinaryMemcacheClientCodec(int decodeChunkSize) {\r\n        this(decodeChunkSize, false);\r\n    }\r\n", "                StringBuilder buf = new StringBuilder();\r\n                for (DnsRecord r : mxList) {\r\n                    ByteBuf recordContent = ((ByteBufHolder) r).content();\r\n\r\n                    buf.append(StringUtil.NEWLINE);\r\n", "                recursionDesired,\r\n                maxQueriesPerResolve,\r\n                traceEnabled,\r\n                maxPayloadSize,\r\n                optResourceEnabled,\r\n", "        return completeEarlyIfPossible && parent.preferredAddressType().addressType() == resolved.getClass();\r\n    }\r\n\r\n    @Override\r\n    boolean isDuplicateAllowed() {\r\n", "                // If we are configured to use TCP as a fallback lets replay the dns message over TCP\r\n                Socket socket = serverSocket.accept();\r\n\r\n                InputStream in = socket.getInputStream();\r\n                assertTrue((in.read() << 8 | (in.read() & 0xff)) > 2); // skip length field\r\n", "    private final Class<? extends InetAddress> preferredAddressType;\r\n\r\n    private PreferredAddressTypeComparator(Class<? extends InetAddress> preferredAddressType) {\r\n        this.preferredAddressType = preferredAddressType;\r\n    }\r\n", "                    rm.put(DnsAttribute.SERVICE_WEIGHT, \"1\");\r\n                    return Collections.singleton(rm.getEntry());\r\n                }\r\n                return null;\r\n            }\r\n", "            final ByteBuf recordContent = ((ByteBufHolder) r).content();\r\n            final String domainName = decodeDomainName(recordContent);\r\n            if (domainName == null) {\r\n                continue;\r\n            }\r\n", "        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e, 0x6f, 0x74, 0x20, 0x66, 0x6f, 0x75,\r\n    };\r\n\r\n    private static final byte[] GET_RESPONSE_CHUNK_2 = {\r\n            0x6e, 0x64, (byte) 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00,\r\n", "                }\r\n            } else {\r\n                set(singletonList(e));\r\n                scheduleCacheExpirationIfNeeded(ttl, loop);\r\n            }\r\n", "\r\npublic class DnsNameResolverTest {\r\n\r\n    private static final InternalLogger logger = InternalLoggerFactory.getInstance(DnsNameResolver.class);\r\n    private static final long DEFAULT_TEST_TIMEOUT_MS = 30000;\r\n", "            assertEquals(txt, texts.get(0));\r\n\r\n            if (tcpFallback) {\r\n                assertFalse(envelope.content().isTruncated());\r\n            } else {\r\n", "    public DefaultBinaryMemcacheRequest(ByteBuf key) {\r\n        this(key, null);\r\n    }\r\n\r\n    /**\r\n", "        buf.release();\r\n    }\r\n\r\n    @Test\r\n    public void testUnknownSpdySettingsFlags() throws Exception {\r\n", "     * @param completeOncePreferredResolved {@code true} to enable, {@code false} to disable.\r\n     * @return {@code this}\r\n     */\r\n    public DnsNameResolverBuilder completeOncePreferredResolved(boolean completeOncePreferredResolved) {\r\n        this.completeOncePreferredResolved = completeOncePreferredResolved;\r\n", "    private void tryToFinishResolve(final DnsServerAddressStream nameServerAddrStream,\r\n                                    final int nameServerAddrStreamIndex,\r\n                                    final DnsQuestion question,\r\n                                    final DnsQueryLifecycleObserver queryLifecycleObserver,\r\n                                    final Promise<List<T>> promise,\r\n", "\r\n        fullResponse.setMagic(response.magic());\r\n        fullResponse.setOpcode(response.opcode());\r\n        fullResponse.setKeyLength(response.keyLength());\r\n        fullResponse.setExtrasLength(response.extrasLength());\r\n", "            if (types == ResolvedAddressTypes.IPV4_PREFERRED) {\r\n                assertEquals(ipv4Address, resolved.getHostAddress());\r\n            } else {\r\n                assertEquals(ipv6Address, resolved.getHostAddress());\r\n            }\r\n", "                        mxList.add(r);\r\n                    }\r\n                }\r\n\r\n                assertThat(mxList.size(), is(greaterThan(0)));\r\n", "    }\r\n\r\n    @Test\r\n    public void testAddSameAddressForSameHostname() throws Exception {\r\n        InetAddress addr1 = InetAddress.getByAddress(new byte[] { 10, 0, 0, 1 });\r\n", "    /**\r\n     * Sets the {@link EventLoop} which will perform the communication with the DNS servers.\r\n     *\r\n     * @param eventLoop the {@link EventLoop}\r\n     * @return {@code this}\r\n", "        short type = 8;\r\n        byte flags = 0;\r\n        int length = 4;\r\n        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;\r\n\r\n", "    @Test\r\n    public void testUseConfiguredEventLoop() throws InterruptedException {\r\n        NioEventLoopGroup group = new NioEventLoopGroup(1);\r\n        final EventLoop loop = group.next();\r\n        DefaultEventLoopGroup defaultEventLoopGroup = new DefaultEventLoopGroup(1);\r\n", "            List<InetAddress> resolvedAddresses =\r\n                    resolver.resolveAll(\"x.netty.io\").syncUninterruptibly().getNow();\r\n            assertEquals(1, resolvedAddresses.size());\r\n            assertTrue(resolvedAddresses.contains(InetAddress.getByAddress(new byte[] { 10, 0, 0, 99 })));\r\n\r\n", "    public void testExpire() throws Throwable {\r\n        EventLoopGroup group = new DefaultEventLoopGroup(1);\r\n\r\n        try {\r\n            EventLoop loop = group.next();\r\n", "            ChannelFactory<? extends DatagramChannel> channelFactory,\r\n            final DnsCache resolveCache,\r\n            final DnsCache authoritativeDnsServerCache,\r\n            DnsQueryLifecycleObserverFactory dnsQueryLifecycleObserverFactory,\r\n            long queryTimeoutMillis,\r\n", "                    Set<ResourceRecord> records = new HashSet<ResourceRecord>(2);\r\n\r\n                    ResourceRecordModifier rm = new ResourceRecordModifier();\r\n                    rm.setDnsClass(RecordClass.IN);\r\n                    rm.setDnsName(name);\r\n", "            if (noComparator) {\r\n                cache = new DefaultAuthoritativeDnsServerCache(10000, 10000, null);\r\n            }  else {\r\n                cache = new DefaultAuthoritativeDnsServerCache(10000, 10000,\r\n                                                               new Comparator<InetSocketAddress>() {\r\n", "     * @param buf    the {@link ByteBuf} to write into.\r\n     * @param extras the extras to encode.\r\n     */\r\n    private static void encodeExtras(ByteBuf buf, ByteBuf extras) {\r\n        if (extras == null || !extras.isReadable()) {\r\n", "        int streamId = RANDOM.nextInt() & 0x7FFFFFFF;\r\n        int deltaWindowSize = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;\r\n\r\n        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeControlFrameHeader(buf, type, flags, length);\r\n", "        SearchDomainUnknownHostException(Throwable cause, String originalHostname) {\r\n            super(\"Search domain query failed. Original hostname: '\" + originalHostname + \"' \" + cause.getMessage());\r\n            setStackTrace(cause.getStackTrace());\r\n\r\n            // Preserve the cause\r\n", "\r\n    @Test\r\n    public void nameServerAddressStreamShouldBeRotationalWhenRotationOptionsIsPresent() throws Exception {\r\n        File f = buildFile(\"options rotate\\n\" +\r\n            \"domain linecorp.local\\n\" +\r\n", "\r\n        @Override\r\n        public long getDelay(TimeUnit unit) {\r\n            // We ignore unit and always return the minimum value to ensure the TTL of the cancelled marker is\r\n            // the smallest.\r\n", "    @Test\r\n    public void testEmptySpdySettingsFrame() throws Exception {\r\n        short type = 4;\r\n        byte flags = 0;\r\n        int numSettings = 0;\r\n", "    private static void validateAdditional(DnsRecord record, boolean validateType) {\r\n        checkNotNull(record, \"record\");\r\n        if (validateType && record instanceof DnsRawRecord) {\r\n            throw new IllegalArgumentException(\"DnsRawRecord implementations not allowed: \" + record);\r\n        }\r\n", "     * @param extras  the extras to use.\r\n     * @param content the content of the full request.\r\n     */\r\n    public DefaultFullBinaryMemcacheResponse(ByteBuf key, ByteBuf extras,\r\n        ByteBuf content) {\r\n", "            DnsServerAddressStreamProvider dnsServerAddressStreamProvider,\r\n            String[] searchDomains,\r\n            int ndots,\r\n            boolean decodeIdn,\r\n            boolean completeOncePreferredResolved) {\r\n", "        TestDnsServer redirectServer = new TestDnsServer(new HashSet<String>(Arrays.asList(hostname, ns1Name))) {\r\n            @Override\r\n            protected DnsMessage filterMessage(DnsMessage message) {\r\n                for (QuestionRecord record: message.getQuestionRecords()) {\r\n                    if (record.getDomainName().equals(hostname)) {\r\n", "     * @return a valid content chunk indicating failure.\r\n     */\r\n    private MemcacheContent invalidChunk(Exception cause) {\r\n        state = State.BAD_MESSAGE;\r\n        MemcacheContent chunk = new DefaultLastMemcacheContent(Unpooled.EMPTY_BUFFER);\r\n", "        assertHostNameEquals(\"127.0.0.3\", stream.next());\r\n    }\r\n\r\n    @Test\r\n    public void moreRefinedSelectionReturnedWhenMatch() throws Exception {\r\n", "     *\r\n     * @param buf the {@link ByteBuf} to write into.\r\n     * @param msg the message to encode.\r\n     */\r\n    protected abstract void encodeHeader(ByteBuf buf, M msg);\r\n", "     * the default DNS server to use, and also overrides for individual domains. Also parse a directory of the format\r\n     * <a href=\"\r\n     * https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man5/resolver.5.html\">\r\n     * /etc/resolver</a> which may contain multiple files to override the name servers used for multiple domains.\r\n     * @param etcResolvConf <a href=\"https://linux.die.net/man/5/resolver\">/etc/resolv.conf</a>.\r\n", "    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return SequentialDnsServerAddressStream.toString(\"shuffled\", i, addresses);\r\n", "        short type = 4;\r\n        byte flags = 0;\r\n        int numSettings = 1;\r\n        int length = 8 * numSettings + 4;\r\n        byte idFlags = 0x02; // FLAG_SETTINGS_PERSISTED\r\n", "    /**\r\n     * Sends a DNS query with the specified question.\r\n     */\r\n    public Future<AddressedEnvelope<DnsResponse, InetSocketAddress>> query(\r\n            DnsQuestion question, Promise<AddressedEnvelope<? extends DnsResponse, InetSocketAddress>> promise) {\r\n", "    }\r\n\r\n    private void onResponse(final DnsServerAddressStream nameServerAddrStream, final int nameServerAddrStreamIndex,\r\n                            final DnsQuestion question, AddressedEnvelope<DnsResponse, InetSocketAddress> envelope,\r\n                            final DnsQueryLifecycleObserver queryLifecycleObserver,\r\n", "            }\r\n\r\n            @Override\r\n            public void cache(String hostname, InetSocketAddress address, long originalTtl, EventLoop loop) {\r\n                cached.add(address);\r\n", "            }\r\n\r\n            @Override\r\n            public void cache(String hostname, InetSocketAddress address, long originalTtl, EventLoop loop) {\r\n                cached.add(address);\r\n", "import io.netty.handler.codec.dns.DnsQuery;\r\nimport io.netty.handler.codec.dns.DnsQuestion;\r\nimport io.netty.handler.codec.dns.DnsRecord;\r\nimport io.netty.handler.codec.dns.DnsResponse;\r\nimport io.netty.util.concurrent.Promise;\r\n", "import io.netty.handler.codec.dns.DnsQuery;\r\nimport io.netty.handler.codec.dns.DnsQuestion;\r\nimport io.netty.handler.codec.dns.DnsRecord;\r\nimport io.netty.handler.codec.dns.DnsResponse;\r\nimport io.netty.util.concurrent.Promise;\r\n", "    MemcacheMessage retain();\r\n\r\n    /**\r\n     * Increases the reference count by the specified {@code increment}.\r\n     */\r\n", "            @Override\r\n            public List<? extends DnsCacheEntry> get(String hostname, DnsRecord[] additionals) {\r\n                return Collections.emptyList();\r\n            }\r\n\r\n", "\r\n    @Override\r\n    public List<? extends DnsCacheEntry> get(String hostname, DnsRecord[] additionals) {\r\n        return Collections.emptyList();\r\n    }\r\n", "        DnsMessageModifier modifier = new DnsMessageModifier();\r\n        modifier.setAcceptNonAuthenticatedData(message.isAcceptNonAuthenticatedData());\r\n        modifier.setAdditionalRecords(message.getAdditionalRecords());\r\n        modifier.setAnswerRecords(message.getAnswerRecords());\r\n        modifier.setAuthoritativeAnswer(message.isAuthoritativeAnswer());\r\n", "                } else {\r\n                    // Ignore the server and try the next one...\r\n                    query(nameServerAddrStream, nameServerAddrStreamIndex + 1,\r\n                          question, queryLifecycleObserver, true, promise, cause);\r\n                }\r\n", "    /**\r\n     * Create a new {@link DefaultBinaryMemcacheResponse} with the header and key.\r\n     *\r\n     * @param key    the key to use.\r\n     */\r\n", "        int x = comparator.compare(IPV4ADDRESS1, IPV6ADDRESS1);\r\n        int y = comparator.compare(IPV6ADDRESS1, IPV4ADDRESS1);\r\n\r\n        assertEquals(-1, x);\r\n        assertEquals(x, -y);\r\n", "\r\n        written = channel.readOutbound();\r\n        assertThat(written.readableBytes(), is(content2.content().readableBytes()));\r\n        assertThat(\r\n                written.readSlice(content2.content().readableBytes()).toString(CharsetUtil.UTF_8),\r\n", "    private DnsNameResolverBuilder newResolver() {\r\n        return new DnsNameResolverBuilder(group.next())\r\n            .channelType(NioDatagramChannel.class)\r\n            .nameServerProvider(new SingletonDnsServerAddressStreamProvider(dnsServer.localAddress()))\r\n            .maxQueriesPerResolve(1)\r\n", "                        message.getAdditionalRecords().clear();\r\n                        message.getAnswerRecords().clear();\r\n                        message.getAuthorityRecords().add(TestDnsServer.newNsRecord(domain, ns1Name));\r\n                        message.getAdditionalRecords().add(newARecord(ns1Address));\r\n                        message.getAdditionalRecords().add(newARecord(ns2Address));\r\n", "package io.netty.handler.codec.memcache;\r\n\r\nimport io.netty.buffer.ByteBuf;\r\nimport io.netty.util.internal.UnstableApi;\r\n\r\n", "            List<InetAddress> resolved2 = resolver.resolveAll(expected.getHostName()).syncUninterruptibly().getNow();\r\n            assertEquals(1, resolved2.size());\r\n            assertEquals(expected, resolved2.get(0));\r\n\r\n            if (authoritativeDnsServerCache != NoopAuthoritativeDnsServerCache.INSTANCE) {\r\n", "package io.netty.handler.codec.memcache.binary;\r\n\r\nimport static io.netty.util.internal.ObjectUtil.checkPositiveOrZero;\r\n\r\nimport io.netty.buffer.ByteBuf;\r\n", "        int lastGoodStreamId = RANDOM.nextInt() & 0x7FFFFFFF;\r\n        int statusCode = RANDOM.nextInt() | 0x01;\r\n\r\n        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeControlFrameHeader(buf, type, flags, length);\r\n", "import io.netty.util.concurrent.GenericFutureListener;\r\nimport io.netty.util.concurrent.Promise;\r\nimport io.netty.util.concurrent.ScheduledFuture;\r\nimport io.netty.util.internal.logging.InternalLogger;\r\nimport io.netty.util.internal.logging.InternalLoggerFactory;\r\n", "    protected AddressResolver<InetSocketAddress> newResolver(\r\n            EventLoop eventLoop, ChannelFactory<? extends DatagramChannel> channelFactory,\r\n            DnsServerAddressStreamProvider nameServerProvider) throws Exception {\r\n\r\n        final NameResolver<InetAddress> resolver = new InflightNameResolver<InetAddress>(\r\n", "import org.apache.directory.server.dns.messages.RecordClass;\r\nimport org.apache.directory.server.dns.messages.RecordType;\r\nimport org.apache.directory.server.dns.messages.ResourceRecord;\r\nimport org.apache.directory.server.dns.messages.ResourceRecordImpl;\r\nimport org.apache.directory.server.dns.messages.ResourceRecordModifier;\r\n", "     *\r\n     * @param channelFactory the {@link ChannelFactory} or {@code null}\r\n     *                       if <a href=\"https://tools.ietf.org/html/rfc7766\">TCP fallback</a> should not be supported.\r\n     * @return {@code this}\r\n     */\r\n", "        DnsNameResolver resolver = newResolver(decode).build();\r\n        try {\r\n            for (Entry<String, String> entries : DOMAINS_PUNYCODE.entrySet()) {\r\n                InetAddress address = resolver.resolve(entries.getKey()).syncUninterruptibly().getNow();\r\n                assertEquals(decode ? entries.getKey() : entries.getValue(), address.getHostName());\r\n", "    /**\r\n     * Sends a DNS query with the specified question.\r\n     */\r\n    public Future<AddressedEnvelope<DnsResponse, InetSocketAddress>> query(DnsQuestion question) {\r\n        return query(nextNameServerAddress(), question);\r\n", "import io.netty.util.internal.UnstableApi;\r\n\r\n/**\r\n * The default implementation for the {@link LastMemcacheContent}.\r\n */\r\n", "    }\r\n\r\n    @Test(timeout = DEFAULT_TEST_TIMEOUT_MS)\r\n    public void aAndAAAAQueryShouldTryFirstDnsServerBeforeSecond() throws IOException {\r\n        final String knownHostName = \"netty.io\";\r\n", "        return resolve(resolvesInProgress, inetHost, promise, false);\r\n    }\r\n\r\n    @Override\r\n    public Promise<List<T>> resolveAll(String inetHost, Promise<List<T>> promise) {\r\n", "        }\r\n    }\r\n\r\n    @Test(timeout = DEFAULT_TEST_TIMEOUT_MS)\r\n    public void secondDnsServerShouldBeUsedBeforeCNAMEFirstServerNotStarted() throws IOException {\r\n", "        decoder.decode(header);\r\n        decoder.decode(segment1);\r\n        decoder.decode(segment2);\r\n        verifyZeroInteractions(delegate);\r\n        assertFalse(header.isReadable());\r\n", "    }\r\n\r\n    private static void testNonCachedResolveAllEmptyHostName(String inetHost) throws UnknownHostException {\r\n        DnsNameResolver resolver = newNonCachedResolver(ResolvedAddressTypes.IPV4_ONLY).build();\r\n        try {\r\n", "                }\r\n                if (alias.get()) {\r\n                    ResourceRecordModifier rm = new ResourceRecordModifier();\r\n                    rm.setDnsClass(RecordClass.IN);\r\n                    rm.setDnsName(name);\r\n", "     */\r\n    void queryCancelled(int queriesRemaining);\r\n\r\n    /**\r\n     * The query has been redirected to another list of DNS servers.\r\n", "                        && internetProtocolFamilies[1] == InternetProtocolFamily.IPv4) ?\r\n                        ResolvedAddressTypes.IPV6_PREFERRED: ResolvedAddressTypes.IPV6_ONLY;\r\n            default:\r\n                throw new IllegalArgumentException(\r\n                        \"Couldn't resolve ResolvedAddressTypes from InternetProtocolFamily array\");\r\n", "    private static final int maxHeaderSize = 16;\r\n\r\n    private static final String name = \"name\";\r\n    private static final String value = \"value\";\r\n    private static final byte[] nameBytes = name.getBytes();\r\n", "    }\r\n\r\n    @Override\r\n    DnsCnameCache cnameCache() {\r\n        // We don't use a cache here at all as we also don't cache if we end up using the DnsRecordResolverContext.\r\n", "    }\r\n\r\n    @Test\r\n    public void testResolveAAAAorA() throws Exception {\r\n        DnsNameResolver resolver = newResolver(ResolvedAddressTypes.IPV6_PREFERRED).build();\r\n", "    }\r\n\r\n    private static void assertResolvedAddress(InetAddress resolvedAddress, String ipAddr, String hostname) {\r\n        assertEquals(ipAddr, resolvedAddress.getHostAddress());\r\n        assertEquals(hostname, resolvedAddress.getHostName());\r\n", "        });\r\n        final TestDnsServer dnsServer3 = new TestDnsServer(new RecordStore() {\r\n            @Override\r\n            public Set<ResourceRecord> getRecords(QuestionRecord question) throws DnsException {\r\n                if (question.getDomainName().equals(lastName)) {\r\n", "     * Create a new {@link DefaultBinaryMemcacheRequest} with the header only.\r\n     *\r\n     * @param key    the key to use.\r\n     * @param extras the extras to use.\r\n     */\r\n", "                                    MACOS_PROVIDER_CLASS_NAME,\r\n                                    true,\r\n                                    DnsServerAddressStreamProviders.class.getClassLoader());\r\n                        } catch (Throwable cause) {\r\n                            return cause;\r\n", "\r\n    public RoundRobinDnsAddressResolverGroup(DnsNameResolverBuilder dnsResolverBuilder) {\r\n        super(dnsResolverBuilder);\r\n    }\r\n\r\n", "\r\n    @Test\r\n    public void testUnknownSpdyDataFrameFlags() throws Exception {\r\n        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;\r\n        byte flags = (byte) 0xFE; // should ignore any unknown flags\r\n", "    @Test\r\n    public void testInstanceWithNullPreferredAddressType() {\r\n        new DnsNameResolver(\r\n                group.next(), // eventLoop\r\n                new ReflectiveChannelFactory<DatagramChannel>(NioDatagramChannel.class), // channelFactory\r\n", "        testExpireWithTTL0(1000);\r\n        testExpireWithTTL0(1000000);\r\n    }\r\n\r\n    private static void testExpireWithTTL0(int days) {\r\n", "        testExpireWithTTL0(1000);\r\n        testExpireWithTTL0(1000000);\r\n    }\r\n\r\n    private static void testExpireWithTTL0(int days) {\r\n", "                    String hostname, DnsRecord[] additionals, InetAddress address, long originalTtl, EventLoop loop) {\r\n                return null;\r\n            }\r\n\r\n            @Override\r\n", "\r\n    private void doResolveAllUncached(final String hostname,\r\n                                      final DnsRecord[] additionals,\r\n                                      final Promise<?> originalPromise,\r\n                                      final Promise<List<InetAddress>> promise,\r\n", "\r\n            // As this address was supplied as ADDITIONAL we should put it resolved into the cache.\r\n            assertEquals(ns0Address, cached.get(0));\r\n            assertEquals(ns5Address, cached.get(1));\r\n\r\n", "        int associatedToStreamId = RANDOM.nextInt() & 0x7FFFFFFF;\r\n        byte priority = (byte) (RANDOM.nextInt() & 0x07);\r\n\r\n        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length + headerBlockLength);\r\n        encodeControlFrameHeader(buf, type, flags, length + headerBlockLength);\r\n", "    /**\r\n     * Cache a value for the given hostname that will automatically expire once the TTL is reached.\r\n     */\r\n    final void cache(String hostname, E value, int ttl, EventLoop loop) {\r\n        Entries entries = resolveCache.get(hostname);\r\n", "        byte flags = (byte) 0xFF; // invalid flags\r\n        int length = 8;\r\n        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;\r\n        int statusCode = RANDOM.nextInt() | 0x01;\r\n\r\n", "        assertFalse(segment1.isReadable());\r\n        assertFalse(segment2.isReadable());\r\n        header.release();\r\n        segment1.release();\r\n        segment2.release();\r\n", "\r\n        if (PlatformDependent.javaVersion() >= 7 && address.getHostString() == null) {\r\n            // We only cache addresses that have also a host string as we will need it later when trying to replace\r\n            // unresolved entries in the cache.\r\n            return;\r\n", "        return newAddressResolver(eventLoop, resolver);\r\n    }\r\n\r\n    /**\r\n     * Creates a new {@link NameResolver}. Override this method to create an alternative {@link NameResolver}\r\n", "\r\n    @Test\r\n    public void testSortAlreadySortedNotPreferred() {\r\n        List<InetSocketAddress> expected = Arrays.asList(IPV4ADDRESS1, IPV4ADDRESS2, IPV4ADDRESS3);\r\n        List<InetSocketAddress> addresses = new ArrayList<InetSocketAddress>(expected);\r\n", "    public static ResolvedAddressTypes computeResolvedAddressTypes(InternetProtocolFamily... internetProtocolFamilies) {\r\n        if (internetProtocolFamilies == null || internetProtocolFamilies.length == 0) {\r\n            return DnsNameResolver.DEFAULT_RESOLVE_ADDRESS_TYPES;\r\n        }\r\n        if (internetProtocolFamilies.length > 2) {\r\n", "    DnsAddressResolveContext(DnsNameResolver parent, Promise<?> originalPromise,\r\n                             String hostname, DnsRecord[] additionals,\r\n                             DnsServerAddressStream nameServerAddrs, int allowedQueries, DnsCache resolveCache,\r\n                             AuthoritativeDnsServerCache authoritativeDnsServerCache,\r\n                             boolean completeEarlyIfPossible) {\r\n", "                        // If the query is done in a late fashion (as the channel was not ready yet) we always flush\r\n                        // to ensure we did not race with a previous flush() that was done when the Channel was not\r\n                        // ready yet.\r\n                        writeQuery(query, true, writePromise);\r\n                    } else {\r\n", "        try {\r\n            AuthoritativeDnsServerCache nsCache = new DefaultAuthoritativeDnsServerCache();\r\n            // What we want to test is the following:\r\n            // 1. Do a DNS query.\r\n            // 2. CNAME is returned, we want to lookup that CNAME on multiple DNS servers\r\n", "        assertFalse(buf.isReadable());\r\n        buf.release();\r\n    }\r\n\r\n    @Test\r\n", "        assertFalse(buf.isReadable());\r\n        buf.release();\r\n    }\r\n\r\n    @Test\r\n", "        assertFalse(buf.isReadable());\r\n        buf.release();\r\n    }\r\n\r\n    @Test\r\n", "        assertFalse(buf.isReadable());\r\n        buf.release();\r\n    }\r\n\r\n    @Test\r\n", "        assertFalse(buf.isReadable());\r\n        buf.release();\r\n    }\r\n\r\n    @Test\r\n", "        assertFalse(buf.isReadable());\r\n        buf.release();\r\n    }\r\n\r\n    @Test\r\n", "        assertFalse(buf.isReadable());\r\n        buf.release();\r\n    }\r\n\r\n    @Test\r\n", "        assertFalse(buf.isReadable());\r\n        buf.release();\r\n    }\r\n\r\n    @Test\r\n", "            } catch (Exception e) {\r\n                resetDecoder();\r\n                out.add(invalidMessage(e));\r\n                return;\r\n            }\r\n", "import io.netty.util.ReferenceCountUtil;\r\nimport io.netty.util.concurrent.Future;\r\nimport io.netty.util.concurrent.Promise;\r\nimport io.netty.util.internal.PlatformDependent;\r\nimport io.netty.util.internal.SocketUtils;\r\n", "    private final DnsQueryLifecycleObserver a;\r\n    private final DnsQueryLifecycleObserver b;\r\n\r\n    /**\r\n     * Create a new instance.\r\n", "                Object maybeProvider = AccessController.doPrivileged(new PrivilegedAction<Object>() {\r\n                    @Override\r\n                    public Object run() {\r\n                        try {\r\n                            return Class.forName(\r\n", "                supportsAAAARecords = true;\r\n                supportsARecords = true;\r\n                resolveRecordTypes = IPV6_PREFERRED_RESOLVED_RECORD_TYPES;\r\n                resolvedInternetProtocolFamilies = IPV6_PREFERRED_RESOLVED_PROTOCOL_FAMILIES;\r\n                break;\r\n", "import java.net.InetAddress;\r\nimport java.net.InetSocketAddress;\r\nimport java.net.UnknownHostException;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\n", "    public Future<AddressedEnvelope<DnsResponse, InetSocketAddress>> query(\r\n            InetSocketAddress nameServerAddr, DnsQuestion question,\r\n            Promise<AddressedEnvelope<? extends DnsResponse, InetSocketAddress>> promise) {\r\n\r\n        return query0(nameServerAddr, question, EMPTY_ADDITIONALS, true, ch.newPromise(), promise);\r\n", "package io.netty.handler.codec.memcache;\r\n\r\nimport io.netty.buffer.ByteBuf;\r\nimport io.netty.buffer.Unpooled;\r\nimport io.netty.channel.ChannelHandlerContext;\r\n", "                int toRead = in.readableBytes();\r\n                if (valueLength > 0) {\r\n                    if (toRead == 0) {\r\n                        return;\r\n                    }\r\n", "    @Override\r\n    BinaryMemcacheMessage touch();\r\n\r\n    @Override\r\n    BinaryMemcacheMessage touch(Object hint);\r\n", "\r\n        Future<InetAddress> fut = resolver.resolve(\"unknown.hostname\");\r\n        assertTrue(fut.await(10, TimeUnit.SECONDS));\r\n        assertFalse(fut.isSuccess());\r\n        final Throwable cause = fut.cause();\r\n", "            redirectServer.stop();\r\n        }\r\n    }\r\n\r\n    @Test\r\n", "    public DnsNameResolverBuilder traceEnabled(boolean traceEnabled) {\r\n        this.traceEnabled = traceEnabled;\r\n        return this;\r\n    }\r\n\r\n", "    }\r\n\r\n    @Override\r\n    public FullBinaryMemcacheResponse retainedDuplicate() {\r\n        return replace(content().retainedDuplicate());\r\n", "            }\r\n\r\n            final ByteBuf recordContent = ((ByteBufHolder) r).content();\r\n            final String domainName = decodeDomainName(recordContent);\r\n            if (domainName == null) {\r\n", "        final AtomicReference<DnsServerAddressStream> redirectedRef = new AtomicReference<DnsServerAddressStream>();\r\n        final DnsNameResolver resolver = new DnsNameResolver(\r\n                loop, new ReflectiveChannelFactory<DatagramChannel>(NioDatagramChannel.class),\r\n                cache, authoritativeDnsServerCache,\r\n                NoopDnsQueryLifecycleObserverFactory.INSTANCE, 2000, ResolvedAddressTypes.IPV4_ONLY,\r\n", "    @Override\r\n    void cache(String hostname, DnsRecord[] additionals, UnknownHostException cause) {\r\n        resolveCache.cache(hostname, additionals, cause, parent.ch.eventLoop());\r\n    }\r\n\r\n", "                    }\r\n\r\n                    currentMessage.setKey(in.readRetainedSlice(keyLength));\r\n                }\r\n                out.add(currentMessage.retain());\r\n", "        }\r\n\r\n        private static int index(int arrayLength) {\r\n            return Math.abs(PlatformDependent.threadLocalRandom().nextInt()) % arrayLength;\r\n        }\r\n", "        byte flags = (byte) 0xFF; // undefined flags\r\n        int length = 8;\r\n        int lastGoodStreamId = RANDOM.nextInt() & 0x7FFFFFFF;\r\n        int statusCode = RANDOM.nextInt() | 0x01;\r\n\r\n", "                return (internetProtocolFamilies.length >= 2\r\n                        && internetProtocolFamilies[1] == InternetProtocolFamily.IPv6) ?\r\n                        ResolvedAddressTypes.IPV4_PREFERRED: ResolvedAddressTypes.IPV4_ONLY;\r\n            case IPv6:\r\n                return (internetProtocolFamilies.length >= 2\r\n", "        return unfiltered;\r\n    }\r\n\r\n    @Override\r\n    boolean isCompleteEarly(InetAddress resolved) {\r\n", "                    if (record.getDomainName().equals(expected.getHostName())) {\r\n                        message.getAdditionalRecords().clear();\r\n                        message.getAnswerRecords().clear();\r\n                        if (invalidNsFirst) {\r\n                            message.getAuthorityRecords().add(TestDnsServer.newNsRecord(domain, ns2Name));\r\n", "                true, // recursionDesired\r\n                1, // maxQueriesPerResolve\r\n                false, // traceEnabled\r\n                4096, // maxPayloadSize\r\n                true, // optResourceEnabled\r\n", "                    Collections.<DnsRecord>singleton(\r\n                            // Suggest max payload size of 1024\r\n                            // 157.88.0.0 / 24\r\n                            new DefaultDnsOptEcsRecord(1024, 24,\r\n                                                       SocketUtils.addressByName(\"157.88.0.0\").getAddress())));\r\n", "package io.netty.handler.codec.memcache.binary;\r\n\r\nimport io.netty.buffer.ByteBuf;\r\nimport io.netty.buffer.Unpooled;\r\nimport io.netty.util.internal.ObjectUtil;\r\n", "package io.netty.handler.codec.memcache.binary;\r\n\r\nimport io.netty.buffer.ByteBuf;\r\nimport io.netty.buffer.Unpooled;\r\nimport io.netty.util.internal.ObjectUtil;\r\n", "import java.util.Map;\r\nimport java.util.Set;\r\n\r\nclass TestDnsServer extends DnsServer {\r\n    private static final Map<String, byte[]> BYTES = new HashMap<String, byte[]>();\r\n", "            InetAddress resolved = decodeAddress(r, nsName, parent.isDecodeIdn());\r\n            if (resolved == null) {\r\n                // Could not parse the address, just ignore.\r\n                return;\r\n            }\r\n", "        final int queriesRemaining;\r\n\r\n        QueryCancelledEvent(int queriesRemaining) {\r\n            this.queriesRemaining = queriesRemaining;\r\n        }\r\n", "     * @param chunkSize the maximum chunk size of the payload.\r\n     */\r\n    protected AbstractBinaryMemcacheDecoder(int chunkSize) {\r\n        checkPositiveOrZero(chunkSize, \"chunkSize\");\r\n\r\n", "    @Test\r\n    public void testUnidirectionalSpdySynStreamFrame() throws Exception {\r\n        short type = 1;\r\n        byte flags = 0x02; // FLAG_UNIDIRECTIONAL\r\n        int length = 10;\r\n", "            if (logger.isDebugEnabled()) {\r\n                logger.debug(\"Domain name {} already maps to addresses {} so new addresses {} will be discarded\",\r\n                        domainName, existingAddresses, addresses);\r\n            }\r\n        }\r\n", "            InternalLoggerFactory.getInstance(DefaultDnsServerAddressStreamProvider.class);\r\n    public static final DefaultDnsServerAddressStreamProvider INSTANCE = new DefaultDnsServerAddressStreamProvider();\r\n\r\n    private static final List<InetSocketAddress> DEFAULT_NAME_SERVER_LIST;\r\n    private static final DnsServerAddresses DEFAULT_NAME_SERVERS;\r\n", "package io.netty.handler.codec.memcache.binary;\r\n\r\nimport io.netty.buffer.ByteBuf;\r\nimport io.netty.buffer.Unpooled;\r\nimport io.netty.channel.embedded.EmbeddedChannel;\r\n", "package io.netty.handler.codec.memcache.binary;\r\n\r\nimport io.netty.buffer.ByteBuf;\r\nimport io.netty.buffer.Unpooled;\r\nimport io.netty.channel.embedded.EmbeddedChannel;\r\n", "package io.netty.handler.codec.memcache.binary;\r\n\r\nimport io.netty.buffer.ByteBuf;\r\nimport io.netty.buffer.Unpooled;\r\nimport io.netty.channel.embedded.EmbeddedChannel;\r\n", "package io.netty.handler.codec.memcache.binary;\r\n\r\nimport io.netty.buffer.ByteBuf;\r\nimport io.netty.buffer.Unpooled;\r\nimport io.netty.channel.embedded.EmbeddedChannel;\r\n", "package io.netty.handler.codec.memcache.binary;\r\n\r\nimport io.netty.buffer.ByteBuf;\r\nimport io.netty.buffer.Unpooled;\r\nimport io.netty.channel.embedded.EmbeddedChannel;\r\n", "package io.netty.handler.codec.memcache.binary;\r\n\r\nimport io.netty.buffer.ByteBuf;\r\nimport io.netty.buffer.Unpooled;\r\nimport io.netty.util.internal.UnstableApi;\r\n", "package io.netty.handler.codec.memcache.binary;\r\n\r\nimport io.netty.buffer.ByteBuf;\r\nimport io.netty.buffer.Unpooled;\r\nimport io.netty.util.internal.UnstableApi;\r\n", "    }\r\n\r\n    @Override\r\n    List<InetAddress> filterResults(List<InetAddress> unfiltered) {\r\n        Collections.sort(unfiltered, PreferredAddressTypeComparator.comparator(parent.preferredAddressType()));\r\n", "            negativeLookupThread.join(DEFAULT_TEST_TIMEOUT_MS);\r\n\r\n            if (negativeLookupThread.isAlive()) {\r\n                negativeLookupThread.interrupt();\r\n                fail(\"Cached negative lookups did not finish quickly.\");\r\n", "\r\n    /**\r\n     * If {@code true} {@link DnsNameResolver#resolveAll(String)} will notify the returned {@link Future} as\r\n     * soon as all queries for the preferred address-type are complete.\r\n     *\r\n", " * A implementation of a {@link AbstractMemcacheObjectDecoder} generates {@link MemcacheContent} after\r\n * {@link MemcacheMessage} when the content is large. If you prefer not to receive {@link MemcacheContent}\r\n * in your handler, place a aggregator after an implementation of the {@link AbstractMemcacheObjectDecoder}\r\n * in the {@link ChannelPipeline}.\r\n */\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", " * with the License. You may obtain a copy of the License at:\r\n *\r\n *   https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n", "    public int maxQueriesPerResolve() {\r\n        return maxQueriesPerResolve;\r\n    }\r\n\r\n    /**\r\n", "     *\r\n     * @return the list of the address as the result of the resolution\r\n     */\r\n    public final Future<List<InetAddress>> resolveAll(String inetHost, Iterable<DnsRecord> additionals,\r\n                                                      Promise<List<InetAddress>> promise) {\r\n", "    private void internalResolve(String name, Promise<List<T>> promise) {\r\n        try {\r\n            // Resolve from cnameCache() until there is no more cname entry cached.\r\n            name = cnameResolveFromCache(cnameCache(), name);\r\n        } catch (Throwable cause) {\r\n", "    }\r\n\r\n    @Override\r\n    public MemcacheContent retainedDuplicate() {\r\n        return replace(content.retainedDuplicate());\r\n", "        short type = 7;\r\n        byte flags = 0;\r\n        int length = 8;\r\n        int lastGoodStreamId = RANDOM.nextInt() & 0x7FFFFFFF;\r\n        int statusCode = RANDOM.nextInt() | 0x01;\r\n", "    @Test\r\n    public void testDotHandling() throws Exception {\r\n        InetAddress addr1 = InetAddress.getByAddress(new byte[] { 10, 0, 0, 1 });\r\n        InetAddress addr2 = InetAddress.getByAddress(new byte[] { 10, 0, 0, 2 });\r\n        EventLoopGroup group = new DefaultEventLoopGroup(1);\r\n", "    @Deprecated\r\n    public static DnsServerAddresses defaultAddresses() {\r\n        return DefaultDnsServerAddressStreamProvider.defaultAddresses();\r\n    }\r\n\r\n", "    public BinaryMemcacheMessage setExtras(ByteBuf extras) {\r\n        if (this.extras != null) {\r\n            this.extras.release();\r\n        }\r\n        this.extras = extras;\r\n", "        final String domain = \"netty.io\";\r\n        final String ns1Name = \"ns1.\" + domain;\r\n        final String ns2Name = \"ns2.\" + domain;\r\n\r\n        TestDnsServer testDnsServer = new TestDnsServer(new HashSet<String>(\r\n", "    @Override\r\n    protected ByteBuf encodeMessage(ChannelHandlerContext ctx, M msg) {\r\n        ByteBuf buf = ctx.alloc().buffer(MINIMUM_HEADER_SIZE + msg.extrasLength()\r\n            + msg.keyLength());\r\n\r\n", "    }\r\n\r\n    @Test\r\n    public void testResolveAllNullIpv4() {\r\n        testResolveAll0(ResolvedAddressTypes.IPV4_ONLY, NetUtil.LOCALHOST4, null);\r\n", "    }\r\n\r\n    @Override\r\n    public void querySucceed() {\r\n    }\r\n", "            }\r\n            return (UnknownHostException) e;\r\n        }\r\n    }\r\n\r\n", "    @Override\r\n    public BinaryMemcacheMessage setOpcode(byte opcode) {\r\n        this.opcode = opcode;\r\n        return this;\r\n    }\r\n", "import static org.hamcrest.core.IsNull.notNullValue;\r\nimport static org.hamcrest.core.IsNull.nullValue;\r\nimport static org.junit.Assert.assertTrue;\r\n\r\n/**\r\n", "package io.netty.handler.codec.memcache.binary;\r\n\r\nimport io.netty.buffer.ByteBuf;\r\nimport io.netty.handler.codec.memcache.AbstractMemcacheObject;\r\nimport io.netty.util.internal.UnstableApi;\r\n", "    /**\r\n     * Sets the capacity of the datagram packet buffer (in bytes).  The default value is {@code 4096} bytes.\r\n     *\r\n     * @param maxPayloadSize the capacity of the datagram packet buffer\r\n     * @return {@code this}\r\n", "            return Collections.emptyList();\r\n        }\r\n        List<String> list = new ArrayList<String>();\r\n        ByteBuf data = ((DnsRawRecord) record).content();\r\n        int idx = data.readerIndex();\r\n", "     */\r\n    public LoggingDnsQueryLifeCycleObserverFactory() {\r\n        this(LogLevel.DEBUG);\r\n    }\r\n\r\n", "package io.netty.handler.codec.memcache;\r\n\r\nimport io.netty.util.ReferenceCounted;\r\nimport io.netty.util.internal.UnstableApi;\r\n\r\n", "     * each hostname.\r\n     * @return {@code this}.\r\n     */\r\n    public DnsNameResolverBuilder nameServerProvider(DnsServerAddressStreamProvider dnsServerAddressStreamProvider) {\r\n        this.dnsServerAddressStreamProvider =\r\n", "    UniSequentialDnsServerAddressStreamProvider(DnsServerAddresses addresses) {\r\n        this.addresses = ObjectUtil.checkNotNull(addresses, \"addresses\");\r\n    }\r\n\r\n    @Override\r\n", "    private final InternalLogger logger;\r\n    private final InternalLogLevel level;\r\n\r\n    /**\r\n     * Create {@link DnsQueryLifecycleObserver} instances that log events at the default {@link LogLevel#DEBUG} level.\r\n", "\r\n    @Test\r\n    public void testLastSpdyDataFrame() throws Exception {\r\n        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;\r\n        byte flags = 0x01; // FLAG_FIN\r\n", "            throw new UnsupportedOperationException();\r\n        }\r\n\r\n        @Override\r\n        public boolean isCancelled() {\r\n", "    }\r\n\r\n    @Test\r\n    public void testSearchDomainQueryFailureForMultipleAddressTypeCompletes() {\r\n        expectedException.expect(UnknownHostException.class);\r\n", "    public void testDnsNameResolverBuilderCopy() {\r\n        ChannelFactory<DatagramChannel> channelFactory =\r\n                new ReflectiveChannelFactory<DatagramChannel>(NioDatagramChannel.class);\r\n        DnsNameResolverBuilder builder = new DnsNameResolverBuilder(group.next())\r\n                .channelFactory(channelFactory);\r\n", "        int streamId = 0; // invalid stream identifier\r\n        int statusCode = RANDOM.nextInt() | 0x01;\r\n\r\n        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeControlFrameHeader(buf, type, flags, length);\r\n", "     */\r\n    @Test\r\n    public void shouldHandleNonUniformNetworkBatches() {\r\n        ByteBuf incoming = Unpooled.copiedBuffer(SET_REQUEST_WITH_CONTENT);\r\n        while (incoming.isReadable()) {\r\n", "     * the default DNS server to use, and also overrides for individual domains. Also parse list of files of the format\r\n     * <a href=\"\r\n     * https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man5/resolver.5.html\">\r\n     * /etc/resolver</a> which may contain multiple files to override the name servers used for multiple domains.\r\n     * @param etcResolvConf <a href=\"https://linux.die.net/man/5/resolver\">/etc/resolv.conf</a>.\r\n", "                    .maxQueriesPerResolve(16)\r\n                    .nameServerProvider(new DnsServerAddressStreamProvider() {\r\n                        private final DnsServerAddresses addresses =\r\n                                DnsServerAddresses.rotational(dnsServer2.localAddress(), dnsServer3.localAddress());\r\n                        @Override\r\n", "        this.recursionDesired = recursionDesired;\r\n        this.maxQueriesPerResolve = maxQueriesPerResolve > 0 ? maxQueriesPerResolve : DEFAULT_OPTIONS.attempts();\r\n        this.maxPayloadSize = checkPositive(maxPayloadSize, \"maxPayloadSize\");\r\n        this.optResourceEnabled = optResourceEnabled;\r\n        this.hostsFileEntriesResolver = checkNotNull(hostsFileEntriesResolver, \"hostsFileEntriesResolver\");\r\n", "        testMultipleAdditionalRecordsForSameNSRecord(true);\r\n    }\r\n\r\n    private static void testMultipleAdditionalRecordsForSameNSRecord(final boolean reversed) throws Exception {\r\n        final String domain = \"netty.io\";\r\n", "    private int i;\r\n\r\n    SequentialDnsServerAddressStream(List<? extends InetSocketAddress> addresses, int startIdx) {\r\n        this.addresses = addresses;\r\n        i = startIdx;\r\n", "            assertEquals(\"cname.netty.io.\", cache.get(\"x.netty.io.\"));\r\n            assertEquals(1, cnameQueries.get());\r\n            assertEquals(1, aQueries.get());\r\n\r\n            resolvedAddresses =\r\n", "    public void teardown() throws Exception {\r\n        assertFalse(channel.finish());\r\n    }\r\n\r\n    @Test\r\n", "    }\r\n\r\n    @Test\r\n    public void testCompareUnresolvedOnly() {\r\n        NameServerComparator comparator = new NameServerComparator(Inet4Address.class);\r\n", "    // need it.\r\n    private static final class DefaultProviderHolder {\r\n        // We use 5 minutes which is the same as what OpenJDK is using in sun.net.dns.ResolverConfigurationImpl.\r\n        private static final long REFRESH_INTERVAL = TimeUnit.MINUTES.toNanos(5);\r\n\r\n", "\r\npublic class DefaultDnsCacheTest {\r\n\r\n    @Test\r\n    public void testExpire() throws Throwable {\r\n", "            throw new IllegalArgumentException(\"No more than 2 InternetProtocolFamilies\");\r\n        }\r\n\r\n        switch(internetProtocolFamilies[0]) {\r\n            case IPv4:\r\n", "    }\r\n\r\n    @Test\r\n    public void testCompareResolvedOnly() {\r\n        NameServerComparator comparator = new NameServerComparator(Inet4Address.class);\r\n", "            InetSocketAddress remoteAddress, DnsQuestion question, String message, Throwable cause) {\r\n        super(message, cause);\r\n        this.remoteAddress = validateRemoteAddress(remoteAddress);\r\n        this.question = validateQuestion(question);\r\n    }\r\n", "        } else {\r\n            parent.channelFuture.addListener(new GenericFutureListener<Future<? super Channel>>() {\r\n                @Override\r\n                public void operationComplete(Future<? super Channel> future) {\r\n                    if (future.isSuccess()) {\r\n", "            this.resolvedAddresses = resolvedAddresses;\r\n            this.originalStream = originalStream;\r\n            resolved = resolvedAddresses.iterator();\r\n        }\r\n\r\n", "    public RoundRobinDnsAddressResolverGroup(\r\n            Class<? extends DatagramChannel> channelType,\r\n            DnsServerAddressStreamProvider nameServerProvider) {\r\n        super(channelType, nameServerProvider);\r\n    }\r\n", "\r\n    /**\r\n     * Create a new {@link DefaultFullBinaryMemcacheResponse} with the header, key and extras.\r\n     *\r\n     * @param key    the key to use.\r\n", "import java.net.UnknownHostException;\r\n\r\nimport static org.junit.Assert.fail;\r\n\r\npublic class DnsResolveContextTest {\r\n", "    /**\r\n     * Create a new {@link DefaultBinaryMemcacheRequest} with the header and key.\r\n     *\r\n     * @param key    the key to use.\r\n     */\r\n", "\r\n    public InetSocketAddress localAddress() {\r\n        return (InetSocketAddress) getTransports()[0].getAcceptor().getLocalAddress();\r\n    }\r\n\r\n", "        // First message\r\n        BinaryMemcacheResponse response = channel.readInbound();\r\n        assertThat(response.status(), is(BinaryMemcacheResponseStatus.KEY_ENOENT));\r\n        assertThat(response.totalBodyLength(), is(msgBody.length()));\r\n        response.release();\r\n", "    @Test\r\n    public void testResolveEmptyIpv4() {\r\n        testResolve0(ResolvedAddressTypes.IPV4_ONLY, NetUtil.LOCALHOST4, StringUtil.EMPTY_STRING);\r\n    }\r\n\r\n", "    }\r\n\r\n    @Test\r\n    public void testReservedSpdyWindowUpdateFrameBits() throws Exception {\r\n        short type = 9;\r\n", "        int streamId = RANDOM.nextInt() & 0x7FFFFFFF;\r\n        int deltaWindowSize = 0; // invalid delta window size\r\n\r\n        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeControlFrameHeader(buf, type, flags, length);\r\n", "    }\r\n\r\n    @Override\r\n    public DnsServerAddressStream nameServerAddressStream(String hostname) {\r\n        for (DnsServerAddressStreamProvider provider : providers) {\r\n", "        assert nameServerName != null;\r\n\r\n        // Placeholder so we will not try to finish the original query yet.\r\n        final Future<AddressedEnvelope<DnsResponse, InetSocketAddress>> resolveFuture = parent.executor()\r\n                .newSucceededFuture(null);\r\n", "     * {@link DnsQueryContext}.\r\n     */\r\n    final Map<InetSocketAddress, IntObjectMap<DnsQueryContext>> map =\r\n            new HashMap<InetSocketAddress, IntObjectMap<DnsQueryContext>>();\r\n\r\n", "    @Override\r\n    public void queryCancelled(int queriesRemaining) {\r\n        if (dnsServerAddress != null) {\r\n            logger.log(level, \"from {} : {} cancelled with {} queries remaining\", dnsServerAddress, question,\r\n                        queriesRemaining);\r\n", "        return this;\r\n    }\r\n\r\n    @Override\r\n    public FullBinaryMemcacheRequest touch(Object hint) {\r\n", "        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeControlFrameHeader(buf, type, flags, length);\r\n        buf.writeInt(numSettings);\r\n\r\n        decoder.decode(buf);\r\n", "            }\r\n            list.add(a);\r\n        }\r\n\r\n        if (list.isEmpty()) {\r\n", "            this.defaultNameServerAddresses = defaultNameServerAddresses;\r\n        }\r\n\r\n        if (useEtcResolverFiles) {\r\n            domainToNameServerStreamMap.putAll(etcResolvConfMap);\r\n", "        if (msg instanceof FileRegion) {\r\n            return (int) ((FileRegion) msg).count();\r\n        }\r\n        throw new IllegalStateException(\"unexpected message type: \" + StringUtil.simpleClassName(msg));\r\n    }\r\n", "            @Override\r\n            public Set<ResourceRecord> getRecords(QuestionRecord question) {\r\n                ResourceRecordModifier rm = new ResourceRecordModifier();\r\n                rm.setDnsClass(RecordClass.IN);\r\n                rm.setDnsName(question.getDomainName());\r\n", "        case IPV6_PREFERRED:\r\n            return InternetProtocolFamily.IPv6;\r\n        default:\r\n            throw new IllegalArgumentException(\"Unknown ResolvedAddressTypes \" + resolvedAddressTypes);\r\n        }\r\n", "     * @param channelType the type or {@code null} if <a href=\"https://tools.ietf.org/html/rfc7766\">TCP fallback</a>\r\n     *                    should not be supported.\r\n     * @return {@code this}\r\n     */\r\n    public DnsNameResolverBuilder socketChannelType(Class<? extends SocketChannel> channelType) {\r\n", "\r\n    @Test\r\n    public void shouldEncodeExtras() {\r\n        String extrasContent = \"netty<3memcache\";\r\n        ByteBuf extras = Unpooled.copiedBuffer(extrasContent, CharsetUtil.UTF_8);\r\n", "        this.dnsClass = dnsClass;\r\n        this.expectedTypes = expectedTypes;\r\n        this.additionals = additionals;\r\n\r\n        this.nameServerAddrs = ObjectUtil.checkNotNull(nameServerAddrs, \"nameServerAddrs\");\r\n", "        EventLoop loop = dnsResolverBuilder.eventLoop;\r\n        return newResolver(loop == null ? (EventLoop) executor : loop,\r\n                dnsResolverBuilder.channelFactory(),\r\n                dnsResolverBuilder.nameServerProvider());\r\n    }\r\n", "            @Override\r\n            protected DnsServerAddressStream newRedirectDnsServerStream(\r\n                    String hostname, List<InetSocketAddress> nameservers) {\r\n                DnsServerAddressStream stream = new SequentialDnsServerAddressStream(nameservers, 0);\r\n                redirectedRef.set(stream);\r\n", "\r\n        for (Entry<String, Future<InetAddress>> e : futures.entrySet()) {\r\n            String unresolved = e.getKey();\r\n            InetAddress resolved = e.getValue().sync().getNow();\r\n\r\n", "        final String secondName = \"secondname.com\";\r\n        final String lastName = \"lastname.com\";\r\n        final String ipv4Addr = \"1.2.3.4\";\r\n        final String ipv6Addr = \"::1\";\r\n        TestDnsServer dnsServer2 = new TestDnsServer(new RecordStore() {\r\n", "                    }\r\n                    // We should replace the TTL if needed with the one of the ADDITIONAL record so we use\r\n                    // the smallest for caching.\r\n                    serverName.update(parent.newRedirectServerAddress(resolved), r.timeToLive());\r\n\r\n", "            String name = r.name().toLowerCase(Locale.US);\r\n            String mapping = domainName.toLowerCase(Locale.US);\r\n\r\n            // Cache the CNAME as well.\r\n            String nameWithDot = hostnameWithDot(name);\r\n", "        // Only try when using Java8 and lower as otherwise it will produce:\r\n        // WARNING: Illegal reflective access by io.netty.resolver.dns.DefaultDnsServerAddressStreamProvider\r\n        if (PlatformDependent.javaVersion() < 9 && defaultNameServers.isEmpty()) {\r\n            try {\r\n                Class<?> configClass = Class.forName(\"sun.net.dns.ResolverConfiguration\");\r\n", "\r\n    @Test\r\n    public void testInvalidSpdyWindowUpdateFrameLength() throws Exception {\r\n        short type = 9;\r\n        byte flags = 0;\r\n", "        assertFalse(headerBlock.isReadable());\r\n        assertFalse(frame.isInvalid());\r\n        assertEquals(0, frame.headers().names().size());\r\n        headerBlock.release();\r\n    }\r\n", "            internalResolve(hostname, promise);\r\n        } else {\r\n            final boolean startWithoutSearchDomain = hasNDots();\r\n            final String initialHostname = startWithoutSearchDomain ? hostname : hostname + '.' + searchDomains[0];\r\n            final int initialSearchDomainIdx = startWithoutSearchDomain ? 0 : 1;\r\n", "\r\n    private static final class QueryFailedEvent {\r\n        final Throwable cause;\r\n\r\n        QueryFailedEvent(Throwable cause) {\r\n", "                return false;\r\n            }\r\n\r\n            @Override\r\n            public List<? extends DnsCacheEntry> get(String hostname, DnsRecord[] additionals) {\r\n", "        }\r\n    }\r\n\r\n    private static List<String> decodeTxt(DnsRecord record) {\r\n        if (!(record instanceof DnsRawRecord)) {\r\n", "        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;\r\n        int associatedToStreamId = RANDOM.nextInt() & 0x7FFFFFFF;\r\n        byte priority = (byte) (RANDOM.nextInt() & 0x07);\r\n\r\n        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n", "        return resolveCache.get(appendDot(hostname));\r\n    }\r\n\r\n    @Override\r\n    public DnsCacheEntry cache(String hostname, DnsRecord[] additionals,\r\n", "        assertFalse(headerBlock.isReadable());\r\n        assertTrue(frame.isInvalid());\r\n        assertEquals(0, frame.headers().names().size());\r\n        headerBlock.release();\r\n    }\r\n", "        assertFalse(headerBlock.isReadable());\r\n        assertTrue(frame.isInvalid());\r\n        assertEquals(0, frame.headers().names().size());\r\n        headerBlock.release();\r\n    }\r\n", "                            newDnsQueryLifecycleObserver(question), true, promise, null);\r\n                }\r\n            }\r\n        } finally {\r\n            ReferenceCountUtil.safeRelease(envelope);\r\n", "    }\r\n\r\n    /**\r\n     * Create a new {@link BinaryMemcacheClientCodec} and set a custom chunk size.\r\n     *\r\n", "    }\r\n\r\n    @Override\r\n    protected FullMemcacheMessage beginAggregation(BinaryMemcacheMessage start, ByteBuf content) throws Exception {\r\n        if (start instanceof BinaryMemcacheRequest) {\r\n", "             maxQueriesPerResolve, traceEnabled, maxPayloadSize, optResourceEnabled, hostsFileEntriesResolver,\r\n             dnsServerAddressStreamProvider, searchDomains, ndots, decodeIdn, false);\r\n    }\r\n\r\n    DnsNameResolver(\r\n", "        // \"host4.sub\" contains a dot but not resolved then resolved to \"host4.sub.foo.com\" with \"foo.com\" search domain\r\n        resolved = assertResolve(resolver, \"host4.sub\");\r\n        assertEquals(store.getAddress(\"host4.sub.foo.com\"), resolved);\r\n\r\n        // \"host5.sub\" would have been directly resolved but since it has less than ndots the \"foo.com\" search domain\r\n", "    }\r\n\r\n    @Test\r\n    public void nameServerAddressStreamShouldAlwaysStartFromTheTopWhenRotationOptionsIsAbsent() throws Exception {\r\n        File f = buildFile(\"domain linecorp.local\\n\" +\r\n", "     * Create a new {@link DefaultBinaryMemcacheResponse} with the header, key and extras.\r\n     *\r\n     * @param key    the key to use.\r\n     * @param extras the extras to use.\r\n     */\r\n", "        }\r\n\r\n        @Override\r\n        public Iterator<InetSocketAddress> iterator() {\r\n            return new Iterator<InetSocketAddress>() {\r\n", "\r\n        // \"host3.\" does not contain a dot but is absolute\r\n        resolved = assertResolveAll(resolver, \"host3.\");\r\n        assertEquals(store.getAddresses(\"host3\"), resolved);\r\n\r\n", "            DnsQueryLifecycleObserverFactory dnsQueryLifecycleObserverFactory,\r\n            long queryTimeoutMillis,\r\n            ResolvedAddressTypes resolvedAddressTypes,\r\n            boolean recursionDesired,\r\n            int maxQueriesPerResolve,\r\n", "                Object o = observer.events.poll();\r\n                if (o instanceof QueryCancelledEvent) {\r\n                    assertTrue(\"unexpected type: \" + observer.question,\r\n                            observer.question.type() == CNAME || observer.question.type() == AAAA);\r\n                } else if (o instanceof QueryWrittenEvent) {\r\n", "\r\n        // \"host3.\" does not contain a dot but is absolute\r\n        resolved = assertResolve(resolver, \"host3.\");\r\n        assertEquals(store.getAddress(\"host3\"), resolved);\r\n\r\n", "package io.netty.handler.codec.memcache.binary;\r\n\r\nimport io.netty.util.internal.UnstableApi;\r\n\r\n/**\r\n", "package io.netty.handler.codec.memcache.binary;\r\n\r\nimport io.netty.util.internal.UnstableApi;\r\n\r\n/**\r\n", "package io.netty.handler.codec.memcache.binary;\r\n\r\nimport io.netty.util.internal.UnstableApi;\r\n\r\n/**\r\n", "package io.netty.handler.codec.memcache.binary;\r\n\r\nimport io.netty.util.internal.UnstableApi;\r\n\r\n/**\r\n", "        ByteBuf extras = Unpooled.wrappedBuffer(\"extras\".getBytes(CharsetUtil.UTF_8));\r\n        FullBinaryMemcacheResponse resp = new DefaultFullBinaryMemcacheResponse(key, extras, content);\r\n        assertTrue(channel.writeOutbound(resp));\r\n        // header + content\r\n        assertEquals(2, channel.outboundMessages().size());\r\n", "    private static final class QueryCnamedEvent {\r\n        final DnsQuestion question;\r\n\r\n        QueryCnamedEvent(DnsQuestion question) {\r\n            this.question = question;\r\n", "    }\r\n\r\n    // Only here to override in unit tests.\r\n    InetSocketAddress newRedirectServerAddress(InetAddress server) {\r\n        return new InetSocketAddress(server, DNS_PORT);\r\n", "        TestDnsServer redirectServer = new TestDnsServer(new HashSet<String>(\r\n                Arrays.asList(expected.getHostName(), ns1Name, ns2Name))) {\r\n            @Override\r\n            protected DnsMessage filterMessage(DnsMessage message) {\r\n                for (QuestionRecord record: message.getQuestionRecords()) {\r\n", "        request.setExtrasLength((byte) 34);\r\n        request.setDataType((byte) 43);\r\n        request.setTotalBodyLength(345);\r\n        request.setOpaque(3);\r\n        request.setCas(345345L);\r\n", "\r\n    private static DnsNameResolverBuilder newResolver(boolean decodeToUnicode,\r\n                                                      DnsServerAddressStreamProvider dnsServerAddressStreamProvider) {\r\n        DnsNameResolverBuilder builder = new DnsNameResolverBuilder(group.next())\r\n                .dnsQueryLifecycleObserverFactory(new TestRecursiveCacheDnsQueryLifecycleObserverFactory())\r\n", "        InetSocketAddress resolved2 = new InetSocketAddress(\r\n                InetAddress.getByAddress(\"ns2\", new byte[] { 10, 0, 0, 2 }), 53);\r\n        EventLoopGroup group = new DefaultEventLoopGroup(1);\r\n\r\n        try {\r\n", "     * @param extras  the extras to use.\r\n     * @param content the content of the full request.\r\n     */\r\n    public DefaultFullBinaryMemcacheRequest(ByteBuf key, ByteBuf extras,\r\n                                            ByteBuf content) {\r\n", "    public Future<AddressedEnvelope<DnsResponse, InetSocketAddress>> query(\r\n            DnsQuestion question, Iterable<DnsRecord> additionals) {\r\n        return query(nextNameServerAddress(), question, additionals);\r\n    }\r\n\r\n", "    public void testNotIncludeDuplicates() throws IOException {\r\n        final String name = \"netty.io\";\r\n        final String ipv4Addr = \"1.2.3.4\";\r\n        TestDnsServer dnsServer2 = new TestDnsServer(new RecordStore() {\r\n            @Override\r\n", "     */\r\n    public DefaultBinaryMemcacheRequest() {\r\n        this(null, null);\r\n    }\r\n\r\n", "     * Returns the capacity of the datagram packet buffer (in bytes).  The default value is {@code 4096} bytes.\r\n     */\r\n    public int maxPayloadSize() {\r\n        return maxPayloadSize;\r\n    }\r\n", "                if (completeEarly) {\r\n                    this.completeEarly = true;\r\n                }\r\n                queryLifecycleObserver.querySucceed();\r\n                return;\r\n", "        testMultipleAdditionalRecordsForSameNSRecord(false);\r\n    }\r\n\r\n    @Test\r\n    public void testMultipleAdditionalRecordsForSameNSRecordReordered() throws Exception {\r\n", "                        return null;\r\n                    } catch (Throwable cause) {\r\n                        return cause;\r\n                    }\r\n                }\r\n", "    @Test\r\n    public void ignoreComments() throws Exception {\r\n        File f = buildFile(\"domain linecorp.local\\n\" +\r\n                \"nameserver 127.0.0.2 #somecomment\\n\");\r\n        UnixResolverDnsServerAddressStreamProvider p =\r\n", "            assertEquals(Collections.singletonList(InetAddress.getByAddress(name, new byte[] { 1, 2, 3, 4 })),\r\n                    resolvedAddresses);\r\n        } finally {\r\n            dnsServer2.stop();\r\n            if (resolver != null) {\r\n", "    private final DnsRecord optResource;\r\n    private final InetSocketAddress nameServerAddr;\r\n\r\n    private final boolean recursionDesired;\r\n    private volatile ScheduledFuture<?> timeoutFuture;\r\n", "     * implementation or override the default configuration.\r\n     */\r\n    protected NameResolver<InetAddress> newNameResolver(EventLoop eventLoop,\r\n                                                        ChannelFactory<? extends DatagramChannel> channelFactory,\r\n                                                        DnsServerAddressStreamProvider nameServerProvider)\r\n", "    private static DnsNameResolverBuilder newNonCachedResolver(ResolvedAddressTypes resolvedAddressTypes) {\r\n        return newResolver()\r\n                .resolveCache(NoopDnsCache.INSTANCE)\r\n                .resolvedAddressTypes(resolvedAddressTypes);\r\n    }\r\n", "    // Ignore as this needs to query real DNS servers.\r\n    @Ignore\r\n    @Test\r\n    public void testSubnetQuery() throws Exception {\r\n        EventLoopGroup group = new NioEventLoopGroup(1);\r\n", "\r\n    @Test\r\n    public void testUseCorrectProvider() {\r\n        Assert.assertSame(DnsServerAddressStreamProviders.unixDefault(),\r\n                DnsServerAddressStreamProviders.platformDefault());\r\n", "        } catch (SocketException e) {\r\n            logger.debug(\"Unable to detect if any interface supports IPv6, assuming IPv4-only\", e);\r\n            // ignore\r\n        }\r\n        return false;\r\n", "            };\r\n            InetAddress resolvedAddress = resolver.resolve(firstName).syncUninterruptibly().getNow();\r\n            if (ipv4Preferred) {\r\n                assertEquals(ipv4Addr, resolvedAddress.getHostAddress());\r\n            } else {\r\n", "            for (InetAddress address: future.syncUninterruptibly().getNow()) {\r\n                System.err.println(address);\r\n            }\r\n        } finally {\r\n            resolver.close();\r\n", "    @Override\r\n    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\r\n        this.dnsServerAddress = dnsServerAddress;\r\n    }\r\n\r\n", "     * @param channelFactory the {@link ChannelFactory} that will create a {@link DatagramChannel}\r\n     * @param resolveCache the DNS resolved entries cache\r\n     * @param authoritativeDnsServerCache the cache used to find the authoritative DNS server for a domain\r\n     * @param dnsQueryLifecycleObserverFactory used to generate new instances of {@link DnsQueryLifecycleObserver} which\r\n     *                                         can be used to track metrics for DNS servers.\r\n", "        int wIdx = data.writerIndex();\r\n        while (idx < wIdx) {\r\n            int len = data.getUnsignedByte(idx++);\r\n            list.add(data.toString(idx, len, CharsetUtil.UTF_8));\r\n            idx += len;\r\n", "\r\n    static {\r\n        String[] searchDomains;\r\n        try {\r\n            List<String> list = PlatformDependent.isWindows()\r\n", "            FileReader fr = new FileReader(etcResolverFile);\r\n            BufferedReader br = null;\r\n            try {\r\n                br = new BufferedReader(fr);\r\n                List<InetSocketAddress> addresses = new ArrayList<InetSocketAddress>(2);\r\n", "                assertNull(nsCache.cache.get(\"io.\"));\r\n                assertNull(nsCache.cache.get(\"netty.io.\"));\r\n                DnsServerAddressStream entries = nsCache.cache.get(\"record.netty.io.\");\r\n\r\n                // First address should be resolved (as we received a matching additional record), second is unresolved.\r\n", "                    if (overriddenHostnames.contains(resolvedEntry.getKey())) {\r\n                        assertEquals(\"failed to resolve \" + resolvedEntry.getKey(),\r\n                                overriddenIP, resolvedEntry.getValue().getHostAddress());\r\n                    } else {\r\n                        assertNotEquals(\"failed to resolve \" + resolvedEntry.getKey(),\r\n", "package io.netty.handler.codec.memcache;\r\n\r\nimport io.netty.handler.codec.ByteToMessageDecoder;\r\nimport io.netty.util.internal.UnstableApi;\r\n\r\n", "        }\r\n\r\n        private void scheduleCacheExpirationIfNeeded(int ttl, EventLoop loop) {\r\n            for (;;) {\r\n                // We currently don't calculate a new TTL when we need to retry the CAS as we don't expect this to\r\n", "     * @param address the resolved address\r\n     * @param originalTtl the TLL as returned by the DNS server\r\n     * @param loop the {@link EventLoop} used to register the TTL timeout\r\n     * @return The {@link DnsCacheEntry} corresponding to this cache entry.\r\n     */\r\n", "    private final Comparator<InetSocketAddress> comparator;\r\n    private final Cache<InetSocketAddress> resolveCache = new Cache<InetSocketAddress>() {\r\n        @Override\r\n        protected boolean shouldReplaceAll(InetSocketAddress entry) {\r\n            return false;\r\n", "\r\n    private static void assertNoQueriesMade(DnsNameResolver resolver) {\r\n        TestRecursiveCacheDnsQueryLifecycleObserverFactory lifecycleObserverFactory =\r\n                (TestRecursiveCacheDnsQueryLifecycleObserverFactory) resolver.dnsQueryLifecycleObserverFactory();\r\n        assertTrue(lifecycleObserverFactory.observers.isEmpty());\r\n", "    }\r\n\r\n    /**\r\n     * Parse <a href=\"https://linux.die.net/man/5/resolver\">/etc/resolv.conf</a> and return options of interest, namely:\r\n     * timeout, attempts and ndots.\r\n", "            AddressResolver<?> resolver = resolverGroup.getResolver(defaultEventLoopGroup.next());\r\n            resolver.resolve(new SocketAddress() {\r\n                private static final long serialVersionUID = 3169703458729818468L;\r\n            }).addListener(new FutureListener<Object>() {\r\n                @Override\r\n", "    public void testShuffled() {\r\n        DnsServerAddresses seq = DnsServerAddresses.shuffled(ADDR1, ADDR2, ADDR3);\r\n\r\n        // Ensure that all three addresses are returned by the iterator.\r\n        // In theory, this test can fail at extremely low chance, but we don't really care.\r\n", "            \"google.co.id\",\r\n            \"github.com\",\r\n            \"stackoverflow.com\",\r\n            \"pinterest.com\",\r\n            \"amazon.de\",\r\n", "        assertThat(written.readableBytes(), is(DEFAULT_HEADER_SIZE));\r\n        assertThat(written.readByte(), is((byte) 0xAA));\r\n        assertThat(written.readByte(), is(BinaryMemcacheOpcodes.GET));\r\n        written.release();\r\n    }\r\n", "        request.release();\r\n        assertThat(channel.readInbound(), instanceOf(LastMemcacheContent.class));\r\n    }\r\n\r\n    /**\r\n", "                    List<? extends DnsCacheEntry> entries = cache.get(serverName.nsName, null);\r\n                    if (entries != null && !entries.isEmpty()) {\r\n                        InetAddress address = entries.get(0).address();\r\n\r\n                        // If address is null we have a resolution failure cached so just use an unresolved address.\r\n", "                cache, authoritativeDnsServerCache, NoopDnsQueryLifecycleObserverFactory.INSTANCE, 2000,\r\n                ResolvedAddressTypes.IPV4_ONLY, true, 10, true, 4096,\r\n                false, HostsFileEntriesResolver.DEFAULT,\r\n                new SingletonDnsServerAddressStreamProvider(redirectServer.localAddress()),\r\n                DnsNameResolver.DEFAULT_SEARCH_DOMAINS, 0, true) {\r\n", "    private static void testUseComparator0(boolean noComparator) throws Exception {\r\n        InetSocketAddress unresolved = InetSocketAddress.createUnresolved(\"ns1\", 53);\r\n        InetSocketAddress resolved = new InetSocketAddress(\r\n                InetAddress.getByAddress(\"ns2\", new byte[] { 10, 0, 0, 2 }), 53);\r\n        EventLoopGroup group = new DefaultEventLoopGroup(1);\r\n", "    }\r\n\r\n    @Test\r\n    public void testNSRecordsFromCache() throws Exception {\r\n        final String domain = \"netty.io\";\r\n", "    /**\r\n     * Creates a new builder.\r\n     *\r\n     * @param eventLoop the {@link EventLoop} which will perform the communication with the DNS\r\n     * servers.\r\n", "import java.util.Collections;\r\nimport java.util.HashMap;\r\nimport java.util.LinkedHashSet;\r\nimport java.util.List;\r\nimport java.util.Locale;\r\n", "    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return strVal;\r\n", "            if (i < 0 || i == hostname.length() - 1) {\r\n                return defaultNameServerAddresses.stream();\r\n            }\r\n\r\n            DnsServerAddresses addresses = domainToNameServerStreamMap.get(hostname);\r\n", "     * @return the list of the {@link DnsRecord}s as the result of the resolution\r\n     */\r\n    public final Future<List<DnsRecord>> resolveAll(DnsQuestion question, Iterable<DnsRecord> additionals) {\r\n        return resolveAll(question, additionals, executor().<List<DnsRecord>>newPromise());\r\n    }\r\n", "package io.netty.handler.codec.memcache.binary;\r\n\r\nimport io.netty.buffer.ByteBuf;\r\nimport io.netty.util.internal.UnstableApi;\r\n\r\n", "package io.netty.handler.codec.memcache.binary;\r\n\r\nimport io.netty.buffer.ByteBuf;\r\nimport io.netty.util.internal.UnstableApi;\r\n\r\n", "package io.netty.handler.codec.memcache.binary;\r\n\r\nimport io.netty.buffer.ByteBuf;\r\nimport io.netty.util.internal.UnstableApi;\r\n\r\n", "package io.netty.handler.codec.memcache.binary;\r\n\r\nimport io.netty.buffer.ByteBuf;\r\nimport io.netty.util.internal.UnstableApi;\r\n\r\n", "    private void shuffle() {\r\n        Collections.shuffle(addresses, PlatformDependent.threadLocalRandom());\r\n    }\r\n\r\n    @Override\r\n", "        FullBinaryMemcacheRequest newInstance = request.duplicate();\r\n        try {\r\n            assertCopy(request, request.content(), newInstance);\r\n        } finally {\r\n            request.release();\r\n", "    }\r\n\r\n    @Override\r\n    protected boolean isStartMessage(MemcacheObject msg) throws Exception {\r\n        return msg instanceof BinaryMemcacheMessage;\r\n", "     * @param hostname the hostname.\r\n     * @param nameservers The addresses of the DNS servers which are used in the event of a redirect. This may\r\n     *                    contain resolved and unresolved addresses so the used {@link DnsServerAddressStream} must\r\n     *                    allow unresolved addresses if you want to include these as well.\r\n     * @return A {@link DnsServerAddressStream} which will be used to follow the DNS redirect or {@code null} if\r\n", "        secondDnsServerShouldBeUsedBeforeCNAME(true);\r\n    }\r\n\r\n    private static void secondDnsServerShouldBeUsedBeforeCNAME(boolean startDnsServer1) throws IOException {\r\n        final String knownHostName = \"netty.io\";\r\n", "    }\r\n\r\n    @Test\r\n    public void testInvalidSpdyRstStreamFrameFlags() throws Exception {\r\n        short type = 3;\r\n", "        buf.release();\r\n    }\r\n\r\n    @Test\r\n    public void testSpdySettingsFrameClearFlag() throws Exception {\r\n", "\r\n    SingletonDnsServerAddresses(InetSocketAddress address) {\r\n        this.address = address;\r\n    }\r\n\r\n", "                hashCode = hashCode * 31 + recipient().hashCode();\r\n            }\r\n            return hashCode;\r\n        }\r\n    }\r\n", "            assertTrue(txts.contains(txt2));\r\n            envelope.release();\r\n        } finally {\r\n            resolver.close();\r\n            server.stop();\r\n", "                Method open = configClass.getMethod(\"open\");\r\n                Method nameservers = configClass.getMethod(\"nameservers\");\r\n                Object instance = open.invoke(null);\r\n\r\n                @SuppressWarnings(\"unchecked\")\r\n", "\r\n    private static final class QueryWrittenEvent {\r\n        final InetSocketAddress dnsServerAddress;\r\n\r\n        QueryWrittenEvent(InetSocketAddress dnsServerAddress) {\r\n", "    }\r\n\r\n    @Override\r\n    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\r\n        logger.log(level, \"from {} : {} CNAME question {}\", dnsServerAddress, question, cnameQuestion);\r\n", "     * Create {@link DnsQueryLifecycleObserver} instances that log events to a logger with the given class context,\r\n     * at the given log level.\r\n     * @param classContext The class context for the logger to use.\r\n     * @param level The log level to use for logging resolver events.\r\n     */\r\n", "\r\n        // We often get a bunch of CNAMES as well when we asked for A/AAAA.\r\n        final DnsResponse response = envelope.content();\r\n        final Map<String, String> cnames = buildAliasMap(response, cnameCache(), parent.executor());\r\n        final int answerCount = response.count(DnsSection.ANSWER);\r\n", "            }\r\n            queryLifecycleObserver.queryFailed(NO_MATCHING_RECORD_QUERY_FAILED_EXCEPTION);\r\n        } else {\r\n            queryLifecycleObserver.querySucceed();\r\n            // We also got a CNAME so we need to ensure we also query it.\r\n", "    }\r\n\r\n    @Override\r\n    public FullBinaryMemcacheRequest retainedDuplicate() {\r\n        return replace(content().retainedDuplicate());\r\n", "                           \"search squarecorp.local\\n\" +\r\n                           \"nameserver 127.0.0.2\\n\");\r\n        List<String> domains = UnixResolverDnsServerAddressStreamProvider.parseEtcResolverSearchDomains(f);\r\n        assertEquals(Collections.singletonList(\"squarecorp.local\"), domains);\r\n    }\r\n", "        return modifier;\r\n    }\r\n\r\n    private static void testTruncated0(boolean tcpFallback, final boolean truncatedBecauseOfMtu) throws IOException {\r\n        final String host = \"somehost.netty.io\";\r\n", "        return query0(nameServerAddr, question, toArray(additionals, false), true, ch.newPromise(), promise);\r\n    }\r\n\r\n    /**\r\n     * Returns {@code true} if the {@link Throwable} was caused by an timeout or transport error.\r\n", "    }\r\n\r\n    /**\r\n     * Returns {@code true} if the {@link Throwable} was caused by an timeout.\r\n     * These methods can be used on the {@link Future#cause()} that is returned by the various methods exposed by this\r\n", "    final List<? extends E> get(String hostname) {\r\n        Entries entries = resolveCache.get(hostname);\r\n        return entries == null ? null : entries.get();\r\n    }\r\n\r\n", "     * @param msg the object to determine the length of.\r\n     * @return the determined content length.\r\n     */\r\n    private static int contentLength(Object msg) {\r\n        if (msg instanceof MemcacheContent) {\r\n", "\r\nimport java.net.InetSocketAddress;\r\n\r\nfinal class TcpDnsQueryContext extends DnsQueryContext {\r\n\r\n", "                @Override\r\n                public void run() {\r\n                    doResolveAllUncached0(hostname, additionals, originalPromise,\r\n                                          promise, resolveCache, completeEarlyIfPossible);\r\n                }\r\n", "    private DirContextUtils() { }\r\n\r\n    static void addNameServers(List<InetSocketAddress> defaultNameServers, int defaultPort) {\r\n        // Using jndi-dns to obtain the default name servers.\r\n        //\r\n", "            } catch (Exception e) {\r\n                resetDecoder();\r\n                out.add(invalidChunk(e));\r\n                return;\r\n            }\r\n", "                resolvedInternetProtocolFamilies = IPV4_ONLY_RESOLVED_PROTOCOL_FAMILIES;\r\n                break;\r\n            case IPV4_PREFERRED:\r\n                supportsAAAARecords = true;\r\n                supportsARecords = true;\r\n", "import io.netty.util.concurrent.Future;\r\nimport io.netty.util.concurrent.FutureListener;\r\nimport io.netty.util.concurrent.Promise;\r\nimport io.netty.util.internal.ObjectUtil;\r\nimport io.netty.util.internal.PlatformDependent;\r\n", "        this.chunkSize = chunkSize;\r\n    }\r\n\r\n    @Override\r\n    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\r\n", "\r\n        assertFalse(headerBlock.isReadable());\r\n        assertTrue(frame.isInvalid());\r\n        assertEquals(0, frame.headers().names().size());\r\n        headerBlock.release();\r\n", " * Verifies the correct functionality of the {@link AbstractBinaryMemcacheDecoder}.\r\n * <p/>\r\n * While technically there are both a {@link BinaryMemcacheRequestDecoder} and a {@link BinaryMemcacheResponseDecoder}\r\n * they implement the same basics and just differ in the type of headers returned.\r\n */\r\n", "                resolveRecordTypes = IPV4_PREFERRED_RESOLVED_RECORD_TYPES;\r\n                resolvedInternetProtocolFamilies = IPV4_PREFERRED_RESOLVED_PROTOCOL_FAMILIES;\r\n                break;\r\n            case IPV6_ONLY:\r\n                supportsAAAARecords = true;\r\n", "        } finally {\r\n            b.queryRedirected(nameServers);\r\n        }\r\n        return this;\r\n    }\r\n", "            for (String domain : domains) {\r\n                List<String> addresses = new ArrayList<String>(length);\r\n                for (int i = 0; i < length; i++) {\r\n                    addresses.add(TestRecordStore.nextIp());\r\n                }\r\n", "     * @return List of search domains.\r\n     * @throws IOException If a failure occurs parsing the file.\r\n     */\r\n    static List<String> parseEtcResolverSearchDomains(File etcResolvConf) throws IOException {\r\n        String localDomain = null;\r\n", "        return new DnsNameResolver(\r\n                eventLoop,\r\n                channelFactory,\r\n                socketChannelFactory,\r\n                resolveCache,\r\n", "                                logger.debug(\"Received a DNS response with an unexpected ID: TCP [{}: {}]\",\r\n                                        channel, queryId);\r\n                            }\r\n                        }\r\n\r\n", "     *\r\n     * @return a {@link DnsNameResolver}\r\n     */\r\n    public DnsNameResolver build() {\r\n        if (eventLoop == null) {\r\n", "        int length = 10;\r\n        int streamId = 0; // invalid stream identifier\r\n        int associatedToStreamId = RANDOM.nextInt() & 0x7FFFFFFF;\r\n        byte priority = (byte) (RANDOM.nextInt() & 0x07);\r\n\r\n", "        ByteBuf newContent = Unpooled.copiedBuffer(\"new value\", CharsetUtil.UTF_8);\r\n        FullBinaryMemcacheRequest newInstance = request.replace(newContent);\r\n        try {\r\n            assertCopy(request, newContent, newInstance);\r\n        } finally {\r\n", "        fullRequest.setExtrasLength(request.extrasLength());\r\n        fullRequest.setDataType(request.dataType());\r\n        fullRequest.setTotalBodyLength(request.totalBodyLength());\r\n        fullRequest.setOpaque(request.opaque());\r\n        fullRequest.setCas(request.cas());\r\n", "    }\r\n\r\n    @Test\r\n    public void testResolveAAAA() throws Exception {\r\n        DnsNameResolver resolver = newResolver(ResolvedAddressTypes.IPV6_ONLY).build();\r\n", "            server.stop();\r\n        }\r\n    }\r\n\r\n    @Test\r\n", "        ByteBuf extras = Unpooled.copiedBuffer(\"extras\", CharsetUtil.UTF_8);\r\n        BinaryMemcacheRequest request = new DefaultBinaryMemcacheRequest(key, extras);\r\n\r\n        assertTrue(channel.writeOutbound(request));\r\n        for (;;) {\r\n", "        final ByteBuf content = record.content();\r\n        assertThat(record.name(), is(\"foo.com.\"));\r\n        assertThat(record.dnsClass(), is(DnsRecord.CLASS_IN));\r\n        assertThat(record.type(), is(A));\r\n        assertThat(content.readableBytes(), is(4));\r\n", "                    putIfAbsent(domainToNameServerStreamMap, domainName, addresses, rotate);\r\n                }\r\n            } finally {\r\n                if (br == null) {\r\n                    fr.close();\r\n", "    public static final NoopDnsQueryLifecycleObserverFactory INSTANCE = new NoopDnsQueryLifecycleObserverFactory();\r\n\r\n    private NoopDnsQueryLifecycleObserverFactory() {\r\n    }\r\n\r\n", "            while (server != null) {\r\n                if (server.address != null) {\r\n                    addressList.add(server.address);\r\n                }\r\n                server = server.next;\r\n", "        return question;\r\n    }\r\n\r\n    // Suppress a warning since the method doesn't need synchronization\r\n    @Override\r\n", "                final List<DnsRecord> mxList = f.getNow();\r\n                assertThat(mxList.size(), is(greaterThan(0)));\r\n                StringBuilder buf = new StringBuilder();\r\n                for (DnsRecord r : mxList) {\r\n                    ByteBuf recordContent = ((ByteBufHolder) r).content();\r\n", "    final DnsNameResolver parent;\r\n    private final Promise<?> originalPromise;\r\n    private final DnsServerAddressStream nameServerAddrs;\r\n    private final String hostname;\r\n    private final int dnsClass;\r\n", "        short type = 8;\r\n        byte flags = 0;\r\n        int length = 4;\r\n        int headerBlockLength = 1024;\r\n        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;\r\n", "        int length = 4;\r\n        int headerBlockLength = 1024;\r\n        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;\r\n\r\n        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length + headerBlockLength);\r\n", "            return sender;\r\n        }\r\n\r\n        @Override\r\n        public InetSocketAddress recipient() {\r\n", "            throws Exception {\r\n        final String hostname = \"some.record.netty.io\";\r\n        final String hostname2 = \"some2.record.netty.io\";\r\n\r\n        final TestDnsServer dnsServerAuthority = new TestDnsServer(new HashSet<String>(\r\n", "                .hostsFileEntriesResolver(new HostsFileEntriesResolver() {\r\n                    @Override\r\n                    public InetAddress address(String inetHost, ResolvedAddressTypes resolvedAddressTypes) {\r\n                        if (\"foo.com.\".equals(inetHost)) {\r\n                            try {\r\n", "        assertTrue(fut.await(10, TimeUnit.SECONDS));\r\n        assertFalse(fut.isSuccess());\r\n    }\r\n\r\n    private static String assertResolve(DnsNameResolver resolver, String inetHost) throws InterruptedException {\r\n", "        finishResolve(promise, cause);\r\n    }\r\n\r\n    private void finishResolve(Promise<List<T>> promise, Throwable cause) {\r\n        // If completeEarly was true we still want to continue processing the queries to ensure we still put everything\r\n", "     *\r\n     * @param eventLoop the {@link EventLoop} which will perform the communication with the DNS servers\r\n     * @param channelFactory the {@link ChannelFactory} that will create a {@link DatagramChannel}\r\n     * @param resolveCache the DNS resolved entries cache\r\n     * @param authoritativeDnsServerCache the cache used to find the authoritative DNS server for a domain\r\n", "\r\n    @Test\r\n    public void testEmptySpdyDataFrame() throws Exception {\r\n        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;\r\n        byte flags = 0;\r\n", "                        \"Default DNS servers: {} (sun.net.dns.ResolverConfiguration)\", defaultNameServers);\r\n            }\r\n        } else {\r\n            // Depending if IPv6 or IPv4 is used choose the correct DNS servers provided by google:\r\n            // https://developers.google.com/speed/public-dns/docs/using\r\n", "\r\n        String name = mapping;\r\n        // Resolve from cnameCache() until there is no more cname entry cached.\r\n        while ((mapping = cnameCache.get(hostnameWithDot(name))) != null) {\r\n            checkCnameLoop(hostname, first, mapping);\r\n", "            InetSocketAddress address = originalStream.next();\r\n            if (address.equals(replaced)) {\r\n                resolved = resolvedAddresses.iterator();\r\n                return nextResolved0();\r\n            }\r\n", "        }\r\n        if (entries.get(0).cause() != null) {\r\n            return null;\r\n        }\r\n\r\n", "        return msg instanceof MemcacheObject || msg instanceof ByteBuf || msg instanceof FileRegion;\r\n    }\r\n\r\n    /**\r\n     * Take the given {@link MemcacheMessage} and encode it into a writable {@link ByteBuf}.\r\n", "\r\n    DnsQuestion question() {\r\n        return question;\r\n    }\r\n\r\n", "    @Test\r\n    public void testCompareUnresolvedSimple() {\r\n        NameServerComparator comparator = new NameServerComparator(Inet4Address.class);\r\n        int x = comparator.compare(IPV4ADDRESS1, UNRESOLVED1);\r\n        int y = comparator.compare(UNRESOLVED1, IPV4ADDRESS1);\r\n", "                                                      int dnsClass, DnsRecordType[] expectedTypes,\r\n                                                      DnsRecord[] additionals,\r\n                                                      DnsServerAddressStream nameServerAddrs, int allowedQueries) {\r\n        return new DnsAddressResolveContext(parent, originalPromise, hostname, additionals, nameServerAddrs,\r\n                allowedQueries, resolveCache, authoritativeDnsServerCache, completeEarlyIfPossible);\r\n", "\r\n            if (a instanceof Inet4Address) {\r\n                // Also add the mapping for the IPv4-compatible IPv6 address.\r\n                final Inet4Address a4 = (Inet4Address) a;\r\n                if (a4.isLoopbackAddress()) {\r\n", "        checkNotNull(hostname, \"hostname\");\r\n        return resolveCache.clear(appendDot(hostname));\r\n    }\r\n\r\n    private static boolean emptyAdditionals(DnsRecord[] additionals) {\r\n", "        // \"host4.sub\" contains a dot but not resolved then resolved to \"host4.sub.foo.com\" with \"foo.com\" search domain\r\n        resolved = assertResolveAll(resolver, \"host4.sub\");\r\n        assertEquals(store.getAddresses(\"host4.sub.foo.com\"), resolved);\r\n\r\n        // \"host5.sub\" would have been directly resolved but since it has less than ndots the \"foo.com\" search domain\r\n", "import org.apache.directory.server.dns.protocol.DnsProtocolHandler;\r\nimport org.apache.directory.server.dns.protocol.DnsUdpEncoder;\r\nimport org.apache.directory.server.dns.store.DnsAttribute;\r\nimport org.apache.directory.server.dns.store.RecordStore;\r\nimport org.apache.directory.server.protocol.shared.transport.UdpTransport;\r\n", "\r\n    private static DnsRecord[] toArray(Iterable<DnsRecord> additionals, boolean validateType) {\r\n        checkNotNull(additionals, \"additionals\");\r\n        if (additionals instanceof Collection) {\r\n            Collection<DnsRecord> records = (Collection<DnsRecord>) additionals;\r\n", "     * Returns the component that tries to resolve hostnames against the hosts file prior to asking to\r\n     * remotes DNS servers.\r\n     */\r\n    public HostsFileEntriesResolver hostsFileEntriesResolver() {\r\n        return hostsFileEntriesResolver;\r\n", "                    rm.put(DnsAttribute.IP_ADDRESS, ipv4Addr);\r\n                } else {\r\n                    return null;\r\n                }\r\n                return Collections.singleton(rm.getEntry());\r\n", "    }\r\n\r\n    private DnsQueryLifecycleObserver newDnsQueryLifecycleObserver(DnsQuestion question) {\r\n        return parent.dnsQueryLifecycleObserverFactory().newDnsQueryLifecycleObserver(question);\r\n    }\r\n", "     */\r\n    public final Future<List<DnsRecord>> resolveAll(DnsQuestion question) {\r\n        return resolveAll(question, EMPTY_ADDITIONALS, executor().<List<DnsRecord>>newPromise());\r\n    }\r\n\r\n", "    public DefaultBinaryMemcacheResponse(ByteBuf key) {\r\n        this(key, null);\r\n    }\r\n\r\n    /**\r\n", "    public void testInvalidSpdySynReplyFrameLength() throws Exception {\r\n        short type = 2;\r\n        byte flags = 0;\r\n        int length = 0; // invalid length\r\n\r\n", "        } else {\r\n            tryFailure(promise, cause);\r\n            return true;\r\n        }\r\n    }\r\n", "import io.netty.handler.codec.memcache.MemcacheContent;\r\nimport io.netty.handler.codec.memcache.MemcacheObject;\r\nimport io.netty.util.internal.UnstableApi;\r\n\r\n/**\r\n", "import io.netty.util.internal.UnstableApi;\r\n\r\n/**\r\n * The default implementation of a {@link FullBinaryMemcacheResponse}.\r\n */\r\n", "        copiedBuilder.traceEnabled(traceEnabled);\r\n        copiedBuilder.maxPayloadSize(maxPayloadSize);\r\n        copiedBuilder.optResourceEnabled(optResourceEnabled);\r\n        copiedBuilder.hostsFileEntriesResolver(hostsFileEntriesResolver);\r\n\r\n", "            for (DnsRecord r: additionals) {\r\n                validateAdditional(r, validateType);\r\n            }\r\n            return records.toArray(new DnsRecord[records.size()]);\r\n        }\r\n", " */\r\n@UnstableApi\r\npublic abstract class AbstractBinaryMemcacheEncoder<M extends BinaryMemcacheMessage>\r\n    extends AbstractMemcacheObjectEncoder<M> {\r\n\r\n", "            DnsServerAddressStream nameServerAddressStream = getNameServers(name);\r\n\r\n            final int end = expectedTypes.length - 1;\r\n            for (int i = 0; i < end; ++i) {\r\n                if (!query(name, expectedTypes[i], nameServerAddressStream.duplicate(), false, promise)) {\r\n", "            assertNotNull(envelope.sender());\r\n\r\n            DnsResponse response = envelope.content();\r\n            assertNotNull(response);\r\n\r\n", "\r\n        TestDnsProtocolUdpCodecFactory(boolean dropAAAArecords) {\r\n            this.dropAAAArecords = dropAAAArecords;\r\n        }\r\n\r\n", "    @Override\r\n    FullBinaryMemcacheRequest touch();\r\n\r\n    @Override\r\n    FullBinaryMemcacheRequest touch(Object hint);\r\n", "        int numSettings = 1;\r\n        int length = 8 * numSettings + 4;\r\n        byte idFlags = 0x01; // FLAG_SETTINGS_PERSIST_VALUE\r\n        int id = RANDOM.nextInt() & 0x00FFFFFF;\r\n        int value = RANDOM.nextInt();\r\n", "            // original nameservers so we correctly update the internal index\r\n            if (name.equals(hostname)) {\r\n                return nameServerAddrs.duplicate();\r\n            }\r\n            return parent.newNameServerAddressStream(name);\r\n", "        ByteBuf extras = extras();\r\n        if (extras != null) {\r\n            extras = extras.duplicate();\r\n        }\r\n        return newInstance(key, extras, content().duplicate());\r\n", "        ByteBuf extras = extras();\r\n        if (extras != null) {\r\n            extras = extras.duplicate();\r\n        }\r\n        return newInstance(key, extras, content().duplicate());\r\n", "            return ((FileRegion) msg).retain();\r\n        }\r\n        throw new IllegalStateException(\"unexpected message type: \" + StringUtil.simpleClassName(msg));\r\n    }\r\n\r\n", "                    ? getSearchDomainsHack()\r\n                    : UnixResolverDnsServerAddressStreamProvider.parseEtcResolverSearchDomains();\r\n            searchDomains = list.toArray(new String[0]);\r\n        } catch (Exception ignore) {\r\n            // Failed to get the system name search domain list.\r\n", "\r\n            // Ensure the result from the cache is identical from the uncached one.\r\n            assertThat(resultB.size(), is(resultA.size()));\r\n            for (Entry<String, InetAddress> e : resultA.entrySet()) {\r\n                InetAddress expected = e.getValue();\r\n", "                Collections.singletonList(domain))) {\r\n\r\n            @Override\r\n            protected DnsMessage filterMessage(DnsMessage message) {\r\n                // Just always return NS records only without any additional records (glue records).\r\n", "\r\n    @After\r\n    public void teardown() throws Exception {\r\n        channel.finishAndReleaseAll();\r\n    }\r\n", "\r\n    @After\r\n    public void teardown() throws Exception {\r\n        channel.finishAndReleaseAll();\r\n    }\r\n", "public class DnsServerAddressesTest {\r\n\r\n    private static final InetSocketAddress ADDR1 = new InetSocketAddress(NetUtil.LOCALHOST, 1);\r\n    private static final InetSocketAddress ADDR2 = new InetSocketAddress(NetUtil.LOCALHOST, 2);\r\n    private static final InetSocketAddress ADDR3 = new InetSocketAddress(NetUtil.LOCALHOST, 3);\r\n", "        nameServerComparator = new NameServerComparator(preferredAddressType.addressType());\r\n\r\n        Bootstrap b = new Bootstrap();\r\n        b.group(executor());\r\n        b.channelFactory(channelFactory);\r\n", "\r\npublic class DefaultFullBinaryMemcacheRequestTest {\r\n\r\n    private DefaultFullBinaryMemcacheRequest request;\r\n\r\n", "import java.util.concurrent.atomic.AtomicInteger;\r\nimport java.util.concurrent.atomic.AtomicReference;\r\n\r\nimport static io.netty.handler.codec.dns.DnsRecordType.A;\r\nimport static io.netty.handler.codec.dns.DnsRecordType.AAAA;\r\n", "    }\r\n\r\n    @Test\r\n    public void testRotational() {\r\n        DnsServerAddresses seq = DnsServerAddresses.rotational(ADDR1, ADDR2, ADDR3);\r\n", "\r\n    @Test\r\n    public void testSearchDomainQueryFailureForSingleAddressTypeCompletes() {\r\n        expectedException.expect(UnknownHostException.class);\r\n        testSearchDomainQueryFailureCompletes(ResolvedAddressTypes.IPV4_ONLY);\r\n", "    public SequentialDnsServerAddressStream duplicate() {\r\n        return new SequentialDnsServerAddressStream(addresses, i);\r\n    }\r\n\r\n    @Override\r\n", "        public LastMemcacheContent retainedDuplicate() {\r\n            return this;\r\n        }\r\n\r\n        @Override\r\n", "\r\n    private static final class DnsAddressStreamList extends AbstractList<InetSocketAddress> {\r\n\r\n        private final DnsServerAddressStream duplicate;\r\n        private List<InetSocketAddress> addresses;\r\n", "     *\r\n     * @return {@link DnsNameResolverBuilder}\r\n     */\r\n    public DnsNameResolverBuilder copy() {\r\n        DnsNameResolverBuilder copiedBuilder = new DnsNameResolverBuilder();\r\n", "                        int priority = 0;\r\n                        do {\r\n                            attr.put(DnsAttribute.DOMAIN_NAME.toLowerCase(Locale.US), nextDomain());\r\n                            attr.put(DnsAttribute.MX_PREFERENCE.toLowerCase(Locale.US), String.valueOf(++priority));\r\n                        } while (PlatformDependent.threadLocalRandom().nextBoolean());\r\n", "        buffer.writeByte(flags);\r\n        buffer.writeMedium(length);\r\n    }\r\n\r\n    @Test\r\n", "     *\r\n     * @param optResourceEnabled if optional records inclusion is enabled\r\n     * @return {@code this}\r\n     */\r\n    public DnsNameResolverBuilder optResourceEnabled(boolean optResourceEnabled) {\r\n", "        byte flags = 0;\r\n        int length = 0;\r\n\r\n        ByteBuf buf = Unpooled.buffer(2 * (SPDY_HEADER_SIZE + length));\r\n        encodeDataFrameHeader(buf, streamId1, flags, length);\r\n", "                DnsServerAddressStream cached = authoritativeDnsServerCache.get(domain + '.');\r\n                assertEquals(2, cached.size());\r\n                InetSocketAddress ns1Address = InetSocketAddress.createUnresolved(\r\n                        ns1Name + '.', DefaultDnsServerAddressStreamProvider.DNS_PORT);\r\n                InetSocketAddress ns2Address = InetSocketAddress.createUnresolved(\r\n", "        final String name = \"netty.com\";\r\n        // This store is non-compliant, returning records of the wrong type for a query.\r\n        // It works since we don't verify the type of the result when resolving to deal with\r\n        // non-compliant servers in the wild.\r\n        List<Set<ResourceRecord>> records = new ArrayList<Set<ResourceRecord>>();\r\n", " * A {@link DnsNameResolver} builder.\r\n */\r\npublic final class DnsNameResolverBuilder {\r\n    volatile EventLoop eventLoop;\r\n    private ChannelFactory<? extends DatagramChannel> channelFactory;\r\n", "\r\n    @Override\r\n    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\r\n        try {\r\n            a.queryRedirected(nameServers);\r\n", "import io.netty.handler.codec.dns.DnsRecord;\r\nimport io.netty.handler.codec.dns.DnsRecordType;\r\nimport io.netty.util.concurrent.Promise;\r\n\r\nfinal class DnsAddressResolveContext extends DnsResolveContext<InetAddress> {\r\n", "\r\n    @Test\r\n    public void testZeroNameLength() throws Exception {\r\n        ByteBuf headerBlock = Unpooled.buffer(8);\r\n        headerBlock.writeInt(1);\r\n", "    @Before\r\n    public void setUp() {\r\n        request = new DefaultFullBinaryMemcacheRequest(\r\n                Unpooled.copiedBuffer(\"key\", CharsetUtil.UTF_8),\r\n                Unpooled.wrappedBuffer(new byte[]{1, 3, 4, 9}),\r\n", "            // Will only query for one CNAME\r\n            assertEquals(2, cnameQueries.get());\r\n            assertEquals(3, aQueries.get());\r\n\r\n            resolvedAddresses =\r\n", "    private static final byte[] valueBytes = value.getBytes();\r\n\r\n    private SpdyHeaderBlockRawDecoder decoder;\r\n    private SpdyHeadersFrame frame;\r\n\r\n", "        FullBinaryMemcacheResponse newInstance = response.replace(newContent);\r\n        try {\r\n            assertResponseEquals(response, newContent, newInstance);\r\n        } finally {\r\n            response.release();\r\n", "\r\n    private static DnsNameResolverBuilder newResolver() {\r\n        return newResolver(true);\r\n    }\r\n\r\n", "        return additionals == null || additionals.length == 0;\r\n    }\r\n\r\n    @Override\r\n    public List<? extends DnsCacheEntry> get(String hostname, DnsRecord[] additionals) {\r\n", "            EventLoop loop = group.next();\r\n            final DefaultDnsCache cache = new DefaultDnsCache();\r\n            assertNotNull(cache.cache(\"netty.io\", null, NetUtil.LOCALHOST, days, loop));\r\n        } finally {\r\n            group.shutdownGracefully();\r\n", "        public ByteBuf content() {\r\n            return Unpooled.EMPTY_BUFFER;\r\n        }\r\n\r\n        @Override\r\n", "    }\r\n\r\n    @Override\r\n    protected Object newContinueResponse(H start, int maxContentLength, ChannelPipeline pipeline) {\r\n        return null;\r\n", "\r\n    /**\r\n     * Create a new {@link DefaultBinaryMemcacheRequest} with the header, key, extras and content.\r\n     *\r\n     * @param key     the key to use.\r\n", "        new DnsAddressResolveContext(this, originalPromise, hostname, additionals, nameServerAddrs,\r\n                                     maxQueriesPerResolve, resolveCache,\r\n                                     authoritativeDnsServerCache, completeEarlyIfPossible)\r\n                .resolve(promise);\r\n    }\r\n", "        encodeHeader(buf, msg);\r\n        encodeExtras(buf, msg.extras());\r\n        encodeKey(buf, msg.key());\r\n\r\n        return buf;\r\n", "        int length = 0;\r\n\r\n        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeDataFrameHeader(buf, streamId, flags, length);\r\n\r\n", "        int length = 0;\r\n\r\n        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeDataFrameHeader(buf, streamId, flags, length);\r\n\r\n", "        int length = 0;\r\n\r\n        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeDataFrameHeader(buf, streamId, flags, length);\r\n\r\n", "        int length = 0;\r\n\r\n        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeDataFrameHeader(buf, streamId, flags, length);\r\n\r\n", "            doResolve(inetHost, additionalsArray, promise, resolveCache);\r\n            return promise;\r\n        } catch (Exception e) {\r\n            return promise.setFailure(e);\r\n        }\r\n", "        decoder.decode(ByteBufAllocator.DEFAULT, headerBlock, frame);\r\n\r\n        assertFalse(headerBlock.isReadable());\r\n        assertTrue(frame.isInvalid());\r\n        assertEquals(0, frame.headers().names().size());\r\n", "import java.util.List;\r\n\r\n/**\r\n * Decoder for both {@link BinaryMemcacheRequest} and {@link BinaryMemcacheResponse}.\r\n * <p/>\r\n", "                    return i < stream.size();\r\n                }\r\n\r\n                @Override\r\n                public InetSocketAddress next() {\r\n", "        if (cached == null || cached.size() == 0) {\r\n            // If there is no cache hit (which may be the case for example when a NoopAuthoritativeDnsServerCache\r\n            // is used), we will just directly use the provided nameservers.\r\n            Collections.sort(nameservers, nameServerComparator);\r\n            return new SequentialDnsServerAddressStream(nameservers, 0);\r\n", "        assertThat(written.readableBytes(), is(DEFAULT_HEADER_SIZE));\r\n        written.release();\r\n\r\n        written = channel.readOutbound();\r\n        assertThat(written.readableBytes(), is(content1.content().readableBytes()));\r\n", "public interface LastMemcacheContent extends MemcacheContent {\r\n\r\n    LastMemcacheContent EMPTY_LAST_CONTENT = new LastMemcacheContent() {\r\n\r\n        @Override\r\n", "        UnixResolverOptions.Builder optionsBuilder = UnixResolverOptions.newBuilder();\r\n\r\n        FileReader fr = new FileReader(etcResolvConf);\r\n        BufferedReader br = null;\r\n        try {\r\n", "        super.retain(increment);\r\n        return this;\r\n    }\r\n\r\n    @Override\r\n", "        decoder.endHeaderBlock(frame);\r\n\r\n        assertFalse(headerBlock.isReadable());\r\n        assertTrue(frame.isInvalid());\r\n        assertEquals(0, frame.headers().names().size());\r\n", "                    public void operationComplete(Future<U> f) throws Exception {\r\n                        transferResult(f, promise);\r\n                    }\r\n                });\r\n            }\r\n", "/**\r\n * The encoder which takes care of encoding the response headers.\r\n */\r\n@UnstableApi\r\npublic class BinaryMemcacheResponseEncoder\r\n", "        return this;\r\n    }\r\n\r\n    @Override\r\n    public FullBinaryMemcacheResponse touch(Object hint) {\r\n", "     * @param etcResolvConf a file of the format <a href=\"https://linux.die.net/man/5/resolver\">/etc/resolv.conf</a>.\r\n     * @return The options values provided by /etc/resolve.conf.\r\n     * @throws IOException If a failure occurs parsing the file.\r\n     */\r\n    static UnixResolverOptions parseEtcResolverOptions(File etcResolvConf) throws IOException {\r\n", "     * Be aware this <strong>won't</strong> be called with timeout / cancel / transport exceptions.\r\n      *\r\n     * @param hostname the hostname\r\n     * @param additionals the additional records\r\n     * @param cause the resolution failure\r\n", "\r\n        assert executor().inEventLoop();\r\n\r\n        final DnsServerAddressStream nameServerAddrs =\r\n                dnsServerAddressStreamProvider.nameServerAddressStream(hostname);\r\n", "\r\n        try {\r\n            String domain = DOMAINS.iterator().next();\r\n            String domainWithDot = domain + '.';\r\n\r\n", "        buf.release();\r\n    }\r\n\r\n    @Test\r\n    public void testSpdySettingsFrame() throws Exception {\r\n", "    public DnsNameResolverBuilder socketChannelFactory(ChannelFactory<? extends SocketChannel> channelFactory) {\r\n        this.socketChannelFactory = channelFactory;\r\n        return this;\r\n    }\r\n\r\n", "     * Create a new instance.\r\n     * @param addresses The addresses are not cloned. It is assumed the caller has cloned this array or otherwise will\r\n     *                  not modify the contents.\r\n     */\r\n    ShuffledDnsServerAddressStream(List<InetSocketAddress> addresses) {\r\n", "    static final class Builder {\r\n\r\n        private int ndots = 1;\r\n        private int timeout = 5;\r\n        private int attempts = 16;\r\n", "    private ShuffledDnsServerAddressStream(List<InetSocketAddress> addresses, int startIdx) {\r\n        this.addresses = addresses;\r\n        i = startIdx;\r\n    }\r\n\r\n", "        assertNext(i, ADDR1);\r\n\r\n        i = seq.stream();\r\n        assertNext(i, ADDR3);\r\n        assertNext(i, ADDR1);\r\n", "        queryLifecycleObserver.queryWritten(nameServerAddr, writePromise);\r\n\r\n        f.addListener(new FutureListener<AddressedEnvelope<DnsResponse, InetSocketAddress>>() {\r\n            @Override\r\n            public void operationComplete(Future<AddressedEnvelope<DnsResponse, InetSocketAddress>> future) {\r\n", "     * @param queryTimeoutMillis timeout of each DNS query in millis\r\n     * @param resolvedAddressTypes the preferred address types\r\n     * @param recursionDesired if recursion desired flag must be set\r\n     * @param maxQueriesPerResolve the maximum allowed number of DNS queries for a given name resolution\r\n     * @param traceEnabled if trace is enabled\r\n", "                queriesInProgress.remove(future);\r\n\r\n                if (promise.isDone() || future.isCancelled()) {\r\n                    queryLifecycleObserver.queryCancelled(allowedQueries);\r\n\r\n", "                state = State.READ_CONTENT;\r\n            } catch (Exception e) {\r\n                resetDecoder();\r\n                out.add(invalidMessage(e));\r\n                return;\r\n", "    }\r\n\r\n    @Override\r\n    public MemcacheContent replace(ByteBuf content) {\r\n        return new DefaultMemcacheContent(content);\r\n", "            }\r\n            if (cause instanceof Error) {\r\n                throw (Error) cause;\r\n            }\r\n            throw new IllegalStateException(\"Unable to create / register Channel\", cause);\r\n", "\r\n    public RoundRobinDnsAddressResolverGroup(\r\n            ChannelFactory<? extends DatagramChannel> channelFactory,\r\n            DnsServerAddressStreamProvider nameServerProvider) {\r\n        super(channelFactory, nameServerProvider);\r\n", "    @Test\r\n    public void testIncludeDuplicates() throws IOException {\r\n        final String name = \"netty.io\";\r\n        final String ipv4Addr = \"1.2.3.4\";\r\n        TestDnsServer dnsServer2 = new TestDnsServer(new RecordStore() {\r\n", "        @Override\r\n        public int size() {\r\n            return 1;\r\n        }\r\n\r\n", "\r\n    private static DnsServerAddresses sequential0(final List<InetSocketAddress> addresses) {\r\n        if (addresses.size() == 1) {\r\n            return singleton(addresses.get(0));\r\n        }\r\n", "                    return records;\r\n                }\r\n                if (name.equals(\"foo.service.netty.io\")) {\r\n                    ResourceRecordModifier rm = new ResourceRecordModifier();\r\n                    rm.setDnsClass(RecordClass.IN);\r\n", "                                    Collections.<String, Object>singletonMap(\r\n                                            DnsAttribute.CHARACTER_STRING.toLowerCase(), txt)));\r\n                }\r\n                return null;\r\n            }\r\n", "\r\n    @Test\r\n    public void searchDomainsWithMultipleSearchSeperatedByWhitespace() throws IOException {\r\n        File f = buildFile(\"search linecorp.local squarecorp.local\\n\" +\r\n                           \"nameserver 127.0.0.2\\n\");\r\n", "        testResolveAll0(ResolvedAddressTypes.IPV4_ONLY, NetUtil.LOCALHOST4, StringUtil.EMPTY_STRING);\r\n    }\r\n\r\n    @Test\r\n    public void testResolveAllEmptyIpv6() {\r\n", "\r\n        // \"host4\" does not resolve\r\n        assertNotResolve(resolver, \"host4\");\r\n    }\r\n\r\n", "    protected void encode(ChannelHandlerContext ctx, Object msg, List<Object> out) throws Exception {\r\n        if (msg instanceof MemcacheMessage) {\r\n            if (expectingMoreContent) {\r\n                throw new IllegalStateException(\"unexpected message type: \" + StringUtil.simpleClassName(msg));\r\n            }\r\n", "        assertHostNameEquals(\"127.0.0.4\", stream.next());\r\n        assertHostNameEquals(\"127.0.0.5\", stream.next());\r\n    }\r\n\r\n    @Test\r\n", "\r\n        stream = p.nameServerAddressStream(\"\");\r\n        assertHostNameEquals(\"127.0.0.4\", stream.next());\r\n        assertHostNameEquals(\"127.0.0.2\", stream.next());\r\n        assertHostNameEquals(\"127.0.0.3\", stream.next());\r\n", "package io.netty.handler.codec.memcache;\r\n\r\nimport io.netty.handler.codec.DecoderResultProvider;\r\nimport io.netty.util.internal.UnstableApi;\r\n\r\n", "    public void shouldHandleTwoMessagesInOneBatch() {\r\n        channel.writeInbound(Unpooled.buffer().writeBytes(GET_REQUEST).writeBytes(GET_REQUEST));\r\n\r\n        BinaryMemcacheRequest request = channel.readInbound();\r\n        assertThat(request, instanceOf(BinaryMemcacheRequest.class));\r\n", "        assertFalse(frame.isInvalid());\r\n        assertEquals(1, frame.headers().names().size());\r\n        assertTrue(frame.headers().contains(name));\r\n        assertEquals(1, frame.headers().getAll(name).size());\r\n        assertEquals(value, frame.headers().get(name));\r\n", "        return query(nextNameServerAddress(), question, Collections.<DnsRecord>emptyList(), promise);\r\n    }\r\n\r\n    private InetSocketAddress nextNameServerAddress() {\r\n        return nameServerAddrStream.get().next();\r\n", "\r\n        stream = p.nameServerAddressStream(\"\");\r\n        assertHostNameEquals(\"127.0.0.2\", stream.next());\r\n        assertHostNameEquals(\"127.0.0.3\", stream.next());\r\n        assertHostNameEquals(\"127.0.0.4\", stream.next());\r\n", "\r\n        stream = p.nameServerAddressStream(\"\");\r\n        assertHostNameEquals(\"127.0.0.2\", stream.next());\r\n        assertHostNameEquals(\"127.0.0.3\", stream.next());\r\n        assertHostNameEquals(\"127.0.0.4\", stream.next());\r\n", "\r\n        stream = p.nameServerAddressStream(\"\");\r\n        assertHostNameEquals(\"127.0.0.2\", stream.next());\r\n        assertHostNameEquals(\"127.0.0.3\", stream.next());\r\n        assertHostNameEquals(\"127.0.0.4\", stream.next());\r\n", "                    resolver.resolveAll(\"y.netty.io\").syncUninterruptibly().getNow();\r\n            assertEquals(1, resolvedAddresses.size());\r\n            assertTrue(resolvedAddresses.contains(InetAddress.getByAddress(new byte[] { 10, 0, 0, 99 })));\r\n\r\n            // Should not have queried for the CNAME again.\r\n", "\r\n    @Test\r\n    public void testInvalidSpdyRstStreamFrameLength() throws Exception {\r\n        short type = 3;\r\n        byte flags = 0;\r\n", "\r\n        assertEquals(0, comparator.compare(IPV4ADDRESS1, IPV4ADDRESS1));\r\n        assertEquals(0, comparator.compare(IPV6ADDRESS1, IPV6ADDRESS1));\r\n    }\r\n\r\n", "            MemcacheContent content = channel.readInbound();\r\n            if (i < expectedContentChunks) {\r\n                assertThat(content, instanceOf(MemcacheContent.class));\r\n            } else {\r\n                assertThat(content, instanceOf(LastMemcacheContent.class));\r\n", "            }\r\n        }\r\n        STREAM_PROVIDER_CONSTRUCTOR = constructor;\r\n    }\r\n\r\n", "     */\r\n    public DnsNameResolverBuilder resolvedAddressTypes(ResolvedAddressTypes resolvedAddressTypes) {\r\n        this.resolvedAddressTypes = resolvedAddressTypes;\r\n        return this;\r\n    }\r\n", "    }\r\n\r\n    @Test\r\n    public void testSortAlreadySortedUnresolved() {\r\n        List<InetSocketAddress> expected = Arrays.asList(UNRESOLVED1, UNRESOLVED2, UNRESOLVED3);\r\n", "        return rm.getEntry();\r\n    }\r\n\r\n    protected static ResourceRecord newAddressRecord(String name, RecordType type, String address) {\r\n        ResourceRecordModifier rm = new ResourceRecordModifier();\r\n", "        InetAddress addr1 = InetAddress.getByAddress(new byte[] { 10, 0, 0, 1 });\r\n        InetAddress addr2 = InetAddress.getByAddress(new byte[] { 10, 0, 0, 2 });\r\n        EventLoopGroup group = new DefaultEventLoopGroup(1);\r\n\r\n        try {\r\n", "    public void testReservedSpdySynStreamFrameBits() throws Exception {\r\n        short type = 1;\r\n        byte flags = 0;\r\n        int length = 10;\r\n        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;\r\n", "    @Override\r\n    public void start() throws IOException {\r\n        start(false);\r\n    }\r\n\r\n", "        }\r\n    }\r\n\r\n    private static UnknownHostException resolveNonExistentDomain(DnsNameResolver resolver) {\r\n        try {\r\n", "    public void queryCancelled(int queriesRemaining) {\r\n    }\r\n\r\n    @Override\r\n    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\r\n", "            headerBlock.writeInt(RANDOM.nextInt());\r\n        }\r\n\r\n        decoder.decode(buf);\r\n        decoder.decode(headerBlock);\r\n", "    public void testChannelFactoryException() {\r\n        final IllegalStateException exception = new IllegalStateException();\r\n        try {\r\n            newResolver().channelFactory(new ChannelFactory<DatagramChannel>() {\r\n                @Override\r\n", "        int authorityCount = res.count(DnsSection.AUTHORITY);\r\n        if (authorityCount == 0) {\r\n            return null;\r\n        }\r\n\r\n", "\r\n        stream = p.nameServerAddressStream(\"\");\r\n        assertHostNameEquals(\"127.0.0.3\", stream.next());\r\n        assertHostNameEquals(\"127.0.0.4\", stream.next());\r\n        assertHostNameEquals(\"127.0.0.2\", stream.next());\r\n", "\r\n    @Override\r\n    public BinaryMemcacheMessage setMagic(byte magic) {\r\n        this.magic = magic;\r\n        return this;\r\n", "        buf.writeByte(msg.opcode());\r\n        buf.writeShort(msg.keyLength());\r\n        buf.writeByte(msg.extrasLength());\r\n        buf.writeByte(msg.dataType());\r\n        buf.writeShort(msg.reserved());\r\n", "    @Override\r\n    FullBinaryMemcacheResponse touch();\r\n\r\n    @Override\r\n    FullBinaryMemcacheResponse touch(Object hint);\r\n", "        final InetSocketAddress ns5Address = new InetSocketAddress(\r\n                InetAddress.getByAddress(ns2Name, new byte[] { 10, 0, 0, 5 }),\r\n                DefaultDnsServerAddressStreamProvider.DNS_PORT);\r\n        TestDnsServer redirectServer = new TestDnsServer(new HashSet<String>(Arrays.asList(hostname, ns1Name))) {\r\n            @Override\r\n", "            DnsServerAddressStream entries = authoritativeDnsServerCache().get(hostname);\r\n            if (entries != null) {\r\n                // The returned List may contain unresolved InetSocketAddress instances that will be\r\n                // resolved on the fly in query(....).\r\n                return entries;\r\n", "\r\n        private Builder() {\r\n        }\r\n\r\n        void setNdots(int ndots) {\r\n", "        buf.release();\r\n    }\r\n\r\n    @Test\r\n    public void testReservedSpdyHeadersFrameBits() throws Exception {\r\n", "            list.add(a);\r\n        }\r\n\r\n        if (list.isEmpty()) {\r\n            throw new IllegalArgumentException(\"empty addresses\");\r\n", "            resolver.resolve(\"test\").syncUninterruptibly();\r\n            List<? extends DnsCacheEntry> entries = cache.cacheHits.get(\"test.netty.io\");\r\n            assertFalse(entries.isEmpty());\r\n        } finally {\r\n            resolver.close();\r\n", "        InetAddress ipv6Address1 = InetAddress.getByName(\"::1\");\r\n        InetAddress ipv6Address2 = InetAddress.getByName(\"::2\");\r\n        InetAddress ipv6Address3 = InetAddress.getByName(\"::3\");\r\n\r\n        PreferredAddressTypeComparator ipv4 = PreferredAddressTypeComparator.comparator(InternetProtocolFamily.IPv4);\r\n", "import java.net.InetSocketAddress;\r\nimport java.util.List;\r\nimport java.util.concurrent.ConcurrentMap;\r\n\r\nimport static io.netty.util.internal.PlatformDependent.newConcurrentHashMap;\r\n", "    @Override\r\n    public LastMemcacheContent duplicate() {\r\n        return replace(content().duplicate());\r\n    }\r\n\r\n", "            return response.equals(obj);\r\n        }\r\n\r\n        @Override\r\n        public int hashCode() {\r\n", "    protected final AddressResolver<InetSocketAddress> newAddressResolver(EventLoop eventLoop,\r\n                                                                          NameResolver<InetAddress> resolver)\r\n            throws Exception {\r\n        return new RoundRobinInetAddressResolver(eventLoop, resolver).asAddressResolver();\r\n    }\r\n", "                .syncUninterruptibly().getNow();\r\n        assertThat(records, Matchers.<DnsRecord>hasSize(1));\r\n        assertThat(records.get(0), Matchers.<DnsRecord>instanceOf(DnsRawRecord.class));\r\n\r\n        final DnsRawRecord record = (DnsRawRecord) records.get(0);\r\n", "\r\n    @Test\r\n    public void testResolveACachedWithDotSearchDomain() throws Exception {\r\n        final TestDnsCache cache = new TestDnsCache(new DefaultDnsCache());\r\n        TestDnsServer server = new TestDnsServer(Collections.singleton(\"test.netty.io\"));\r\n", "                    @Override\r\n                    public int compare(InetSocketAddress o1, InetSocketAddress o2) {\r\n                        if (o1.equals(o2)) {\r\n                            return 0;\r\n                        }\r\n", "\r\n        checkCnameLoop(name, first, second);\r\n        return cnameResolveFromCacheLoop(cnameCache, name, first, second);\r\n    }\r\n\r\n", "        // See https://github.com/netty/netty/issues/9500\r\n        if (PlatformDependent.javaVersion() < 9) {\r\n            // This code on Java 9+ yields a warning about illegal reflective access that will be denied in\r\n            // a future release. There doesn't seem to be a better way to get search domains for Windows yet.\r\n            Class<?> configClass = Class.forName(\"sun.net.dns.ResolverConfiguration\");\r\n", "\r\n        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeControlFrameHeader(buf, type, flags, length);\r\n        buf.writeInt(id);\r\n\r\n", "                            try {\r\n                                recordEncoder.put(buf, record);\r\n                            } catch (IOException e) {\r\n                                // Should never happen\r\n                                throw new IllegalStateException(e);\r\n", "    public void emptyEtcResolverDirectoryDoesNotThrow() throws IOException {\r\n        File f = buildFile(\"domain linecorp.local\\n\" +\r\n                           \"nameserver 127.0.0.2\\n\" +\r\n                           \"nameserver 127.0.0.3\\n\");\r\n        UnixResolverDnsServerAddressStreamProvider p =\r\n", "    }\r\n\r\n    public DnsAddressResolverGroup(\r\n            ChannelFactory<? extends DatagramChannel> channelFactory,\r\n            DnsServerAddressStreamProvider nameServerProvider) {\r\n", "    private final Channel channel;\r\n\r\n    TcpDnsQueryContext(DnsNameResolver parent, Channel channel, InetSocketAddress nameServerAddr, DnsQuestion question,\r\n                       DnsRecord[] additionals, Promise<AddressedEnvelope<DnsResponse, InetSocketAddress>> promise) {\r\n        super(parent, nameServerAddr, question, additionals, promise);\r\n", "            DnsServerAddressStream entries = cache.get(\"netty.io\");\r\n            assertEquals(2, entries.size());\r\n            assertEquals(resolved1, entries.next());\r\n            assertEquals(resolved2, entries.next());\r\n        } finally {\r\n", "    @Test\r\n    public void testIllegalSpdyRstStreamFrameStreamId() throws Exception {\r\n        short type = 3;\r\n        byte flags = 0;\r\n        int length = 8;\r\n", "                    resolver.resolveAll(\"x.netty.io\").syncUninterruptibly().getNow();\r\n            assertEquals(1, resolvedAddresses.size());\r\n            assertTrue(resolvedAddresses.contains(InetAddress.getByAddress(new byte[] { 10, 0, 0, 99 })));\r\n\r\n            // Should not have queried for the CNAME again.\r\n", "        InetAddress ipv6Address1 = InetAddress.getByName(\"::1\");\r\n        InetAddress ipv6Address2 = InetAddress.getByName(\"::2\");\r\n        InetAddress ipv6Address3 = InetAddress.getByName(\"::3\");\r\n\r\n        PreferredAddressTypeComparator ipv4 = PreferredAddressTypeComparator.comparator(InternetProtocolFamily.IPv6);\r\n", "                    switch (question.getRecordType()) {\r\n                        case A:\r\n                            rm.put(DnsAttribute.IP_ADDRESS, ipv4Addr);\r\n                            break;\r\n                        case AAAA:\r\n", "import io.netty.util.internal.UnstableApi;\r\n\r\n/**\r\n * The default implementation of a {@link FullBinaryMemcacheRequest}.\r\n */\r\n", "    @Before\r\n    public void setUp() {\r\n        response = new DefaultFullBinaryMemcacheResponse(\r\n                Unpooled.copiedBuffer(\"key\", CharsetUtil.UTF_8),\r\n                Unpooled.wrappedBuffer(new byte[]{1, 3, 4, 9}),\r\n", "        if (bytes != null) {\r\n            // The inetHost is actually an ipaddress.\r\n            promise.setSuccess(InetAddress.getByAddress(bytes));\r\n            return;\r\n        }\r\n", "     * @param loop the {@link EventLoop} used to register the TTL timeout\r\n     * @return The {@link DnsCacheEntry} corresponding to this cache entry, or {@code null} if this cache doesn't\r\n     * support caching failed responses.\r\n     */\r\n    DnsCacheEntry cache(String hostname, DnsRecord[] additionals, Throwable cause, EventLoop loop);\r\n", "        if (logger.isDebugEnabled()) {\r\n            logger.debug(\"{} WRITE: {}, [{}: {}], {}\", channel(), protocol(), id, nameServerAddr, question);\r\n        }\r\n\r\n        sendQuery(query, flush, writePromise);\r\n", "            onResponseCNAME(question, cnames, newDnsQueryLifecycleObserver(question), promise);\r\n        }\r\n    }\r\n\r\n    private void onResponseCNAME(\r\n", "                NetworkInterface iface = interfaces.nextElement();\r\n                Enumeration<InetAddress> addresses = iface.getInetAddresses();\r\n                while (addresses.hasMoreElements()) {\r\n                    InetAddress inetAddress = addresses.nextElement();\r\n                    if (inetAddress instanceof Inet6Address && !inetAddress.isAnyLocalAddress() &&\r\n", "     * @param promise the {@link Promise} which will be fulfilled when the resolution is finished\r\n     *\r\n     * @return the list of the {@link DnsRecord}s as the result of the resolution\r\n     */\r\n    public final Future<List<DnsRecord>> resolveAll(DnsQuestion question, Iterable<DnsRecord> additionals,\r\n", "\r\n            @Override\r\n            InetSocketAddress newRedirectServerAddress(InetAddress server) {\r\n                try {\r\n                    if (server.getHostName().startsWith(ns1Name)) {\r\n", "                hostsFileEntriesResolver,\r\n                dnsServerAddressStreamProvider,\r\n                searchDomains,\r\n                ndots,\r\n                decodeIdn,\r\n", "                assertTrue(envelope.content().isTruncated());\r\n            }\r\n            assertTrue(envelope.release());\r\n        } finally {\r\n            dnsServer2.stop();\r\n", "            for (InternetProtocolFamily f : resolver.resolvedInternetProtocolFamiliesUnsafe()) {\r\n                Class<?> resolvedType = resolved.getClass();\r\n                if (f.addressType().isAssignableFrom(resolvedType)) {\r\n                    typeMatches = true;\r\n                }\r\n", "        List<DnsRecord> records = new ArrayList<DnsRecord>();\r\n        do {\r\n            DnsRecord r = additionalsIt.next();\r\n            validateAdditional(r, validateType);\r\n            records.add(r);\r\n", "    public DnsAddressResolverGroup(\r\n            Class<? extends DatagramChannel> channelType,\r\n            DnsServerAddressStreamProvider nameServerProvider) {\r\n        this.dnsResolverBuilder = new DnsNameResolverBuilder();\r\n        dnsResolverBuilder.channelType(channelType).nameServerProvider(nameServerProvider);\r\n", "import java.util.HashSet;\r\nimport java.util.List;\r\nimport java.util.Set;\r\nimport java.util.concurrent.TimeUnit;\r\n\r\n", "    }\r\n\r\n    static UnixResolverOptions.Builder newBuilder() {\r\n        return new UnixResolverOptions.Builder();\r\n    }\r\n", "\r\n    private final Cache<String> cache = new Cache<String>() {\r\n        @Override\r\n        protected boolean shouldReplaceAll(String entry) {\r\n            // Only one 1:1 mapping is supported as specified in the RFC.\r\n", "\r\n            for (Entry<String, Future<List<DnsRecord>>> e : futures.entrySet()) {\r\n                String hostname = e.getKey();\r\n                Future<List<DnsRecord>> f = e.getValue().awaitUninterruptibly();\r\n\r\n", "    }\r\n\r\n    @Test\r\n    public void testInvalidSpdySynStreamFrameLength() throws Exception {\r\n        short type = 1;\r\n", "    }\r\n\r\n    @Test(timeout = 2000)\r\n    public void testSrvWithCnameNotCached() throws Exception {\r\n        final AtomicBoolean alias = new AtomicBoolean();\r\n", "        final String txt = \"this is a txt record\";\r\n        final AtomicReference<DnsMessage> messageRef = new AtomicReference<DnsMessage>();\r\n\r\n        TestDnsServer dnsServer2 = new TestDnsServer(new RecordStore() {\r\n            @Override\r\n", "    @Test\r\n    public void testResolveNullIpv4() {\r\n        testResolve0(ResolvedAddressTypes.IPV4_ONLY, NetUtil.LOCALHOST4, null);\r\n    }\r\n\r\n", "        final InetSocketAddress nameServerAddr = nameServerAddr();\r\n        final DnsQuery query = newQuery(id);\r\n\r\n        query.setRecursionDesired(recursionDesired);\r\n\r\n", "\r\n            @Override\r\n            public List<? extends DnsCacheEntry> get(String hostname, DnsRecord[] additionals) {\r\n                return null;\r\n            }\r\n", "    private static DnsQuestion validateQuestion(DnsQuestion question) {\r\n        return ObjectUtil.checkNotNull(question, \"question\");\r\n    }\r\n\r\n    /**\r\n", "\r\n            DnsServerAddressStream entries = cache.get(\"netty.io\");\r\n            assertEquals(2, entries.size());\r\n\r\n            if (noComparator) {\r\n", "\r\n        assertThat(set.size(), is(3));\r\n        assertThat(seq.stream(), is(not(sameInstance(seq.stream()))));\r\n    }\r\n\r\n", "            @Override\r\n            public Set<ResourceRecord> getRecords(QuestionRecord question) throws DnsException {\r\n                hitServer2.set(true);\r\n                if (question.getDomainName().equals(firstName)) {\r\n                    ResourceRecordModifier rm = new ResourceRecordModifier();\r\n", "    protected AddressResolver<InetSocketAddress> newAddressResolver(EventLoop eventLoop,\r\n                                                                    NameResolver<InetAddress> resolver)\r\n            throws Exception {\r\n        return new InetSocketAddressResolver(eventLoop, resolver);\r\n    }\r\n", "        }\r\n\r\n        @Override\r\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\r\n            if (cause instanceof CorruptedFrameException) {\r\n", "                    buf.append(recordContent.readUnsignedShort());\r\n                    buf.append(' ');\r\n                    buf.append(DnsResolveContext.decodeDomainName(recordContent));\r\n                }\r\n\r\n", "    @Test\r\n    public void testResolveEmptyIpv6() {\r\n        testResolve0(ResolvedAddressTypes.IPV6_ONLY, NetUtil.LOCALHOST6, StringUtil.EMPTY_STRING);\r\n    }\r\n\r\n", "                        sortEntries(hostname, newEntries);\r\n\r\n                        if (compareAndSet(entries, Collections.unmodifiableList(newEntries))) {\r\n                            scheduleCacheExpirationIfNeeded(ttl, loop);\r\n                            return;\r\n", "                    .recursionDesired(false)\r\n                    .queryTimeoutMillis(10000)\r\n                    .resolvedAddressTypes(ResolvedAddressTypes.IPV4_PREFERRED)\r\n                    .completeOncePreferredResolved(true)\r\n                    .maxQueriesPerResolve(16)\r\n", "                assertEquals(expectedDnsName, writtenEvent1.dnsServerAddress.getHostName());\r\n                assertEquals(dnsServerAuthority.localAddress(), writtenEvent1.dnsServerAddress);\r\n                succeededEvent = (QuerySucceededEvent) observer.events.poll();\r\n\r\n                // Check that it only queried the cache for record.netty.io.\r\n", "            assertEntry(entries.get(0), addr1);\r\n        } finally {\r\n            group.shutdownGracefully();\r\n        }\r\n    }\r\n", "            assertEquals(2, resolvedAddresses.size());\r\n            for (DnsRecord record: resolvedAddresses) {\r\n                ReferenceCountUtil.release(record);\r\n            }\r\n        } finally {\r\n", "    @Override\r\n    public void querySucceed() {\r\n        try {\r\n            a.querySucceed();\r\n        } finally {\r\n", "     * @param dnsQueryLifecycleObserverFactory used to generate new instances of {@link DnsQueryLifecycleObserver} which\r\n     *                                         can be used to track metrics for DNS servers.\r\n     * @param queryTimeoutMillis timeout of each DNS query in millis\r\n     * @param resolvedAddressTypes the preferred address types\r\n     * @param recursionDesired if recursion desired flag must be set\r\n", "                        if (address != null) {\r\n                            serverName.update(parent.newRedirectServerAddress(address));\r\n\r\n                            for (int i = 1; i < entries.size(); i++) {\r\n                                address = entries.get(i).address();\r\n", "                    // If the queryLifecycleObserver has already been terminated we should create a new one for this\r\n                    // fresh query.\r\n                    query(nameServerAddrStream, nameServerAddrStreamIndex + 1, question,\r\n                          newDnsQueryLifecycleObserver(question), true, promise, cause);\r\n                } else {\r\n", "    private static final String RES_OPTIONS = System.getenv(\"RES_OPTIONS\");\r\n\r\n    private static final String ETC_RESOLV_CONF_FILE = \"/etc/resolv.conf\";\r\n    private static final String ETC_RESOLVER_DIR = \"/etc/resolver\";\r\n    private static final String NAMESERVER_ROW_LABEL = \"nameserver\";\r\n", "            AtomicIntegerFieldUpdater.newUpdater(RotationalDnsServerAddresses.class, \"startIdx\");\r\n\r\n    @SuppressWarnings(\"UnusedDeclaration\")\r\n    private volatile int startIdx;\r\n\r\n", "        assertThat(content1, instanceOf(MemcacheContent.class));\r\n        assertThat(content2, instanceOf(LastMemcacheContent.class));\r\n\r\n        assertThat(content1.content().readableBytes(), is(3));\r\n        assertThat(content2.content().readableBytes(), is(5));\r\n", "        assertFalse(buf.isReadable());\r\n    }\r\n\r\n    @Test\r\n    public void testUnknownSpdyWindowUpdateFrameFlags() throws Exception {\r\n", "    }\r\n\r\n    @Test\r\n    public void testResolveAllNullIpv6() {\r\n        testResolveAll0(ResolvedAddressTypes.IPV6_ONLY, NetUtil.LOCALHOST6, null);\r\n", "import org.apache.mina.transport.socket.DatagramSessionConfig;\r\n\r\nimport java.io.IOException;\r\nimport java.net.InetSocketAddress;\r\nimport java.util.ArrayList;\r\n", "            // 3. The first DNS server should fail\r\n            // 4. The second DNS server should succeed\r\n            // This verifies that we do in fact follow multiple DNS servers in the CNAME resolution.\r\n            // The DnsCache is used for the name server cache, but doesn't provide a InetSocketAddress (only InetAddress\r\n            // so no port), so we only specify the name server in the cache, and then specify both name servers in the\r\n", "        }\r\n\r\n        @Override\r\n        public int size() {\r\n            return duplicate.size();\r\n", "        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;\r\n\r\n        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeControlFrameHeader(buf, type, flags, length);\r\n        buf.writeInt(streamId);\r\n", "    @Override\r\n    public MemcacheContent touch(Object hint) {\r\n        content.touch(hint);\r\n        return this;\r\n    }\r\n", "    public static final byte GETKQ = 0x0d;\r\n    public static final byte APPEND = 0x0e;\r\n    public static final byte PREPEND = 0x0f;\r\n    public static final byte STAT = 0x10;\r\n    public static final byte SETQ = 0x11;\r\n", "    /**\r\n     * Caches a successful resolution.\r\n     */\r\n    abstract void cache(String hostname, DnsRecord[] additionals,\r\n                        DnsRecord result, T convertedResult);\r\n", "    }\r\n\r\n    private void sendQuery(final DnsQuery query, final boolean flush, final ChannelPromise writePromise) {\r\n        if (parent.channelFuture.isDone()) {\r\n            writeQuery(query, flush, writePromise);\r\n", "    @Override\r\n    public DnsServerAddressStream get(String hostname) {\r\n        List<? extends DnsCacheEntry> entries = cache.get(hostname, EMPTY);\r\n        if (entries == null || entries.isEmpty()) {\r\n            return null;\r\n", "                }\r\n            }\r\n\r\n            final T converted = convertRecord(r, hostname, additionals, parent.executor());\r\n            if (converted == null) {\r\n", "                            Promise<List<T>> promise) {\r\n        try {\r\n            final DnsResponse res = envelope.content();\r\n            final DnsResponseCode code = res.code();\r\n            if (code == DnsResponseCode.NOERROR) {\r\n", "                        ns2Name + '.', DefaultDnsServerAddressStreamProvider.DNS_PORT);\r\n\r\n                if (invalidNsFirst) {\r\n                    assertEquals(ns2Address, cached.next());\r\n                    assertEquals(ns1Address, cached.next());\r\n", "                }\r\n\r\n                resetDecoder();\r\n                state = State.READ_HEADER;\r\n                return;\r\n", "            assertThat(resolver.isRecursionDesired(), is(true));\r\n\r\n            final Map<String, Future<List<DnsRecord>>> futures = new LinkedHashMap<String, Future<List<DnsRecord>>>();\r\n            for (String name : DOMAINS) {\r\n                if (EXCLUSIONS_QUERY_MX.contains(name)) {\r\n", "     * @param decodeIdn if should get decoded\r\n     * @return {@code this}\r\n     */\r\n    public DnsNameResolverBuilder decodeIdn(boolean decodeIdn) {\r\n        this.decodeIdn = decodeIdn;\r\n", "\r\n        @Override\r\n        public AddressedEnvelope<DnsResponse, InetSocketAddress> touch(Object hint) {\r\n            response.touch(hint);\r\n            return this;\r\n", "                final List<T> result = filterResults(finalResult);\r\n                if (!DnsNameResolver.trySuccess(promise, result)) {\r\n                    for (T item : result) {\r\n                        ReferenceCountUtil.safeRelease(item);\r\n                    }\r\n", "        };\r\n        TestDnsServer nonCompliantDnsServer = new TestDnsServer(arbitrarilyOrderedStore);\r\n        nonCompliantDnsServer.start();\r\n        try {\r\n            DnsNameResolver resolver = newResolver(types)\r\n", "            final DnsRecord r = response.recordAt(DnsSection.ANSWER, i);\r\n            final DnsRecordType type = r.type();\r\n            if (type != DnsRecordType.CNAME) {\r\n                continue;\r\n            }\r\n", "\r\n        final DnsNameResolver resolver = builder.resolveCache(NoopDnsCache.INSTANCE)\r\n                .authoritativeDnsServerCache(authoritativeDnsServerCache)\r\n                .nameServerProvider(new SingletonDnsServerAddressStreamProvider(testDnsServer.localAddress())).build();\r\n\r\n", "     */\r\n    public DefaultBinaryMemcacheResponse() {\r\n        this(null, null);\r\n    }\r\n\r\n", "\r\nimport java.net.InetSocketAddress;\r\n\r\nfinal class DatagramDnsQueryContext extends DnsQueryContext {\r\n\r\n", "        ByteBuf headerBlock = Unpooled.buffer(21);\r\n        headerBlock.writeInt(1);\r\n        headerBlock.writeInt(4);\r\n        headerBlock.writeBytes(nameBytes);\r\n        headerBlock.writeInt(5);\r\n", "                    .resolvedAddressTypes(ResolvedAddressTypes.IPV4_PREFERRED).build();\r\n\r\n            assertResolvedAddress(resolver.resolve(firstName).syncUninterruptibly().getNow(), ipv4Addr, firstName);\r\n        } finally {\r\n            dnsServer2.stop();\r\n", "    public void createDecoder() {\r\n        decoder = new SpdyFrameDecoder(SpdyVersion.SPDY_3_1, testDelegate);\r\n    }\r\n\r\n    @After\r\n", "        assertThat(written.readByte(), is((byte) 0x80));\r\n        assertThat(written.readByte(), is((byte) 0x00));\r\n        written.release();\r\n    }\r\n\r\n", "     * @return the address as the result of the resolution\r\n     */\r\n    public final Future<InetAddress> resolve(String inetHost, Iterable<DnsRecord> additionals) {\r\n        return resolve(inetHost, additionals, executor().<InetAddress>newPromise());\r\n    }\r\n", "        if (!(record instanceof DnsRawRecord)) {\r\n            return null;\r\n        }\r\n        final ByteBuf content = ((ByteBufHolder) record).content();\r\n        final int contentLen = content.readableBytes();\r\n", "        this.b = checkNotNull(b, \"b\");\r\n    }\r\n\r\n    @Override\r\n    public DnsQueryLifecycleObserver newDnsQueryLifecycleObserver(DnsQuestion question) {\r\n", "            List<InetAddress> addresses = resolver.resolveAll(name).syncUninterruptibly().getNow();\r\n            assertEquals(1, addresses.size());\r\n            assertEquals(expectedAddr, addresses.get(0));\r\n\r\n            // We are resolving the local address, so we shouldn't make any queries.\r\n", "        @Override\r\n        public void readFrameError(String message) {\r\n            delegate.readFrameError(message);\r\n        }\r\n\r\n", "\r\n            // Make sure the record is for the questioned domain.\r\n            if (!recordName.equals(questionName)) {\r\n                Map<String, String> cnamesCopy = new HashMap<String, String>(cnames);\r\n                // Even if the record's name is not exactly same, it might be an alias defined in the CNAME records.\r\n", "        @Override\r\n        public ProtocolEncoder getEncoder(IoSession session) {\r\n            return new DnsUdpEncoder() {\r\n\r\n                @Override\r\n", "                                    final Throwable cause) {\r\n\r\n        // There are no queries left to try.\r\n        if (!completeEarly && !queriesInProgress.isEmpty()) {\r\n            queryLifecycleObserver.queryCancelled(allowedQueries);\r\n", "\r\n        return new DefaultDnsServerAddresses(\"sequential\", addresses) {\r\n            @Override\r\n            public DnsServerAddressStream stream() {\r\n                return new SequentialDnsServerAddressStream(addresses, 0);\r\n", "\r\n    private static void encodeDataFrameHeader(ByteBuf buffer, int streamId, byte flags, int length) {\r\n        buffer.writeInt(streamId & 0x7FFFFFFF);\r\n        buffer.writeByte(flags);\r\n        buffer.writeMedium(length);\r\n", "            assertEquals(dnsServer1Address, writtenEvent.dnsServerAddress);\r\n            QueryFailedEvent failedEvent = (QueryFailedEvent) observer.events.poll();\r\n\r\n            observer = lifecycleObserverFactory.observers.poll();\r\n            assertEquals(2, observer.events.size());\r\n", "    public void testUnresolvedReplacedByResolved() throws Exception {\r\n        InetSocketAddress unresolved = InetSocketAddress.createUnresolved(\"ns1\", 53);\r\n        InetSocketAddress resolved1 = new InetSocketAddress(\r\n                InetAddress.getByAddress(\"ns2\", new byte[] { 10, 0, 0, 2 }), 53);\r\n        InetSocketAddress resolved2 = new InetSocketAddress(\r\n", "    }\r\n\r\n    @Override\r\n    public ByteBuf content() {\r\n        return content;\r\n", "\r\n            new DnsAddressResolveContext(parent, originalPromise, nameServerName, additionals,\r\n                                         parent.newNameServerAddressStream(nameServerName),\r\n                                         // Resolving the unresolved nameserver must be limited by allowedQueries\r\n                                         // so we eventually fail\r\n", "                        content = Unpooled.wrappedBuffer(hostsFileEntry.getAddress());\r\n                    }\r\n                } else if (hostsFileEntry instanceof Inet6Address) {\r\n                    if (type == DnsRecordType.AAAA) {\r\n                        content = Unpooled.wrappedBuffer(hostsFileEntry.getAddress());\r\n", "            newInstance.release();\r\n        }\r\n    }\r\n\r\n    private void assertResponseEquals(FullBinaryMemcacheResponse expected, ByteBuf expectedContent,\r\n", "    public void testSpdyRstStreamFrame() throws Exception {\r\n        short type = 3;\r\n        byte flags = 0;\r\n        int length = 8;\r\n        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;\r\n", "                private final DnsServerAddressStream stream = duplicate.duplicate();\r\n                private int i;\r\n\r\n                @Override\r\n                public boolean hasNext() {\r\n", "        volatile ScheduledFuture<?> expirationFuture;\r\n\r\n        Entries(String hostname) {\r\n            super(Collections.<E>emptyList());\r\n            this.hostname = hostname;\r\n", "\r\n    /**\r\n     * Create a new {@link DefaultBinaryMemcacheRequest} with the header, key and extras.\r\n     *\r\n     * @param key    the key to use.\r\n", "import io.netty.handler.codec.dns.DnsResponse;\r\nimport io.netty.handler.codec.dns.TcpDnsQueryEncoder;\r\nimport io.netty.handler.codec.dns.TcpDnsResponseDecoder;\r\nimport io.netty.resolver.HostsFileEntries;\r\nimport io.netty.resolver.HostsFileEntriesResolver;\r\n", "            doResolveAllUncached(hostname, additionals, promise, promise,\r\n                                 resolveCache, completeOncePreferredResolved);\r\n        }\r\n    }\r\n\r\n", "public interface FullMemcacheMessage extends MemcacheMessage, LastMemcacheContent {\r\n\r\n    @Override\r\n    FullMemcacheMessage copy();\r\n\r\n", "    @Override\r\n    void doSearchDomainQuery(String hostname, Promise<List<InetAddress>> nextPromise) {\r\n        // Query the cache for the hostname first and only do a query if we could not find it in the cache.\r\n        if (!DnsNameResolver.doResolveAllCached(\r\n                hostname, additionals, nextPromise, resolveCache, parent.resolvedInternetProtocolFamiliesUnsafe())) {\r\n", "                    DnsCacheEntry ns2Entry = ns2Cached.get(0);\r\n                    assertNotNull(ns2Entry.address());\r\n                    assertNull(ns2Entry.cause());\r\n                } else {\r\n                    // We should not even have tried to resolve the DNS name so this should be null.\r\n", "                        message.getAdditionalRecords().add(newARecord(ns3Address));\r\n                        message.getAdditionalRecords().add(newARecord(ns4Address));\r\n                        return message;\r\n                    }\r\n                }\r\n", "        decoder.decode(buf);\r\n        verify(delegate).readFrameError(anyString());\r\n        assertFalse(buf.isReadable());\r\n        buf.release();\r\n    }\r\n", "        decoder.decode(buf);\r\n        verify(delegate).readFrameError(anyString());\r\n        assertFalse(buf.isReadable());\r\n        buf.release();\r\n    }\r\n", "        decoder.decode(buf);\r\n        verify(delegate).readFrameError(anyString());\r\n        assertFalse(buf.isReadable());\r\n        buf.release();\r\n    }\r\n", "        decoder.decode(buf);\r\n        verify(delegate).readFrameError(anyString());\r\n        assertFalse(buf.isReadable());\r\n        buf.release();\r\n    }\r\n", "    public BinaryMemcacheRequest touch(Object hint) {\r\n        super.touch(hint);\r\n        return this;\r\n    }\r\n\r\n", "        short type = 1;\r\n        byte flags = 0;\r\n        int length = 10;\r\n        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;\r\n        int associatedToStreamId = 0; // independent of all other streams\r\n", "                queryMx(resolver, futures, name);\r\n            }\r\n\r\n            for (Entry<String, Future<AddressedEnvelope<DnsResponse, InetSocketAddress>>> e : futures.entrySet()) {\r\n                String hostname = e.getKey();\r\n", "        int tries = 0;\r\n\r\n        synchronized (contexts) {\r\n            for (;;) {\r\n                if (!contexts.containsKey(id)) {\r\n", "            return castPromise.setFailure(e);\r\n        }\r\n    }\r\n\r\n    @SuppressWarnings(\"unchecked\")\r\n", "                                server.next = serverName.next;\r\n                                serverName.next = server;\r\n                                serverName = server;\r\n                                serverName.update(parent.newRedirectServerAddress(address));\r\n\r\n", "\r\n    @Override\r\n    public void queryFailed(Throwable cause) {\r\n        try {\r\n            a.queryFailed(cause);\r\n", "\r\n        assertThat(request.content().readableBytes(), is(8));\r\n        assertThat(request.content().readByte(), is((byte) 0x01));\r\n        assertThat(request.content().readByte(), is((byte) 0x02));\r\n        request.release();\r\n", "        public LastMemcacheContent touch() {\r\n            return this;\r\n        }\r\n\r\n        @Override\r\n", "    public DnsServerAddressStream get(String hostname) {\r\n        checkNotNull(hostname, \"hostname\");\r\n\r\n        List<? extends InetSocketAddress> addresses = resolveCache.get(hostname);\r\n        if (addresses == null || addresses.isEmpty()) {\r\n", "    private static final String SORTLIST_ROW_LABEL = \"sortlist\";\r\n    private static final String OPTIONS_ROW_LABEL = \"options \";\r\n    private static final String OPTIONS_ROTATE_FLAG = \"rotate\";\r\n    private static final String DOMAIN_ROW_LABEL = \"domain\";\r\n    private static final String SEARCH_ROW_LABEL = \"search\";\r\n", "\r\n            final Promise<List<T>> searchDomainPromise = parent.executor().newPromise();\r\n            searchDomainPromise.addListener(new FutureListener<List<T>>() {\r\n                private int searchDomainIdx = initialSearchDomainIdx;\r\n                @Override\r\n", "        if (maxTtl != null && minTtl != null) {\r\n            copiedBuilder.ttl(minTtl, maxTtl);\r\n        }\r\n\r\n        if (negativeTtl != null) {\r\n", "\r\n    private static InetSocketAddress unresolved(InetSocketAddress address) {\r\n        return InetSocketAddress.createUnresolved(address.getHostString(), address.getPort());\r\n    }\r\n\r\n", "@UnstableApi\r\npublic class DefaultFullBinaryMemcacheResponse extends DefaultBinaryMemcacheResponse\r\n    implements FullBinaryMemcacheResponse {\r\n\r\n    private final ByteBuf content;\r\n", "            this.key.release();\r\n        }\r\n        this.key = key;\r\n        short oldKeyLength = keyLength;\r\n        keyLength = key == null ? 0 : (short) key.readableBytes();\r\n", "        short type = 1;\r\n        byte flags = 0;\r\n        int length = 10;\r\n        int headerBlockLength = 1024;\r\n        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;\r\n", "        buf.writeByte(0);\r\n\r\n        decoder.decode(buf);\r\n        verify(delegate).readFrameError(anyString());\r\n        assertFalse(buf.isReadable());\r\n", "        buf.writeInt(statusCode);\r\n\r\n        decoder.decode(buf);\r\n        verify(delegate).readFrameError(anyString());\r\n        assertFalse(buf.isReadable());\r\n", "                return entry.getHostString().equalsIgnoreCase(otherEntry.getHostString());\r\n            }\r\n            return entry.getHostName().equalsIgnoreCase(otherEntry.getHostName());\r\n        }\r\n\r\n", "        @Override\r\n        public InetSocketAddress get(int index) {\r\n            if (addresses == null) {\r\n                DnsServerAddressStream stream = duplicate.duplicate();\r\n                addresses = new ArrayList<InetSocketAddress>(size());\r\n", "    }\r\n\r\n    @Override\r\n    public DnsServerAddressStream nameServerAddressStream(String hostname) {\r\n        return DEFAULT_NAME_SERVERS.stream();\r\n", "import org.apache.mina.core.buffer.IoBuffer;\r\nimport org.apache.mina.core.session.IoSession;\r\nimport org.apache.mina.filter.codec.ProtocolCodecFactory;\r\nimport org.apache.mina.filter.codec.ProtocolCodecFilter;\r\nimport org.apache.mina.filter.codec.ProtocolDecoder;\r\n", "        i = seq.stream();\r\n        assertNext(i, ADDR1);\r\n        assertNext(i, ADDR2);\r\n        assertNext(i, ADDR3);\r\n        assertNext(i, ADDR1);\r\n", "/**\r\n * The encoder part which takes care of encoding the request headers.\r\n */\r\n@UnstableApi\r\npublic class BinaryMemcacheRequestEncoder\r\n", "        byte flags = 0x01; // FLAG_FIN\r\n        int length = 10;\r\n        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;\r\n        int associatedToStreamId = RANDOM.nextInt() & 0x7FFFFFFF;\r\n        byte priority = (byte) (RANDOM.nextInt() & 0x07);\r\n", "                .authoritativeDnsServerCache(cache)\r\n                .resolveCache(cache)\r\n                .nameServerProvider(new SingletonDnsServerAddressStreamProvider(\r\n                        new InetSocketAddress(NetUtil.LOCALHOST, 12345)));\r\n        DnsNameResolver resolver = builder.build();\r\n", "        secondDnsServerShouldBeUsedBeforeCNAME(false);\r\n    }\r\n\r\n    @Test(timeout = DEFAULT_TEST_TIMEOUT_MS)\r\n    public void secondDnsServerShouldBeUsedBeforeCNAMEFirstServerFailResolve() throws IOException {\r\n", " * cause of resolution failure.\r\n */\r\npublic final class LoggingDnsQueryLifeCycleObserverFactory implements DnsQueryLifecycleObserverFactory {\r\n    private static final InternalLogger DEFAULT_LOGGER =\r\n            InternalLoggerFactory.getInstance(LoggingDnsQueryLifeCycleObserverFactory.class);\r\n", "    }\r\n\r\n    @Override\r\n    public ShuffledDnsServerAddressStream duplicate() {\r\n        return new ShuffledDnsServerAddressStream(addresses, i);\r\n", "import java.util.concurrent.TimeUnit;\r\nimport java.util.concurrent.atomic.AtomicLong;\r\n\r\n/**\r\n * Utility methods related to {@link DnsServerAddressStreamProvider}.\r\n", "    public DnsNameResolverBuilder searchDomains(Iterable<String> searchDomains) {\r\n        checkNotNull(searchDomains, \"searchDomains\");\r\n\r\n        final List<String> list = new ArrayList<String>(4);\r\n\r\n", "    }\r\n\r\n    @Test\r\n    public void testNonCachedResolve() throws Exception {\r\n        DnsNameResolver resolver = newNonCachedResolver(ResolvedAddressTypes.IPV4_ONLY).build();\r\n", "                        message.getAnswerRecords().clear();\r\n                        message.getAuthorityRecords().add(TestDnsServer.newNsRecord(domain, ns1Name));\r\n                        message.getAuthorityRecords().add(TestDnsServer.newNsRecord(domain, ns2Name));\r\n                    }\r\n                }\r\n", "    }\r\n\r\n    private static final class TestDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\r\n        final Queue<Object> events = new ArrayDeque<Object>();\r\n        final DnsQuestion question;\r\n", "     * This test makes sure that large content is emitted in chunks.\r\n     */\r\n    @Test\r\n    public void shouldDecodeRequestWithChunkedContent() {\r\n        int smallBatchSize = 2;\r\n", "        // Respect /etc/hosts as well if the record type is A or AAAA.\r\n        final DnsRecordType type = question.type();\r\n        final String hostname = question.name();\r\n\r\n        if (type == DnsRecordType.A || type == DnsRecordType.AAAA) {\r\n", "\r\n        f = buildFile(\"search localdomain\\n\" +\r\n            \"nameserver 127.0.0.11\\n\" +\r\n            \"options ndots:123 foo:goo\\n\");\r\n        assertEquals(123, parseEtcResolverOptions(f).ndots());\r\n", "        this.b = checkNotNull(b, \"b\");\r\n    }\r\n\r\n    @Override\r\n    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\r\n", "    }\r\n\r\n    @Override\r\n    public ByteBuf key() {\r\n        return key;\r\n", "        final ChannelFuture writeFuture = flush ? channel().writeAndFlush(query, writePromise) :\r\n                channel().write(query, writePromise);\r\n        if (writeFuture.isDone()) {\r\n            onQueryWriteCompletion(writeFuture);\r\n        } else {\r\n", "import java.util.concurrent.atomic.AtomicLong;\r\n\r\n/**\r\n * The client codec that combines the proper encoder and decoder.\r\n * <p/>\r\n", "        private final DnsResponse response;\r\n\r\n        AddressedEnvelopeAdapter(InetSocketAddress sender, InetSocketAddress recipient, DnsResponse response) {\r\n            this.sender = sender;\r\n            this.recipient = recipient;\r\n", "    }\r\n\r\n    @Override\r\n    DnsResolveContext<InetAddress> newResolverContext(DnsNameResolver parent, Promise<?> originalPromise,\r\n                                                      String hostname,\r\n", "    /**\r\n     * The response to the query didn't provide the expected response code, but it didn't return\r\n     * {@link DnsResponseCode#NXDOMAIN} so we may try to query again.\r\n     * @param code the unexpected response code.\r\n     * @return An observer for the new query which we may issue.\r\n", "     */\r\n    public DnsNameResolverBuilder channelFactory(ChannelFactory<? extends DatagramChannel> channelFactory) {\r\n        this.channelFactory = channelFactory;\r\n        return this;\r\n    }\r\n", "                                       DnsRecord[] additionals,\r\n                                       Promise<?> originalPromise,\r\n                                       Promise<List<InetAddress>> promise,\r\n                                       DnsCache resolveCache,\r\n                                       boolean completeEarlyIfPossible) {\r\n", "    @Override\r\n    MemcacheMessage retain(int increment);\r\n\r\n    @Override\r\n    MemcacheMessage touch();\r\n", "\r\n    private boolean query(String hostname, DnsRecordType type, DnsServerAddressStream dnsServerAddressStream,\r\n                          boolean flush, Promise<List<T>> promise) {\r\n        final DnsQuestion question;\r\n        try {\r\n", "        verify(delegate).readFrameError(anyString());\r\n        assertFalse(buf.isReadable());\r\n        buf.release();\r\n    }\r\n\r\n", "        verify(delegate).readFrameError(anyString());\r\n        assertFalse(buf.isReadable());\r\n        buf.release();\r\n    }\r\n\r\n", "        verify(delegate).readFrameError(anyString());\r\n        assertFalse(buf.isReadable());\r\n        buf.release();\r\n    }\r\n\r\n", "        verify(delegate).readFrameError(anyString());\r\n        assertFalse(buf.isReadable());\r\n        buf.release();\r\n    }\r\n\r\n", "    public void testResolveDecodeUnicode() {\r\n        testResolveUnicode(true);\r\n    }\r\n\r\n    @Test\r\n", "                            E entry = entries.get(i);\r\n                            // Only add old entry if the address is not the same as the one we try to add as well.\r\n                            // In this case we will skip it and just add the new entry as this may have\r\n                            // more up-to-date data and cancel the old after we were able to update the cache.\r\n                            if (!Cache.this.equals(e, entry)) {\r\n", "\r\n    private static final InternalLogger logger = InternalLoggerFactory.getInstance(DnsNameResolver.class);\r\n    private static final String LOCALHOST = \"localhost\";\r\n    private static final InetAddress LOCALHOST_ADDRESS;\r\n    private static final DnsRecord[] EMPTY_ADDITIONALS = new DnsRecord[0];\r\n", "    }\r\n\r\n    private static Map<String, DnsServerAddresses> parse(File... etcResolverFiles) throws IOException {\r\n        Map<String, DnsServerAddresses> domainToNameServerStreamMap =\r\n                new HashMap<String, DnsServerAddresses>(etcResolverFiles.length << 1);\r\n", "        DnsNameResolver resolver = newResolver(group).build();\r\n        try {\r\n            // Same as:\r\n            // # /.bind-9.9.3-edns/bin/dig @ns1.google.com www.google.es +client=157.88.0.0/24\r\n            Future<List<InetAddress>> future = resolver.resolveAll(\"www.google.es\",\r\n", "            return DefaultDnsServerAddressStreamProvider.defaultAddressList();\r\n        }\r\n\r\n        return list;\r\n    }\r\n", "        });\r\n        dnsServer2.start();\r\n        try {\r\n            final Set<String> overriddenHostnames = new HashSet<String>();\r\n            for (String name : DOMAINS) {\r\n", "        final String lastName = \"lastname.com\";\r\n        final String ipv4Addr = \"1.2.3.4\";\r\n        final TestDnsServer dnsServer2 = new TestDnsServer(new RecordStore() {\r\n            @Override\r\n            public Set<ResourceRecord> getRecords(QuestionRecord question) {\r\n", "        private Iterator<InetAddress> resolved;\r\n\r\n        CombinedDnsServerAddressStream(InetSocketAddress replaced, List<InetAddress> resolvedAddresses,\r\n                                       DnsServerAddressStream originalStream) {\r\n            this.replaced = replaced;\r\n", "     * @param extras the extras to use.\r\n     */\r\n    public DefaultFullBinaryMemcacheResponse(ByteBuf key, ByteBuf extras) {\r\n        this(key, extras, Unpooled.buffer(0));\r\n    }\r\n", "                    Promise<AddressedEnvelope<DnsResponse, InetSocketAddress>> promise) {\r\n\r\n        this.parent = checkNotNull(parent, \"parent\");\r\n        this.nameServerAddr = checkNotNull(nameServerAddr, \"nameServerAddr\");\r\n        this.question = checkNotNull(question, \"question\");\r\n", "     */\r\n    public LoggingDnsQueryLifeCycleObserverFactory(String name, LogLevel level) {\r\n        this.level = checkAndConvertLevel(level);\r\n        logger = InternalLoggerFactory.getInstance(checkNotNull(name, \"name\"));\r\n    }\r\n", "        } else {\r\n            qCtx = null;\r\n        }\r\n\r\n        return qCtx;\r\n", "    public void testIllegalSpdySynReplyFrameStreamId() throws Exception {\r\n        short type = 2;\r\n        byte flags = 0;\r\n        int length = 4;\r\n        int streamId = 0; // invalid stream identifier\r\n", "\r\n    @AfterClass\r\n    public static void destroy() {\r\n        dnsServer.stop();\r\n        group.shutdownGracefully();\r\n", "        final String ipv6Address = \"0:0:0:0:0:0:1:1\";\r\n        final String ipv4Address = \"1.1.1.1\";\r\n        if (types == ResolvedAddressTypes.IPV4_PREFERRED) {\r\n            records.add(Collections.singleton(TestDnsServer.newAddressRecord(name, RecordType.AAAA, ipv6Address)));\r\n            records.add(Collections.singleton(TestDnsServer.newAddressRecord(name, RecordType.A, ipv4Address)));\r\n", "     * @param a The {@link DnsQueryLifecycleObserverFactory} that will receive events first.\r\n     * @param b The {@link DnsQueryLifecycleObserverFactory} that will receive events second.\r\n     */\r\n    public BiDnsQueryLifecycleObserverFactory(DnsQueryLifecycleObserverFactory a, DnsQueryLifecycleObserverFactory b) {\r\n        this.a = checkNotNull(a, \"a\");\r\n", "        boolean result = channel.writeOutbound(request);\r\n        assertThat(result, is(true));\r\n\r\n        ByteBuf written = channel.readOutbound();\r\n        assertThat(written.readableBytes(), is(DEFAULT_HEADER_SIZE));\r\n", "        this.allowedQueries = allowedQueries;\r\n    }\r\n\r\n    static final class DnsResolveContextException extends RuntimeException {\r\n\r\n", "    }\r\n\r\n    @Override\r\n    public FullBinaryMemcacheRequest touch() {\r\n        super.touch();\r\n", "        try {\r\n            assertCopy(request, request.content(), newInstance);\r\n        } finally {\r\n            request.release();\r\n            newInstance.release();\r\n", "    @Override\r\n    boolean isCompleteEarly(DnsRecord resolved) {\r\n        return false;\r\n    }\r\n\r\n", "                    ipv4Preferred ? ResolvedAddressTypes.IPV4_ONLY : ResolvedAddressTypes.IPV6_ONLY, true,\r\n                    10, true, 4096, false, HostsFileEntriesResolver.DEFAULT,\r\n                    new SequentialDnsServerAddressStreamProvider(dnsServer2.localAddress(), dnsServer3.localAddress()),\r\n                    DnsNameResolver.DEFAULT_SEARCH_DOMAINS, 0, true) {\r\n                @Override\r\n", "        if (contentLen != INADDRSZ4 && contentLen != INADDRSZ6) {\r\n            return null;\r\n        }\r\n\r\n        final byte[] addrBytes = new byte[contentLen];\r\n", "@UnstableApi\r\npublic class DefaultFullBinaryMemcacheRequest extends DefaultBinaryMemcacheRequest\r\n    implements FullBinaryMemcacheRequest {\r\n\r\n    private final ByteBuf content;\r\n", "    }\r\n\r\n    @Test\r\n    public void defaultValueReturnedIfAttemptsOptionsIsNotPresent() throws IOException {\r\n        File f = buildFile(\"search localdomain\\n\" +\r\n", "            return false;\r\n        }\r\n\r\n        Throwable cause = cachedEntries.get(0).cause();\r\n        if (cause == null) {\r\n", "                supportsARecords = false;\r\n                resolveRecordTypes = IPV6_ONLY_RESOLVED_RECORD_TYPES;\r\n                resolvedInternetProtocolFamilies = IPV6_ONLY_RESOLVED_PROTOCOL_FAMILIES;\r\n                break;\r\n            case IPV6_PREFERRED:\r\n", "\r\n                if (++tries >= maxTries) {\r\n                    throw new IllegalStateException(\"query ID space exhausted: \" + qCtx.question());\r\n                }\r\n            }\r\n", "            cache.cache(\"netty.io\", resolved1, 1, loop);\r\n            cache.cache(\"netty.io\", resolved2, 10000, loop);\r\n\r\n            Throwable error = loop.schedule(new Callable<Throwable>() {\r\n                @Override\r\n", "        try {\r\n            List<InetAddress> resolved = resolver.resolveAll(expected.getHostName()).syncUninterruptibly().getNow();\r\n            assertEquals(1, resolved.size());\r\n            assertEquals(expected, resolved.get(0));\r\n\r\n", "        } else {\r\n            try {\r\n                if (resolveAll) {\r\n                    @SuppressWarnings(\"unchecked\")\r\n                    final Promise<List<T>> castPromise = (Promise<List<T>>) promise; // U is List<T>\r\n", "\r\n    @Test\r\n    public void testSequential() {\r\n        DnsServerAddresses seq = DnsServerAddresses.sequential(ADDR1, ADDR2, ADDR3);\r\n        assertThat(seq.stream(), is(not(sameInstance(seq.stream()))));\r\n", "                    for (int i = 0; i < size; i++) {\r\n                        exceptions.add(resolveNonExistentDomain(resolver));\r\n                        if (isInterrupted()) {\r\n                            break;\r\n                        }\r\n", "     * Increases the reference count by the specified {@code increment}.\r\n     */\r\n    @Override\r\n    BinaryMemcacheMessage retain(int increment);\r\n\r\n", "    @Override\r\n    public ByteBuf content() {\r\n        return content;\r\n    }\r\n\r\n", "    @Override\r\n    public ByteBuf content() {\r\n        return content;\r\n    }\r\n\r\n", "    public void testTruncatedWithTcpFallbackBecauseOfMtu() throws IOException {\r\n        testTruncated0(true, true);\r\n    }\r\n\r\n    private static DnsMessageModifier modifierFrom(DnsMessage message) {\r\n", "        buf.release();\r\n    }\r\n\r\n    @Test\r\n    public void testReservedSpdyRstStreamFrameBits() throws Exception {\r\n", "            cache.clear();\r\n            assertNull(cache.get(\"y.netty.io\"));\r\n        } finally {\r\n            group.shutdownGracefully();\r\n        }\r\n", "        this.remoteAddress = validateRemoteAddress(remoteAddress);\r\n        this.question = validateQuestion(question);\r\n    }\r\n\r\n    public DnsNameResolverException(\r\n", "        int statusCode = RANDOM.nextInt() | 0x01;\r\n\r\n        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeControlFrameHeader(buf, type, flags, length);\r\n        buf.writeInt(streamId);\r\n", "import io.netty.util.internal.UnstableApi;\r\n\r\n/**\r\n * The {@link MemcacheContent} which signals the end of the content batch.\r\n * <p/>\r\n", "    public void testLastSpdySynReplyFrame() throws Exception {\r\n        short type = 2;\r\n        byte flags = 0x01; // FLAG_FIN\r\n        int length = 4;\r\n        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;\r\n", "            public Set<ResourceRecord> getRecords(QuestionRecord question) {\r\n                if (question.getDomainName().equals(secondName)) {\r\n                    ResourceRecordModifier rm = new ResourceRecordModifier();\r\n                    rm.setDnsClass(RecordClass.IN);\r\n                    rm.setDnsName(question.getDomainName());\r\n", "        if (first == null) {\r\n            // Nothing in the cache at all\r\n            return name;\r\n        }\r\n\r\n", "                            return cache.get(hostname);\r\n                        }\r\n\r\n                        @Override\r\n                        public void cache(String hostname, String cname, long originalTtl, EventLoop loop) {\r\n", "    }\r\n\r\n    @Override\r\n    public FullBinaryMemcacheResponse touch() {\r\n        super.touch();\r\n", "    public final Future<InetAddress> resolve(String inetHost, Iterable<DnsRecord> additionals,\r\n                                             Promise<InetAddress> promise) {\r\n        checkNotNull(promise, \"promise\");\r\n        DnsRecord[] additionalsArray = toArray(additionals, true);\r\n        try {\r\n", "    private static final RuntimeException NO_MATCHING_RECORD_QUERY_FAILED_EXCEPTION =\r\n            DnsResolveContextException.newStatic(\"No matching record type found\",\r\n            DnsResolveContext.class, \"onResponseAorAAAA(..)\");\r\n    private static final RuntimeException UNRECOGNIZED_TYPE_QUERY_FAILED_EXCEPTION =\r\n            DnsResolveContextException.newStatic(\"Response type was unrecognized\",\r\n", "        assertTrue(channel.writeOutbound(request, content1, content2));\r\n\r\n        assertThat(channel.outboundMessages().size(), is(3));\r\n        assertTrue(channel.writeInbound(channel.readOutbound(), channel.readOutbound(), channel.readOutbound()));\r\n\r\n", "                    private final AtomicLong lastRefresh = new AtomicLong(System.nanoTime());\r\n\r\n                    @Override\r\n                    public DnsServerAddressStream nameServerAddressStream(String hostname) {\r\n                        long last = lastRefresh.get();\r\n", "    public int totalBodyLength() {\r\n        return totalBodyLength;\r\n    }\r\n\r\n    @Override\r\n", "                                    DnsRecord[] additionals,\r\n                                    Promise<InetAddress> promise,\r\n                                    DnsCache resolveCache) {\r\n        final List<? extends DnsCacheEntry> cachedEntries = resolveCache.get(hostname, additionals);\r\n        if (cachedEntries == null || cachedEntries.isEmpty()) {\r\n", "            followCname(question, resolved, queryLifecycleObserver, promise);\r\n        } else {\r\n            queryLifecycleObserver.queryFailed(CNAME_NOT_FOUND_QUERY_FAILED_EXCEPTION);\r\n        }\r\n    }\r\n", "            ch.close();\r\n        }\r\n    }\r\n\r\n    @Override\r\n", "    }\r\n\r\n    @Test\r\n    public void searchDomainsPrecedence() throws IOException {\r\n        File f = buildFile(\"domain linecorp.local\\n\" +\r\n", "        private final Promise<Channel> channelActivePromise;\r\n\r\n        DnsResponseHandler(Promise<Channel> channelActivePromise) {\r\n            this.channelActivePromise = channelActivePromise;\r\n        }\r\n", "\r\n            DnsResponse response = envelope.content();\r\n            assertNotNull(response);\r\n\r\n            assertEquals(DnsResponseCode.NOERROR, response.code());\r\n", "        }\r\n\r\n        @Override\r\n        public int size() {\r\n            return originalStream.size() + resolvedAddresses.size() - 1;\r\n", "        assertNext(i, ADDR1);\r\n        assertNext(i, ADDR2);\r\n        assertNext(i, ADDR3);\r\n\r\n        i = seq.stream();\r\n", "            assertEntry(entries.get(0), addr1);\r\n            assertEntry(entries.get(1), addr2);\r\n\r\n            Exception exception = new Exception();\r\n            cache.cache(\"netty.io\", null, exception, loop);\r\n", "            // If an empty hostname is used we should use \"localhost\", just like InetAddress.getByName(...) does.\r\n            promise.setSuccess(loopbackAddress());\r\n            return;\r\n        }\r\n        final byte[] bytes = NetUtil.createByteArrayFromIpAddressString(inetHost);\r\n", "    public DnsNameResolverBuilder maxQueriesPerResolve(int maxQueriesPerResolve) {\r\n        this.maxQueriesPerResolve = maxQueriesPerResolve;\r\n        return this;\r\n    }\r\n\r\n", "    }\r\n\r\n    @Override\r\n    protected boolean isContentMessage(MemcacheObject msg) throws Exception {\r\n        return msg instanceof MemcacheContent;\r\n", "    final DnsRecordType[] resolveRecordTypes() {\r\n        return resolveRecordTypes;\r\n    }\r\n\r\n    final boolean isDecodeIdn() {\r\n", "\r\n    private static FullBinaryMemcacheRequest toFullRequest(BinaryMemcacheRequest request, ByteBuf content) {\r\n        ByteBuf key = request.key() == null ? null : request.key().retain();\r\n        ByteBuf extras = request.extras() == null ? null : request.extras().retain();\r\n        DefaultFullBinaryMemcacheRequest fullRequest =\r\n", "    private static final String PORT_ROW_LABEL = \"port\";\r\n\r\n    private final DnsServerAddresses defaultNameServerAddresses;\r\n    private final Map<String, DnsServerAddresses> domainToNameServerStreamMap;\r\n\r\n", "            }\r\n\r\n            assertQueryObserver(resolver, AAAA);\r\n        } finally {\r\n            resolver.close();\r\n", "                @Override\r\n                public void decode(IoSession session, IoBuffer in, ProtocolDecoderOutput out) throws IOException {\r\n                    DnsMessage message = decoder.decode(in);\r\n                    if (dropAAAArecords) {\r\n                        for (QuestionRecord record: message.getQuestionRecords()) {\r\n", "\r\n            queryLifecycleObserver.queryFailed(NAME_SERVERS_EXHAUSTED_EXCEPTION);\r\n\r\n            // .. and we could not find any expected records.\r\n\r\n", "                NoopDnsCache.INSTANCE, // resolveCache\r\n                NoopAuthoritativeDnsServerCache.INSTANCE, // authoritativeDnsServerCache\r\n                NoopDnsQueryLifecycleObserverFactory.INSTANCE, // dnsQueryLifecycleObserverFactory\r\n                100, // queryTimeoutMillis\r\n                null, // resolvedAddressTypes, see https://github.com/netty/netty/pull/8445\r\n", "        buf.writeByte(msg.opcode());\r\n        buf.writeShort(msg.keyLength());\r\n        buf.writeByte(msg.extrasLength());\r\n        buf.writeByte(msg.dataType());\r\n        buf.writeShort(msg.status());\r\n", "                                    String domainName,\r\n                                    DnsServerAddresses addresses) {\r\n        DnsServerAddresses existingAddresses = domainToNameServerStreamMap.put(domainName, addresses);\r\n        if (existingAddresses != null) {\r\n            domainToNameServerStreamMap.put(domainName, existingAddresses);\r\n", "     * @param status the status to set.\r\n     */\r\n    BinaryMemcacheResponse setStatus(short status);\r\n\r\n    @Override\r\n", "    }\r\n\r\n    @Override\r\n    InetAddress convertRecord(DnsRecord record, String hostname, DnsRecord[] additionals, EventLoop eventLoop) {\r\n        return decodeAddress(record, hostname, parent.isDecodeIdn());\r\n", "     * Set the list of search domains of the resolver.\r\n     *\r\n     * @param searchDomains the search domains\r\n     * @return {@code this}\r\n     */\r\n", "            key2.release();\r\n            extras2.release();\r\n            message.release();\r\n        }\r\n    }\r\n", "                            DnsRecord[] additionals, DnsServerAddressStream nameServerAddrs, int allowedQueries) {\r\n        this(parent, originalPromise, question.name(), question.dnsClass(),\r\n             new DnsRecordType[] { question.type() },\r\n             additionals, nameServerAddrs, allowedQueries);\r\n    }\r\n", "import java.util.List;\r\nimport java.util.concurrent.ConcurrentMap;\r\n\r\nimport static io.netty.util.internal.ObjectUtil.checkNotNull;\r\n\r\n", "\r\n        assertThat(request, instanceOf(FullBinaryMemcacheRequest.class));\r\n        assertThat(request, notNullValue());\r\n        assertThat(request.key(), notNullValue());\r\n        assertThat(request.extras(), nullValue());\r\n", "\r\nimport java.net.InetSocketAddress;\r\nimport java.util.concurrent.TimeUnit;\r\n\r\nimport static io.netty.util.internal.ObjectUtil.checkNotNull;\r\n", "     */\r\n    DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code);\r\n\r\n    /**\r\n     * The following criteria are possible:\r\n", "     *\r\n     * @param recursionDesired true if recursion is desired\r\n     * @return {@code this}\r\n     */\r\n    public DnsNameResolverBuilder recursionDesired(boolean recursionDesired) {\r\n", "        final InetSocketAddress ns0Address = new InetSocketAddress(\r\n                InetAddress.getByAddress(ns0Name, new byte[] { 10, 1, 0, 1 }),\r\n                DefaultDnsServerAddressStreamProvider.DNS_PORT);\r\n        final InetSocketAddress ns1Address = new InetSocketAddress(\r\n                InetAddress.getByAddress(ns1Name, new byte[] { 10, 0, 0, 1 }),\r\n", "            }\r\n        }\r\n    }\r\n\r\n    static final class MapRecordStoreA implements RecordStore {\r\n", "    private final DnsRecordType[] expectedTypes;\r\n    final DnsRecord[] additionals;\r\n\r\n    private final Set<Future<AddressedEnvelope<DnsResponse, InetSocketAddress>>> queriesInProgress =\r\n            Collections.newSetFromMap(\r\n", "        response.setExtrasLength((byte) 34);\r\n        response.setDataType((byte) 43);\r\n        response.setTotalBodyLength(345);\r\n        response.setOpaque(3);\r\n        response.setCas(345345L);\r\n", "    }\r\n\r\n    /**\r\n     * Parse a file of the format <a href=\"https://linux.die.net/man/5/resolver\">/etc/resolv.conf</a> and return options\r\n     * of interest, namely: timeout, attempts and ndots.\r\n", "        Future<InetAddress> result = resolver.resolve(\"doesnotexist.netty.io\").awaitUninterruptibly();\r\n        Throwable cause = result.cause();\r\n        assertTrue(cause instanceof UnknownHostException);\r\n        assertTrue(cause.getCause() instanceof DnsNameResolverTimeoutException);\r\n        assertTrue(DnsNameResolver.isTimeoutError(cause));\r\n", "                cnameCache,\r\n                authoritativeDnsServerCache,\r\n                dnsQueryLifecycleObserverFactory,\r\n                queryTimeoutMillis,\r\n                resolvedAddressTypes,\r\n", "    private static DnsServerAddresses shuffled0(List<InetSocketAddress> addresses) {\r\n        if (addresses.size() == 1) {\r\n            return singleton(addresses.get(0));\r\n        }\r\n\r\n", "     */\r\n    public UnixResolverDnsServerAddressStreamProvider(String etcResolvConf, String etcResolverDir) throws IOException {\r\n        this(etcResolvConf == null ? null : new File(etcResolvConf),\r\n             etcResolverDir == null ? null : new File(etcResolverDir).listFiles());\r\n    }\r\n", "    }\r\n\r\n    @Override\r\n    public FullBinaryMemcacheResponse replace(ByteBuf content) {\r\n        ByteBuf key = key();\r\n", "            }\r\n\r\n            assertThat(exceptions, hasSize(size));\r\n        } finally {\r\n            resolver.close();\r\n", "        } catch (Exception e) {\r\n            if (logger.isDebugEnabled()) {\r\n                logger.debug(\"failed to parse {} and/or {}\", ETC_RESOLV_CONF_FILE, ETC_RESOLVER_DIR, e);\r\n            }\r\n            return DefaultDnsServerAddressStreamProvider.INSTANCE;\r\n", "                    0, extras.readableBytes(), 0);\r\n            testSettingLengths(new DefaultFullBinaryMemcacheRequest(key.retain(), null),\r\n                    key.readableBytes(), 0, 0);\r\n            testSettingLengths(new DefaultFullBinaryMemcacheRequest(null, null), 0, 0, 0);\r\n            testSettingLengths(new DefaultFullBinaryMemcacheRequest(key.retain(), extras.retain(), content.retain()),\r\n", "\r\n    private final long queryTimeoutMillis;\r\n    private final int maxQueriesPerResolve;\r\n    private final ResolvedAddressTypes resolvedAddressTypes;\r\n    private final InternetProtocolFamily[] resolvedInternetProtocolFamilies;\r\n", "    public void testSpdyDataFrame() throws Exception {\r\n        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;\r\n        byte flags = 0;\r\n        int length = 1024;\r\n\r\n", "    private static FullBinaryMemcacheResponse toFullResponse(BinaryMemcacheResponse response, ByteBuf content) {\r\n        ByteBuf key = response.key() == null ? null : response.key().retain();\r\n        ByteBuf extras = response.extras() == null ? null : response.extras().retain();\r\n        DefaultFullBinaryMemcacheResponse fullResponse =\r\n                new DefaultFullBinaryMemcacheResponse(key, extras, content);\r\n", "import org.junit.Test;\r\n\r\nimport java.util.concurrent.Callable;\r\nimport java.util.concurrent.TimeUnit;\r\n\r\n", "import io.netty.util.internal.UnstableApi;\r\n\r\n/**\r\n * The default {@link MemcacheObject} implementation.\r\n */\r\n", "            e = new DnsNameResolverTimeoutException(nameServerAddr, question(), buf.toString());\r\n        } else {\r\n            e = new DnsNameResolverException(nameServerAddr, question(), buf.toString(), cause);\r\n        }\r\n        return promise.tryFailure(e);\r\n", "            this.dnsServerAddress = dnsServerAddress;\r\n        }\r\n    }\r\n\r\n    private static final class QueryCancelledEvent {\r\n", "    }\r\n\r\n    @Override\r\n    public int size() {\r\n        return addresses.size();\r\n", "        Future<InetAddress> fut = resolver.resolve(inetHost);\r\n        assertTrue(fut.await(10, TimeUnit.SECONDS));\r\n        return fut.getNow().getHostAddress();\r\n    }\r\n\r\n", "        TestDnsQueryLifecycleObserver observer;\r\n        while ((observer = lifecycleObserverFactory.observers.poll()) != null) {\r\n            Object o = observer.events.poll();\r\n            if (o instanceof QueryCancelledEvent) {\r\n                assertEquals(cancelledType, observer.question.type());\r\n", "                    continue;\r\n                }\r\n\r\n                futures.put(name, resolver.resolveAll(new DefaultDnsQuestion(name, DnsRecordType.MX)));\r\n            }\r\n", "     * @param extras the extras to use.\r\n     */\r\n    public DefaultFullBinaryMemcacheRequest(ByteBuf key, ByteBuf extras) {\r\n        this(key, extras, Unpooled.buffer(0));\r\n    }\r\n", "                public void operationComplete(Future<List<T>> future) {\r\n                    Throwable cause = future.cause();\r\n                    if (cause == null) {\r\n                        final List<T> result = future.getNow();\r\n                        if (!promise.trySuccess(result)) {\r\n", "            // itself.\r\n            cache(hostname, additionals, unknownHostException);\r\n        } else {\r\n            unknownHostException.initCause(cause);\r\n        }\r\n", "\r\n    @Test\r\n    public void testResolveAllMx() {\r\n        final DnsNameResolver resolver = newResolver().build();\r\n        try {\r\n", "        testSearchDomainQueryFailureCompletes(ResolvedAddressTypes.IPV4_PREFERRED);\r\n    }\r\n\r\n    private void testSearchDomainQueryFailureCompletes(ResolvedAddressTypes types) {\r\n        DnsNameResolver resolver = newResolver()\r\n", "\r\n        DnsServerAddressStream i = seq.stream();\r\n        assertNext(i, ADDR1);\r\n        assertNext(i, ADDR2);\r\n        assertNext(i, ADDR3);\r\n", "            Promise<AddressedEnvelope<? extends DnsResponse, InetSocketAddress>> promise) {\r\n        assert !writePromise.isVoid();\r\n\r\n        final Promise<AddressedEnvelope<DnsResponse, InetSocketAddress>> castPromise = cast(\r\n                checkNotNull(promise, \"promise\"));\r\n", "    @Override\r\n    public BinaryMemcacheRequest setReserved(short reserved) {\r\n        this.reserved = reserved;\r\n        return this;\r\n    }\r\n", "                                newEntries.add(entry);\r\n                            } else {\r\n                                replacedEntry = entry;\r\n                                newEntries.add(e);\r\n\r\n", "        public LastMemcacheContent duplicate() {\r\n            return this;\r\n        }\r\n\r\n        @Override\r\n", "    private static DnsNameResolverBuilder newResolver(ResolvedAddressTypes resolvedAddressTypes) {\r\n        return newResolver()\r\n                .resolvedAddressTypes(resolvedAddressTypes);\r\n    }\r\n\r\n", "    abstract DnsResolveContext<T> newResolverContext(DnsNameResolver parent, Promise<?> originalPromise,\r\n                                                     String hostname,\r\n                                                     int dnsClass, DnsRecordType[] expectedTypes,\r\n                                                     DnsRecord[] additionals,\r\n                                                     DnsServerAddressStream nameServerAddrs, int allowedQueries);\r\n", "        builder.channelFactory(newChannelFactory);\r\n        assertEquals(channelFactory, copiedBuilder.channelFactory());\r\n        assertEquals(newChannelFactory, builder.channelFactory());\r\n    }\r\n\r\n", "    }\r\n\r\n    public static final byte GET = 0x00;\r\n    public static final byte SET = 0x01;\r\n    public static final byte ADD = 0x02;\r\n", "                            packet.content().writerIndex(packet.content().writerIndex() - 1);\r\n                        }\r\n                        ctx.fireChannelRead(msg);\r\n                    }\r\n                });\r\n", "        } else {\r\n            records.add(Collections.singleton(TestDnsServer.newAddressRecord(name, RecordType.A, ipv4Address)));\r\n            records.add(Collections.singleton(TestDnsServer.newAddressRecord(name, RecordType.AAAA, ipv6Address)));\r\n        }\r\n        final Iterator<Set<ResourceRecord>> recordsIterator = records.iterator();\r\n", "                InetAddress.getByAddress(ns1Name, new byte[] { 10, 0, 0, 3 }),\r\n                DefaultDnsServerAddressStreamProvider.DNS_PORT);\r\n        final InetSocketAddress ns4Address = new InetSocketAddress(\r\n                InetAddress.getByAddress(ns1Name, new byte[] { 10, 0, 0, 4 }),\r\n                DefaultDnsServerAddressStreamProvider.DNS_PORT);\r\n", "                        if (DnsNameResolver.isTransportOrTimeoutError(cause)) {\r\n                            promise.tryFailure(new SearchDomainUnknownHostException(cause, hostname));\r\n                        } else if (searchDomainIdx < searchDomains.length) {\r\n                            Promise<List<T>> newPromise = parent.executor().newPromise();\r\n                            newPromise.addListener(this);\r\n", "\r\n    @Test\r\n    public void testUnknownSpdySynStreamFrameFlags() throws Exception {\r\n        short type = 1;\r\n        byte flags = (byte) 0xFC; // undefined flags\r\n", "    @Test\r\n    public void testUseNoComparator() throws Exception {\r\n        testUseComparator0(true);\r\n    }\r\n\r\n", " * A {@link DnsServerAddressStreamProvider} which is backed by a single {@link DnsServerAddresses}.\r\n */\r\nabstract class UniSequentialDnsServerAddressStreamProvider implements DnsServerAddressStreamProvider {\r\n    private final DnsServerAddresses addresses;\r\n\r\n", "        public String toString() {\r\n            if (cause != null) {\r\n                return hostname + '/' + cause;\r\n            } else {\r\n                return address.toString();\r\n", "                    return null;\r\n                }\r\n                return Collections.singleton(rm.getEntry());\r\n            }\r\n        });\r\n", "        public void readSettingsFrame(boolean clearPersisted) {\r\n            delegate.readSettingsFrame(clearPersisted);\r\n        }\r\n\r\n        @Override\r\n", "    }\r\n\r\n    @Test\r\n    public void testDropAAAA() throws IOException {\r\n        String host = \"somehost.netty.io\";\r\n", "        String second = cnameCache.get(hostnameWithDot(first));\r\n        if (second == null) {\r\n            // Nothing else to follow, return first match.\r\n            return first;\r\n        }\r\n", "            public DnsCacheEntry cache(String hostname, DnsRecord[] additionals, Throwable cause, EventLoop loop) {\r\n                return null;\r\n            }\r\n        }).build();\r\n\r\n", "        int extrasLength = extras.readableBytes();\r\n\r\n        BinaryMemcacheRequest request = new DefaultBinaryMemcacheRequest(Unpooled.EMPTY_BUFFER, extras);\r\n\r\n        boolean result = channel.writeOutbound(request);\r\n", "            addresses.add(new InetSocketAddress(addr, DefaultDnsServerAddressStreamProvider.DNS_PORT));\r\n        } while (++i < entries.size());\r\n        return new SequentialDnsServerAddressStream(addresses, 0);\r\n    }\r\n\r\n", "    /**\r\n     * Sets the {@link ChannelFactory} that will create a {@link DatagramChannel}.\r\n     *\r\n     * @param channelFactory the {@link ChannelFactory}\r\n     * @return {@code this}\r\n", "    }\r\n\r\n    @Test\r\n    public void fullCopy() {\r\n        FullBinaryMemcacheResponse newInstance = response.copy();\r\n", "    public void searchDomainsWithOnlySearch() throws IOException {\r\n        File f = buildFile(\"search linecorp.local\\n\" +\r\n                           \"nameserver 127.0.0.2\\n\");\r\n        List<String> domains = UnixResolverDnsServerAddressStreamProvider.parseEtcResolverSearchDomains(f);\r\n        assertEquals(Collections.singletonList(\"linecorp.local\"), domains);\r\n", "    public ExpectedException expectedException = ExpectedException.none();\r\n\r\n    private static DnsNameResolverBuilder newResolver(boolean decodeToUnicode) {\r\n        return newResolver(decodeToUnicode, null);\r\n    }\r\n", "            }\r\n        });\r\n        dnsServer2.start();\r\n        final TestDnsServer dnsServer3 = new TestDnsServer(new RecordStore() {\r\n            @Override\r\n", "            return true;\r\n        }\r\n\r\n        @Override\r\n        public boolean isDone() {\r\n", "            testSettingLengths(new DefaultFullBinaryMemcacheRequest(null, null, content.retain()),\r\n                    0, 0, content.readableBytes());\r\n\r\n            testSettingLengths(new DefaultFullBinaryMemcacheResponse(key.retain(), extras.retain()),\r\n                    key.readableBytes(), extras.readableBytes(), 0);\r\n", "        @Override\r\n        public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\r\n            events.add(new QueryRedirectedEvent(nameServers));\r\n            return this;\r\n        }\r\n", "import java.util.concurrent.ConcurrentLinkedQueue;\r\nimport java.util.concurrent.CopyOnWriteArrayList;\r\nimport java.util.concurrent.CountDownLatch;\r\nimport java.util.concurrent.TimeUnit;\r\nimport java.util.concurrent.atomic.AtomicBoolean;\r\n", "        @Override\r\n        public String toString() {\r\n            return SingletonDnsServerAddresses.this.toString();\r\n        }\r\n    };\r\n", "                break;\r\n            }\r\n            if (a.isUnresolved()) {\r\n                throw new IllegalArgumentException(\"cannot use an unresolved DNS server address: \" + a);\r\n            }\r\n", "        void releaseAll() {\r\n            for (;;) {\r\n                ByteBuf buf = buffers.poll();\r\n                if (buf == null) {\r\n                    return;\r\n", "                if (that.sender() != null) {\r\n                    return false;\r\n                }\r\n            } else if (!sender().equals(that.sender())) {\r\n                return false;\r\n", "    }\r\n\r\n    @Test\r\n    public void fullCopy() {\r\n        FullBinaryMemcacheRequest newInstance = request.copy();\r\n", "    @Override\r\n    FullBinaryMemcacheResponse duplicate();\r\n\r\n    @Override\r\n    FullBinaryMemcacheResponse retainedDuplicate();\r\n", "     *\r\n     * @param hostname the hostname\r\n     * @return the cached entries or an {@code null} if none.\r\n     */\r\n    DnsServerAddressStream get(String hostname);\r\n", "        }\r\n        return newInstance(key, extras, content().copy());\r\n    }\r\n\r\n    @Override\r\n", "        }\r\n        return newInstance(key, extras, content().copy());\r\n    }\r\n\r\n    @Override\r\n", "        return this;\r\n    }\r\n\r\n    /**\r\n     * Set the factory used to generate objects which can observe individual DNS queries.\r\n", "        return promise;\r\n    }\r\n\r\n    private static <T> void transferResult(Future<T> src, Promise<T> dst) {\r\n        if (src.isSuccess()) {\r\n", "    @Override\r\n    LastMemcacheContent retain();\r\n\r\n    @Override\r\n    LastMemcacheContent touch();\r\n", "            dnsServer2.stop();\r\n        }\r\n    }\r\n\r\n    @Test\r\n", "        chunk.setDecoderResult(DecoderResult.failure(cause));\r\n        return chunk;\r\n    }\r\n\r\n    /**\r\n", "            assertEquals(1, cnameQueries.get());\r\n            assertEquals(2, aQueries.get());\r\n\r\n            resolvedAddresses =\r\n                    resolver.resolveAll(\"y.netty.io\").syncUninterruptibly().getNow();\r\n", "    public void ndotsOptionIsParsedIfPresent() throws IOException {\r\n        File f = buildFile(\"search localdomain\\n\" +\r\n            \"nameserver 127.0.0.11\\n\" +\r\n            \"options ndots:0\\n\");\r\n        assertEquals(0, parseEtcResolverOptions(f).ndots());\r\n", "    }\r\n\r\n    @Override\r\n    public void queryCancelled(int queriesRemaining) {\r\n        try {\r\n", "\r\n            if (logger.isDebugEnabled()) {\r\n                logger.debug(\"{} RECEIVED: UDP [{}: {}], {}\", ch, queryId, res.sender(), res);\r\n            }\r\n\r\n", "                assertNotNull(observer);\r\n                assertTrue(lifecycleObserverFactory.observers.isEmpty());\r\n                assertEquals(2, observer.events.size());\r\n                writtenEvent1 = (QueryWrittenEvent) observer.events.poll();\r\n                assertEquals(expectedDnsName, writtenEvent1.dnsServerAddress.getHostName());\r\n", "    @Test\r\n    public void testSingleton() {\r\n        DnsServerAddresses seq = DnsServerAddresses.singleton(ADDR1);\r\n\r\n        // Should return the same iterator instance for least possible footprint.\r\n", "                    .recursionDesired(false)\r\n                    .resolvedAddressTypes(ResolvedAddressTypes.IPV4_ONLY)\r\n                    .maxQueriesPerResolve(16)\r\n                    .nameServerProvider(new SingletonDnsServerAddressStreamProvider(dnsServer2.localAddress()));\r\n\r\n", "        }\r\n\r\n        @Override\r\n        public boolean release(int decrement) {\r\n            return response.release(decrement);\r\n", "            : DnsServerAddresses.sequential(addresses);\r\n        putIfAbsent(domainToNameServerStreamMap, domainName, addrs);\r\n    }\r\n\r\n    private static void putIfAbsent(Map<String, DnsServerAddresses> domainToNameServerStreamMap,\r\n", "            } else {\r\n                out.add(Unpooled.EMPTY_BUFFER);\r\n            }\r\n\r\n            expectingMoreContent = !(msg instanceof LastMemcacheContent);\r\n", "                \"dns4.some.record.netty.io\" : \"dns4.some.record.netty.io.\";\r\n\r\n        try {\r\n            resolver.resolveAll(hostname).syncUninterruptibly();\r\n\r\n", "        }\r\n\r\n        @Override\r\n        public boolean release() {\r\n            return response.release();\r\n", "        if (key != null) {\r\n            key.release();\r\n        }\r\n        if (extras != null) {\r\n            extras.release();\r\n", "        decoder.decode(buf);\r\n        verify(delegate).readFrameError((String) any());\r\n        assertFalse(buf.isReadable());\r\n        buf.release();\r\n    }\r\n", "                    \" (expected: \" + StringUtil.simpleClassName(EventLoop.class));\r\n        }\r\n\r\n        // we don't really need to pass channelFactory and nameServerProvider separately,\r\n        // but still keep this to ensure backward compatibility with (potentially) override methods\r\n", "                new BinaryMemcacheRequestDecoder(),\r\n                new BinaryMemcacheObjectAggregator(MAX_CONTENT_SIZE));\r\n\r\n        ByteBuf key = Unpooled.copiedBuffer(\"Netty\", CharsetUtil.UTF_8);\r\n        ByteBuf extras = Unpooled.copiedBuffer(\"extras\", CharsetUtil.UTF_8);\r\n", "            copiedBuilder.searchDomains(Arrays.asList(searchDomains));\r\n        }\r\n\r\n        copiedBuilder.ndots(ndots);\r\n        copiedBuilder.decodeIdn(decodeIdn);\r\n", "                    .maxQueriesPerResolve(2)\r\n                    .nameServerProvider(new SingletonDnsServerAddressStreamProvider(\r\n                            nonCompliantDnsServer.localAddress()))\r\n                    .build();\r\n            InetAddress resolved = resolver.resolve(\"netty.com\").syncUninterruptibly().getNow();\r\n", "\r\n                // Give the user the chance to sort or filter the used servers for the query.\r\n                DnsServerAddressStream serverStream = parent.newRedirectDnsServerStream(\r\n                        question.name(), addresses);\r\n\r\n", "        final InetSocketAddress ns2Address = new InetSocketAddress(\r\n                InetAddress.getByAddress(ns1Name, new byte[] { 10, 0, 0, 2 }),\r\n                DefaultDnsServerAddressStreamProvider.DNS_PORT);\r\n        final InetSocketAddress ns3Address = new InetSocketAddress(\r\n                InetAddress.getByAddress(ns1Name, new byte[] { 10, 0, 0, 3 }),\r\n", "                    key.readableBytes(), extras.readableBytes(), content.readableBytes());\r\n            testSettingLengths(new DefaultFullBinaryMemcacheRequest(null, extras.retain(), content.retain()),\r\n                    0, extras.readableBytes(), content.readableBytes());\r\n            testSettingLengths(new DefaultFullBinaryMemcacheRequest(key.retain(), null, content.retain()),\r\n                    key.readableBytes(), 0, content.readableBytes());\r\n", "    public static DnsServerAddressStreamProvider platformDefault() {\r\n        if (STREAM_PROVIDER_CONSTRUCTOR != null) {\r\n            try {\r\n                return STREAM_PROVIDER_CONSTRUCTOR.newInstance();\r\n            } catch (IllegalAccessException e) {\r\n", "                    return modifier.getDnsMessage();\r\n                }\r\n                return message;\r\n            }\r\n        };\r\n", "            key = key.copy();\r\n        }\r\n        ByteBuf extras = extras();\r\n        if (extras != null) {\r\n            extras = extras.copy();\r\n", "            key = key.copy();\r\n        }\r\n        ByteBuf extras = extras();\r\n        if (extras != null) {\r\n            extras = extras.copy();\r\n", "    @Override\r\n    LastMemcacheContent copy();\r\n\r\n    @Override\r\n    LastMemcacheContent duplicate();\r\n", "            DnsNameResolverBuilder builder = newResolver()\r\n                    .recursionDesired(false)\r\n                    .queryTimeoutMillis(10000)\r\n                    .resolvedAddressTypes(ResolvedAddressTypes.IPV4_PREFERRED)\r\n                    .maxQueriesPerResolve(16)\r\n", "    }\r\n\r\n    @Override\r\n    public FullBinaryMemcacheRequest replace(ByteBuf content) {\r\n        ByteBuf key = key();\r\n", "                    .recursionDesired(true)\r\n                    .resolvedAddressTypes(ResolvedAddressTypes.IPV4_ONLY)\r\n                    .maxQueriesPerResolve(16)\r\n                    .nameServerProvider(new SingletonDnsServerAddressStreamProvider(dnsServer2.localAddress()));\r\n\r\n", "        if (first.equals(second)) {\r\n            // Follow CNAME from cache would loop. Lets throw and so fail the resolution.\r\n            throw new UnknownHostException(\"CNAME loop detected for '\" + hostname + '\\'');\r\n        }\r\n    }\r\n", "            assertEntry(entries2.get(1), addr2);\r\n        } finally {\r\n            group.shutdownGracefully();\r\n        }\r\n    }\r\n", "     * @param hostname the hostname\r\n     * @param cname the cname mapping.\r\n     * @param originalTtl the TTL as returned by the DNS server\r\n     * @param loop the {@link EventLoop} used to register the TTL timeout\r\n     */\r\n", "            if (addresses != null) {\r\n                return addresses.stream();\r\n            }\r\n\r\n            hostname = hostname.substring(i + 1);\r\n", "    }\r\n\r\n    @Override\r\n    public MemcacheContent duplicate() {\r\n        return replace(content.duplicate());\r\n", "            DnsServerAddressStream entries2 = cache.get(\"netty.io\");\r\n\r\n            assertEquals(2, entries2.size());\r\n            assertEquals(resolved2, entries2.next());\r\n            assertEquals(resolved1, entries2.next());\r\n", "                        return new InetSocketAddress(InetAddress.getByAddress(ns2Name,\r\n                                NetUtil.LOCALHOST.getAddress()), socket.getLocalPort());\r\n                    }\r\n                } catch (UnknownHostException e) {\r\n                    throw new IllegalStateException(e);\r\n", "            group.shutdownGracefully();\r\n        }\r\n    }\r\n\r\n    @Test\r\n", "            group.shutdownGracefully();\r\n        }\r\n    }\r\n\r\n    @Test\r\n", "            group.shutdownGracefully();\r\n        }\r\n    }\r\n\r\n    @Test\r\n", "                exception = new DnsResolveContextException(message);\r\n            }\r\n            return ThrowableUtil.unknownStackTrace(exception, clazz, method);\r\n        }\r\n    }\r\n", "                    key.readableBytes(), extras.readableBytes(), 0);\r\n\r\n            testSettingLengths(new DefaultFullBinaryMemcacheRequest(key.retain(), extras.retain()),\r\n                    key.readableBytes(), extras.readableBytes(), 0);\r\n            testSettingLengths(new DefaultFullBinaryMemcacheRequest(null, extras.retain()),\r\n", "        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;\r\n\r\n        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeControlFrameHeader(buf, type, flags, length);\r\n        buf.writeInt(streamId | 0x80000000); // should ignore reserved bit\r\n", "\r\n    public DnsAddressResolverGroup(DnsNameResolverBuilder dnsResolverBuilder) {\r\n        this.dnsResolverBuilder = dnsResolverBuilder.copy();\r\n    }\r\n\r\n", "            DnsQuestion question, Map<String, String> cnames,\r\n            final DnsQueryLifecycleObserver queryLifecycleObserver,\r\n            Promise<List<T>> promise) {\r\n\r\n        // Resolve the host name in the question into the real host name.\r\n", "            assertTrue(observer.events.isEmpty());\r\n        }\r\n    }\r\n\r\n    private static final class TestRecursiveCacheDnsQueryLifecycleObserverFactory\r\n", "                        }\r\n                        result.add(e.address());\r\n                    }\r\n                }\r\n            }\r\n", "                        message.getAuthorityRecords().add(TestDnsServer.newNsRecord(domain, ns0Name));\r\n                        message.getAuthorityRecords().add(TestDnsServer.newNsRecord(domain, ns1Name));\r\n                        message.getAuthorityRecords().add(TestDnsServer.newNsRecord(domain, ns2Name));\r\n\r\n                        message.getAdditionalRecords().add(newARecord(ns0Address));\r\n", "            }\r\n\r\n            if (recipient() == null) {\r\n                if (that.recipient() != null) {\r\n                    return false;\r\n", "        int length = 10;\r\n        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;\r\n        int associatedToStreamId = RANDOM.nextInt() & 0x7FFFFFFF;\r\n        byte priority = (byte) (RANDOM.nextInt() & 0x07);\r\n\r\n", "        }\r\n    }\r\n\r\n    @Test(timeout = 2000)\r\n    public void testDropAAAAResolveAllFast() throws IOException {\r\n", "package io.netty.handler.codec.memcache.binary;\r\n\r\nimport io.netty.buffer.ByteBuf;\r\nimport io.netty.channel.ChannelHandlerContext;\r\nimport io.netty.channel.CombinedChannelDuplexHandler;\r\n", "        ChannelFuture future = b.register();\r\n        Throwable cause = future.cause();\r\n        if (cause != null) {\r\n            if (cause instanceof RuntimeException) {\r\n                throw (RuntimeException) cause;\r\n", "    private final ConcurrentMap<String, Promise<T>> resolvesInProgress;\r\n    private final ConcurrentMap<String, Promise<List<T>>> resolveAllsInProgress;\r\n\r\n    InflightNameResolver(EventExecutor executor, NameResolver<T> delegate,\r\n                         ConcurrentMap<String, Promise<T>> resolvesInProgress,\r\n", "        UdpTransport transport = new UdpTransport(address.getHostName(), address.getPort());\r\n        setTransports(transport);\r\n\r\n        DatagramAcceptor acceptor = transport.getAcceptor();\r\n\r\n", "     * @param key the key to encode.\r\n     */\r\n    private static void encodeKey(ByteBuf buf, ByteBuf key) {\r\n        if (key == null || !key.isReadable()) {\r\n            return;\r\n", "        return new DefaultDnsQuery(id);\r\n    }\r\n\r\n    @Override\r\n    protected Channel channel() {\r\n", "        ByteBuf incoming = Unpooled.buffer();\r\n        incoming.writeBytes(SET_REQUEST_WITH_CONTENT);\r\n        channel.writeInbound(incoming);\r\n\r\n        FullBinaryMemcacheRequest request = channel.readInbound();\r\n", "\r\n        // There are no queries left to try.\r\n        if (finalResult == null) {\r\n            if (nameServerAddrStreamIndex < nameServerAddrStream.size()) {\r\n                if (queryLifecycleObserver == NoopDnsQueryLifecycleObserver.INSTANCE) {\r\n", "            String mappingWithDot = hostnameWithDot(mapping);\r\n            if (!nameWithDot.equalsIgnoreCase(mappingWithDot)) {\r\n                cache.cache(nameWithDot, mappingWithDot, r.timeToLive(), loop);\r\n                cnames.put(name, mapping);\r\n            }\r\n", "        ByteBuf content = Unpooled.copiedBuffer(\"content\", CharsetUtil.UTF_8);\r\n        try {\r\n            testSettingLengths(new DefaultBinaryMemcacheRequest(), 0, 0, 0);\r\n            testSettingLengths(new DefaultBinaryMemcacheRequest(key.retain()), key.readableBytes(), 0, 0);\r\n            testSettingLengths(new DefaultBinaryMemcacheRequest(key.retain(), extras.retain()),\r\n", "        return this;\r\n    }\r\n\r\n    @Override\r\n    public LastMemcacheContent touch() {\r\n", "                \"ns2\", new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2 }), 53);\r\n\r\n        UNRESOLVED1 = InetSocketAddress.createUnresolved(\"ns3\", 53);\r\n        UNRESOLVED2 = InetSocketAddress.createUnresolved(\"ns4\", 53);\r\n        UNRESOLVED3 = InetSocketAddress.createUnresolved(\"ns5\", 53);\r\n", "     */\r\n    public UnixResolverDnsServerAddressStreamProvider(File etcResolvConf, File... etcResolverFiles) throws IOException {\r\n        Map<String, DnsServerAddresses> etcResolvConfMap = parse(checkNotNull(etcResolvConf, \"etcResolvConf\"));\r\n        final boolean useEtcResolverFiles = etcResolverFiles != null && etcResolverFiles.length != 0;\r\n        domainToNameServerStreamMap = useEtcResolverFiles ? parse(etcResolverFiles) : etcResolvConfMap;\r\n", "        DnsNameResolverBuilder copiedBuilder = builder.copy();\r\n\r\n        // change channel factory does not propagate to previously made copy\r\n        ChannelFactory<DatagramChannel> newChannelFactory =\r\n                new ReflectiveChannelFactory<DatagramChannel>(NioDatagramChannel.class);\r\n", "                    .nameServerProvider(new SingletonDnsServerAddressStreamProvider(dnsServer2.localAddress()));\r\n\r\n            resolver = builder.build();\r\n            assertNotEmptyAndRelease(resolver.resolveAll(new DefaultDnsQuestion(\"service.netty.io\", SRV)));\r\n            alias.set(true);\r\n", "        assertNext(i, ADDR1);\r\n    }\r\n\r\n    private static void assertNext(DnsServerAddressStream i, InetSocketAddress addr) {\r\n        assertThat(i.next(), is(sameInstance(addr)));\r\n", " * Default implementation of {@link DnsCache}, backed by a {@link ConcurrentMap}.\r\n * If any additional {@link DnsRecord} is used, no caching takes place.\r\n */\r\npublic class DefaultDnsCache implements DnsCache {\r\n\r\n", "        if (entries == null) {\r\n            entries = new Entries(hostname);\r\n            Entries oldEntries = resolveCache.putIfAbsent(hostname, entries);\r\n            if (oldEntries != null) {\r\n                entries = oldEntries;\r\n", "    @Override\r\n    FullBinaryMemcacheRequest duplicate();\r\n\r\n    @Override\r\n    FullBinaryMemcacheRequest retainedDuplicate();\r\n", "                    .maxQueriesPerResolve(16)\r\n                    .nameServerProvider(new SingletonDnsServerAddressStreamProvider(dnsServer2.localAddress()));\r\n            if (ipv4Preferred) {\r\n                builder.resolvedAddressTypes(ResolvedAddressTypes.IPV4_PREFERRED);\r\n            } else {\r\n", "\r\n    @Test\r\n    public void testInvalidSpdyHeadersFrameStreamId() throws Exception {\r\n        short type = 8;\r\n        byte flags = 0;\r\n", "        public LastMemcacheContent copy() {\r\n            return EMPTY_LAST_CONTENT;\r\n        }\r\n\r\n        @Override\r\n", "    }\r\n\r\n    @Test\r\n    public void fullReplace() {\r\n        ByteBuf newContent = Unpooled.copiedBuffer(\"new value\", CharsetUtil.UTF_8);\r\n", " * Used to generate new instances of {@link DnsQueryLifecycleObserver}.\r\n */\r\npublic interface DnsQueryLifecycleObserverFactory {\r\n    /**\r\n     * Create a new instance of a {@link DnsQueryLifecycleObserver}. This will be called at the start of a new query.\r\n", "\r\n        QueryNoAnswerEvent(DnsResponseCode code) {\r\n            this.code = code;\r\n        }\r\n    }\r\n", "    public void testResolveNotDecodeUnicode() {\r\n        testResolveUnicode(false);\r\n    }\r\n\r\n    private static void testResolveUnicode(boolean decode) {\r\n", "                InetAddress actual = resultB.get(e.getKey());\r\n                if (!actual.equals(expected)) {\r\n                    // Print the content of the cache when test failure is expected.\r\n                    System.err.println(\"Cache for \" + e.getKey() + \": \" + resolver.resolveAll(e.getKey()).getNow());\r\n                }\r\n", "        try {\r\n            options = UnixResolverDnsServerAddressStreamProvider.parseEtcResolverOptions();\r\n        } catch (Exception ignore) {\r\n            options = UnixResolverOptions.newBuilder().build();\r\n        }\r\n", "        }\r\n    }\r\n\r\n    @Test(timeout = 2000)\r\n    public void testDropAAAAResolveFast() throws IOException {\r\n", "\r\n    @Override\r\n    MemcacheContent touch();\r\n\r\n    @Override\r\n", "        DefaultLastMemcacheContent content2 =\r\n            new DefaultLastMemcacheContent(Unpooled.copiedBuffer(\" Rocks!\", CharsetUtil.UTF_8));\r\n        int totalBodyLength = content1.content().readableBytes() + content2.content().readableBytes();\r\n\r\n        BinaryMemcacheRequest request = new DefaultBinaryMemcacheRequest();\r\n", "            @Override\r\n            public void operationComplete(Future<List<InetAddress>> future) {\r\n                if (future.isSuccess()) {\r\n                    trySuccess(promise, future.getNow().get(0));\r\n                } else {\r\n", "import org.apache.mina.filter.codec.ProtocolDecoderAdapter;\r\nimport org.apache.mina.filter.codec.ProtocolDecoderOutput;\r\nimport org.apache.mina.filter.codec.ProtocolEncoder;\r\nimport org.apache.mina.filter.codec.ProtocolEncoderOutput;\r\nimport org.apache.mina.transport.socket.DatagramAcceptor;\r\n", "                                        question.getDomainName(), question.getRecordType(), attr));\r\n                    default:\r\n                        return null;\r\n                }\r\n            }\r\n", "    public BinaryMemcacheResponse touch(Object hint) {\r\n        super.touch(hint);\r\n        return this;\r\n    }\r\n\r\n", "\r\n    DnsQueryContext(DnsNameResolver parent,\r\n                    InetSocketAddress nameServerAddr,\r\n                    DnsQuestion question,\r\n                    DnsRecord[] additionals,\r\n", "        final String domain = \"netty.io\";\r\n        final String ns1Name = \"ns1.\" + domain;\r\n        final String ns2Name = \"ns2.\" + domain;\r\n        final InetAddress expected = InetAddress.getByAddress(\"some.record.\" + domain, new byte[] { 10, 10, 10, 10 });\r\n\r\n", "    @Override\r\n    public byte dataType() {\r\n        return dataType;\r\n    }\r\n\r\n", "            if (failOnMissingResponse) {\r\n                final int size = out.size();\r\n                for (int i = oldSize; i < size; i ++) {\r\n                    Object msg = out.get(i);\r\n                    if (msg instanceof LastMemcacheContent) {\r\n", "            return recipient;\r\n        }\r\n\r\n        @Override\r\n        public AddressedEnvelope<DnsResponse, InetSocketAddress> retain() {\r\n", "            // If an empty hostname is used we should use \"localhost\", just like InetAddress.getAllByName(...) does.\r\n            promise.setSuccess(Collections.singletonList(loopbackAddress()));\r\n            return;\r\n        }\r\n        final byte[] bytes = NetUtil.createByteArrayFromIpAddressString(inetHost);\r\n", "            \"baidu.com\",\r\n            \"wikipedia.org\",\r\n            \"yahoo.com\",\r\n            \"reddit.com\",\r\n            \"google.co.in\",\r\n", "        decoder.decode(buf);\r\n        verifyZeroInteractions(delegate);\r\n        assertFalse(buf.isReadable());\r\n        buf.release();\r\n    }\r\n", "        decoder.decode(buf);\r\n        verifyZeroInteractions(delegate);\r\n        assertFalse(buf.isReadable());\r\n        buf.release();\r\n    }\r\n", "        this.searchDomains = searchDomains != null ? searchDomains.clone() : DEFAULT_SEARCH_DOMAINS;\r\n        this.ndots = ndots >= 0 ? ndots : DEFAULT_OPTIONS.ndots();\r\n        this.decodeIdn = decodeIdn;\r\n        this.completeOncePreferredResolved = completeOncePreferredResolved;\r\n        this.socketChannelFactory = socketChannelFactory;\r\n", "            return this;\r\n        }\r\n\r\n        @Override\r\n        public void queryFailed(Throwable cause) {\r\n", "        return this;\r\n    }\r\n\r\n    @Override\r\n    public void queryFailed(Throwable cause) {\r\n", "import org.apache.directory.server.dns.messages.ResourceRecord;\r\nimport org.apache.directory.server.dns.messages.ResourceRecordModifier;\r\nimport org.apache.directory.server.dns.messages.ResponseCode;\r\nimport org.apache.directory.server.dns.store.DnsAttribute;\r\nimport org.apache.directory.server.dns.store.RecordStore;\r\n", "            assertEquals(1, server2Counter.get());\r\n            assertEquals(1, server3Counter.get());\r\n            assertResolvedAddress(resolver.resolve(domain).syncUninterruptibly().getNow(), ipv4Addr, domain);\r\n            assertEquals(2, server2Counter.get());\r\n            assertEquals(1, server3Counter.get());\r\n", "        private final class TestAAAARecordEncoder extends ResourceRecordEncoder {\r\n\r\n            @Override\r\n            protected void putResourceRecordData(IoBuffer ioBuffer, ResourceRecord resourceRecord) {\r\n                byte[] bytes = BYTES.get(resourceRecord.get(DnsAttribute.IP_ADDRESS));\r\n", "    }\r\n\r\n    private final class Encoder extends BinaryMemcacheRequestEncoder {\r\n\r\n        @Override\r\n", "import io.netty.util.internal.UnstableApi;\r\n\r\n/**\r\n * The default {@link MemcacheContent} implementation.\r\n */\r\n", "            response.retain();\r\n            return this;\r\n        }\r\n\r\n        @Override\r\n", "                true, 10, true, 4096,\r\n                false, HostsFileEntriesResolver.DEFAULT,\r\n                new SingletonDnsServerAddressStreamProvider(redirectServer.localAddress()),\r\n                DnsNameResolver.DEFAULT_SEARCH_DOMAINS, 0, true) {\r\n\r\n", " */\r\npublic final class DnsServerAddressStreamProviders {\r\n\r\n    private static final InternalLogger LOGGER =\r\n            InternalLoggerFactory.getInstance(DnsServerAddressStreamProviders.class);\r\n", "\r\n    @Override\r\n    MemcacheContent duplicate();\r\n\r\n    @Override\r\n", "\r\n        return optionsBuilder.build();\r\n    }\r\n\r\n    private static void parseResOptions(String line, UnixResolverOptions.Builder builder) {\r\n", "        assertFalse(buf.isReadable());\r\n        assertFalse(headerBlock.isReadable());\r\n        buf.release();\r\n        headerBlock.release();\r\n    }\r\n", "        assertEquals(store.getAddress(\"host2.bar.com\"), resolved);\r\n\r\n        // \"host3\" resolves via the \"foo.com\" search path as it is the first one\r\n        resolved = assertResolve(resolver, \"host3\");\r\n        assertEquals(store.getAddress(\"host3.foo.com\"), resolved);\r\n", "\r\n    @Test\r\n    public void testIllegalSpdySynStreamFrameStreamId() throws Exception {\r\n        short type = 1;\r\n        byte flags = 0;\r\n", "                if (handleRedirect(question, envelope, queryLifecycleObserver, promise)) {\r\n                    // Was a redirect so return here as everything else is handled in handleRedirect(...)\r\n                    return;\r\n                }\r\n                final DnsRecordType type = question.type();\r\n", "\r\n        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeControlFrameHeader(buf, type, flags, length);\r\n        buf.writeInt(lastGoodStreamId);\r\n        buf.writeInt(statusCode);\r\n", "        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeControlFrameHeader(buf, type, flags, length);\r\n        buf.writeInt(lastGoodStreamId);\r\n        buf.writeInt(statusCode);\r\n\r\n", "\r\n                    ReferenceCountUtil.release(r);\r\n                }\r\n\r\n                logger.info(\"{} has the following MX records:{}\", hostname, buf);\r\n", "            // Only try to use when not on Android as the classes not exists there:\r\n            // See https://github.com/netty/netty/issues/8654\r\n            DirContextUtils.addNameServers(defaultNameServers, DNS_PORT);\r\n        }\r\n\r\n", "        return new DefaultDnsServerAddresses(\"shuffled\", addresses) {\r\n            @Override\r\n            public DnsServerAddressStream stream() {\r\n                return new ShuffledDnsServerAddressStream(addresses);\r\n            }\r\n", "import java.net.InetAddress;\r\nimport java.util.List;\r\nimport java.util.concurrent.Callable;\r\nimport java.util.concurrent.TimeUnit;\r\n\r\n", "                query(nameServerAddrStream, nameServerAddrStreamIndex + 1, question,\r\n                      queryLifecycleObserver.queryNoAnswer(code), true, promise, null);\r\n            } else {\r\n                queryLifecycleObserver.queryFailed(NXDOMAIN_QUERY_FAILED_EXCEPTION);\r\n\r\n", "    // See also: https://github.com/netty/netty/commit/b47fb817991b42ec8808c7d26538f3f2464e1fa6\r\n    static final int MAX_SUPPORTED_TTL_SECS = (int) TimeUnit.DAYS.toSeconds(365 * 2);\r\n\r\n    private final ConcurrentMap<String, Entries> resolveCache = PlatformDependent.newConcurrentHashMap();\r\n\r\n", "\r\n    @Test\r\n    public void testEmptyHeaderBlock() throws Exception {\r\n        ByteBuf headerBlock = Unpooled.EMPTY_BUFFER;\r\n        decoder.decode(ByteBufAllocator.DEFAULT, headerBlock, frame);\r\n", "    private static void testResolve0(ResolvedAddressTypes addressTypes, InetAddress expectedAddr, String name) {\r\n        DnsNameResolver resolver = newResolver(addressTypes).build();\r\n        try {\r\n            InetAddress address = resolver.resolve(name).syncUninterruptibly().getNow();\r\n            assertEquals(expectedAddr, address);\r\n", "        int statusCode = 0; // invalid status code\r\n\r\n        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeControlFrameHeader(buf, type, flags, length);\r\n        buf.writeInt(streamId);\r\n", "            Throwable error = loop.schedule(new Callable<Throwable>() {\r\n                @Override\r\n                public Throwable call() {\r\n                    try {\r\n                        assertNull(cache.get(\"netty.io\", null));\r\n", "    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return new StringBuilder()\r\n", "\r\n        DnsServerAddressStream stream = p.nameServerAddressStream(\"somehost\");\r\n        assertHostNameEquals(\"127.0.0.2\", stream.next());\r\n        assertHostNameEquals(\"127.0.0.3\", stream.next());\r\n    }\r\n", "        // No resolved address found.\r\n        final int maxAllowedQueries = parent.maxQueriesPerResolve();\r\n        final int tries = maxAllowedQueries - allowedQueries;\r\n        final StringBuilder buf = new StringBuilder(64);\r\n\r\n", "        buf.release();\r\n    }\r\n\r\n    @Test\r\n    public void testSpdyHeadersFrameHeaderBlock() throws Exception {\r\n", "\r\n        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeControlFrameHeader(buf, type, flags, length);\r\n        buf.writeInt(streamId);\r\n        buf.writeInt(deltaWindowSize);\r\n", "            assertEquals(2, observer.events.size());\r\n            QueryWrittenEvent writtenEvent = (QueryWrittenEvent) observer.events.poll();\r\n            assertEquals(dnsServer1.localAddress(), writtenEvent.dnsServerAddress);\r\n            QueryFailedEvent failedEvent = (QueryFailedEvent) observer.events.poll();\r\n\r\n", "                        return new InetSocketAddress(InetAddress.getByAddress(ns1Name,\r\n                                dnsServerAuthority.localAddress().getAddress().getAddress()),\r\n                                dnsServerAuthority.localAddress().getPort());\r\n                    }\r\n                    if (server.getHostName().startsWith(ns2Name)) {\r\n", "    public void testExpire() throws Throwable {\r\n        InetSocketAddress resolved1 = new InetSocketAddress(\r\n                InetAddress.getByAddress(\"ns1\", new byte[] { 10, 0, 0, 1 }), 53);\r\n        InetSocketAddress resolved2 = new InetSocketAddress(\r\n                InetAddress.getByAddress(\"ns2\", new byte[] { 10, 0, 0, 2 }), 53);\r\n", "        try {\r\n            assertThat(resolver.resolve(domain).await().cause(),\r\n                    Matchers.<Throwable>instanceOf(UnknownHostException.class));\r\n            assertThat(resolver.resolveAll(domain).await().cause(),\r\n                    Matchers.<Throwable>instanceOf(UnknownHostException.class));\r\n", "        byte priority = (byte) (RANDOM.nextInt() & 0x07);\r\n\r\n        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeControlFrameHeader(buf, type, flags, length);\r\n        buf.writeInt(streamId);\r\n", "                return Collections.singleton(rm.getEntry());\r\n            }\r\n        });\r\n        dnsServer3.start();\r\n        DnsNameResolver resolver = null;\r\n", "    @Test\r\n    public void testResolveNullIpv6() {\r\n        testResolve0(ResolvedAddressTypes.IPV6_ONLY, NetUtil.LOCALHOST6, null);\r\n    }\r\n\r\n", "        content.getBytes(content.readerIndex(), addrBytes);\r\n\r\n        try {\r\n            return InetAddress.getByAddress(decodeIdn ? IDN.toUnicode(name) : name, addrBytes);\r\n        } catch (UnknownHostException e) {\r\n", "    FullBinaryMemcacheRequest retain(int increment);\r\n\r\n    @Override\r\n    FullBinaryMemcacheRequest retain();\r\n\r\n", "                    return;\r\n                }\r\n            }\r\n            query(name, expectedTypes[end], nameServerAddressStream, false, promise);\r\n        } finally {\r\n", "    @Override\r\n    public LastMemcacheContent copy() {\r\n        return replace(content().copy());\r\n    }\r\n\r\n", "\r\n    @Test\r\n    public void testCacheFailed() throws Exception {\r\n        InetAddress addr1 = InetAddress.getByAddress(new byte[] { 10, 0, 0, 1 });\r\n        InetAddress addr2 = InetAddress.getByAddress(new byte[] { 10, 0, 0, 2 });\r\n", "            implements DnsQueryLifecycleObserverFactory {\r\n        final Queue<TestDnsQueryLifecycleObserver> observers =\r\n                new ConcurrentLinkedQueue<TestDnsQueryLifecycleObserver>();\r\n        @Override\r\n        public DnsQueryLifecycleObserver newDnsQueryLifecycleObserver(DnsQuestion question) {\r\n", "     * @param channelType the type\r\n     * @return {@code this}\r\n     */\r\n    public DnsNameResolverBuilder channelType(Class<? extends DatagramChannel> channelType) {\r\n        return channelFactory(new ReflectiveChannelFactory<DatagramChannel>(channelType));\r\n", "        try {\r\n            DnsNameResolverBuilder builder = newResolver()\r\n                    .recursionDesired(false)\r\n                    .queryTimeoutMillis(10000)\r\n                    .resolvedAddressTypes(ResolvedAddressTypes.IPV4_PREFERRED)\r\n", "            DnsResolveContext.class, \"onResponse(..)\");\r\n    private static final RuntimeException NAME_SERVERS_EXHAUSTED_EXCEPTION =\r\n            DnsResolveContextException.newStatic(\"No name servers returned an answer\",\r\n            DnsResolveContext.class, \"tryToFinishResolve(..)\");\r\n\r\n", "        List<String> searchDomains = new ArrayList<String>();\r\n\r\n        FileReader fr = new FileReader(etcResolvConf);\r\n        BufferedReader br = null;\r\n        try {\r\n", "            DnsNameResolverBuilder builder = newResolver()\r\n                    .recursionDesired(false)\r\n                    .resolvedAddressTypes(ResolvedAddressTypes.IPV4_ONLY)\r\n                    .maxQueriesPerResolve(16)\r\n                    .nameServerProvider(new SingletonDnsServerAddressStreamProvider(dnsServer.localAddress()));\r\n", "            testSettingLengths(new DefaultFullBinaryMemcacheResponse(key.retain(), extras.retain(), content.retain()),\r\n                    key.readableBytes(), extras.readableBytes(), content.readableBytes());\r\n            testSettingLengths(new DefaultFullBinaryMemcacheResponse(null, extras.retain(), content.retain()),\r\n                    0, extras.readableBytes(), content.readableBytes());\r\n            testSettingLengths(new DefaultFullBinaryMemcacheResponse(key.retain(), null, content.retain()),\r\n", "        assertFalse(headerBlock.isReadable());\r\n        buf.release();\r\n        headerBlock.release();\r\n    }\r\n\r\n", "    @Test\r\n    public void testUseComparator() throws Exception {\r\n        testUseComparator0(false);\r\n    }\r\n\r\n", "                    promise.addListener(\r\n                            new FutureListener<AddressedEnvelope<DnsResponse, InetSocketAddress>>() {\r\n                        @Override\r\n                        public void operationComplete(\r\n                                Future<AddressedEnvelope<DnsResponse, InetSocketAddress>> future) {\r\n", "     * @return The options values provided by /etc/resolve.conf.\r\n     * @throws IOException If a failure occurs parsing the file.\r\n     */\r\n    static UnixResolverOptions parseEtcResolverOptions() throws IOException {\r\n        return parseEtcResolverOptions(new File(ETC_RESOLV_CONF_FILE));\r\n", "            @Override\r\n            protected DnsMessage filterMessage(DnsMessage message) {\r\n                isQuerySentToSecondServer.set(true);\r\n                return message;\r\n            }\r\n", "                DefaultDnsServerAddressStreamProvider.DNS_PORT);\r\n        final InetSocketAddress ns4Address = new InetSocketAddress(\r\n                InetAddress.getByAddress(ns1Name, new byte[] { 10, 0, 0, 4 }),\r\n                DefaultDnsServerAddressStreamProvider.DNS_PORT);\r\n\r\n", "\r\n        boolean result = channel.writeOutbound(request);\r\n        assertThat(result, is(true));\r\n\r\n        ByteBuf written = channel.readOutbound();\r\n", "\r\n        boolean result = channel.writeOutbound(request);\r\n        assertThat(result, is(true));\r\n\r\n        ByteBuf written = channel.readOutbound();\r\n", "                // Try with the next server if is not authoritative for the domain.\r\n                //\r\n                // From https://tools.ietf.org/html/rfc1035 :\r\n                //\r\n                //   RCODE        Response code - this 4 bit field is set as part of\r\n", "                // Because of this the resolver will never be able to resolve and so fail eventually at some\r\n                // point.\r\n                for (QuestionRecord record: message.getQuestionRecords()) {\r\n                    if (record.getDomainName().equals(domain)) {\r\n                        message.getAdditionalRecords().clear();\r\n", "            testSettingLengths(new DefaultFullBinaryMemcacheResponse(null, extras.retain()),\r\n                    0, extras.readableBytes(), 0);\r\n            testSettingLengths(new DefaultFullBinaryMemcacheResponse(key.retain(), null),\r\n                    key.readableBytes(), 0, 0);\r\n            testSettingLengths(new DefaultFullBinaryMemcacheResponse(null, null), 0, 0, 0);\r\n", "     * {@link HostsFileEntries}, a synthetic {@code A} or {@code AAAA} record will be returned.\r\n     *\r\n     * @param question the question\r\n     *\r\n     * @return the list of the {@link DnsRecord}s as the result of the resolution\r\n", "\r\n        DnsServerAddressStream stream = p.nameServerAddressStream(\"\");\r\n        assertHostNameEquals(\"127.0.0.2\", stream.next());\r\n        assertHostNameEquals(\"127.0.0.3\", stream.next());\r\n        assertHostNameEquals(\"127.0.0.4\", stream.next());\r\n", "\r\n        DnsServerAddressStream stream = p.nameServerAddressStream(\"\");\r\n        assertHostNameEquals(\"127.0.0.2\", stream.next());\r\n        assertHostNameEquals(\"127.0.0.3\", stream.next());\r\n        assertHostNameEquals(\"127.0.0.4\", stream.next());\r\n", "                    type + ']', cause));\r\n            return false;\r\n        }\r\n        query(dnsServerAddressStream, 0, question, newDnsQueryLifecycleObserver(question), flush, promise, null);\r\n        return true;\r\n", "    public int size() {\r\n        return addresses.size();\r\n    }\r\n\r\n    @Override\r\n", "     * @param address The singleton address to use for every DNS resolution.\r\n     */\r\n    public SingletonDnsServerAddressStreamProvider(final InetSocketAddress address) {\r\n        super(DnsServerAddresses.singleton(address));\r\n    }\r\n", "        buf.writeInt(id);\r\n\r\n        decoder.decode(buf);\r\n        verify(delegate).readFrameError(anyString());\r\n        assertFalse(buf.isReadable());\r\n", "                HostsFileEntriesResolver.DEFAULT, // hostsFileEntriesResolver\r\n                DnsServerAddressStreamProviders.platformDefault(), // dnsServerAddressStreamProvider\r\n                null, // searchDomains\r\n                1, // ndots\r\n                true // decodeIdn\r\n", "        try {\r\n            assertResponseEquals(response, response.content(), response.duplicate());\r\n        } finally {\r\n            response.release();\r\n        }\r\n", "@UnstableApi\r\npublic class DefaultMemcacheContent extends AbstractMemcacheObject implements MemcacheContent {\r\n\r\n    private final ByteBuf content;\r\n\r\n", "    private final SpdyFrameDecoderDelegate delegate = mock(SpdyFrameDecoderDelegate.class);\r\n    private final TestSpdyFrameDecoderDelegate testDelegate = new TestSpdyFrameDecoderDelegate();\r\n    private SpdyFrameDecoder decoder;\r\n\r\n    @Before\r\n", "     * @param lifecycleObserverFactory the factory used to generate objects which can observe individual DNS queries.\r\n     * @return {@code this}\r\n     */\r\n    public DnsNameResolverBuilder dnsQueryLifecycleObserverFactory(DnsQueryLifecycleObserverFactory\r\n                                                                           lifecycleObserverFactory) {\r\n", "        decoder.decode(buf);\r\n        verify(delegate).readDataFrame(streamId, false, buf.slice(SPDY_HEADER_SIZE, length));\r\n        assertFalse(buf.isReadable());\r\n        buf.release();\r\n    }\r\n", "public abstract class AbstractMemcacheObjectEncoder<M extends MemcacheMessage> extends MessageToMessageEncoder<Object> {\r\n\r\n    private boolean expectingMoreContent;\r\n\r\n    @Override\r\n", "            question = new DefaultDnsQuestion(hostname, type, dnsClass);\r\n        } catch (Throwable cause) {\r\n            // Assume a single failure means that queries will succeed. If the hostname is invalid for one type\r\n            // there is no case where it is known to be valid for another type.\r\n            promise.tryFailure(new IllegalArgumentException(\"Unable to create DNS Question for: [\" + hostname + \", \" +\r\n", "        public void readHeadersFrame(int streamId, boolean last) {\r\n            delegate.readHeadersFrame(streamId, last);\r\n        }\r\n\r\n        @Override\r\n", "    }\r\n\r\n    @Test\r\n    public void searchDomainsWithMultipleSearch() throws IOException {\r\n        File f = buildFile(\"search linecorp.local\\n\" +\r\n", "        queriesInProgress.add(resolveFuture);\r\n\r\n        Promise<List<InetAddress>> resolverPromise = parent.executor().newPromise();\r\n        resolverPromise.addListener(new FutureListener<List<InetAddress>>() {\r\n            @Override\r\n", "                        Throwable cause = future.cause();\r\n                        promise.tryFailure(cause);\r\n                        writePromise.setFailure(cause);\r\n                    }\r\n                }\r\n", "        modifier.setAuthorityRecords(message.getAuthorityRecords());\r\n        modifier.setMessageType(message.getMessageType());\r\n        modifier.setOpCode(message.getOpCode());\r\n        modifier.setQuestionRecords(message.getQuestionRecords());\r\n        modifier.setRecursionAvailable(message.isRecursionAvailable());\r\n", "\r\n    @Test\r\n    public void testEncodeDecode() throws Exception {\r\n        ByteBuf key = Unpooled.wrappedBuffer(\"key\".getBytes(CharsetUtil.UTF_8));\r\n        ByteBuf content = Unpooled.wrappedBuffer(\"content\".getBytes(CharsetUtil.UTF_8));\r\n", "                                return InetAddress.getByAddress(\"foo.com\", new byte[] { 1, 2, 3, 4 });\r\n                            } catch (UnknownHostException e) {\r\n                                throw new Error(e);\r\n                            }\r\n                        }\r\n", "                return Collections.emptySet();\r\n            }\r\n        });\r\n        dnsServerAuthority.start();\r\n\r\n", "            return response;\r\n        }\r\n\r\n        @Override\r\n        public InetSocketAddress sender() {\r\n", "\r\n        // amend options\r\n        if (RES_OPTIONS != null) {\r\n            parseResOptions(RES_OPTIONS, optionsBuilder);\r\n        }\r\n", "    /**\r\n     * Create {@link DnsQueryLifecycleObserver} instances that log events at the given log level.\r\n     * @param level The log level to use for logging resolver events.\r\n     */\r\n    public LoggingDnsQueryLifeCycleObserverFactory(LogLevel level) {\r\n", "                final Map<String, InetAddress> resultA = testResolve0(resolver, EXCLUSIONS_RESOLVE_A, AAAA);\r\n                for (Entry<String, InetAddress> resolvedEntry : resultA.entrySet()) {\r\n                    if (resolvedEntry.getValue().isLoopbackAddress()) {\r\n                        continue;\r\n                    }\r\n", "        }) {\r\n            @Override\r\n            protected DnsMessage filterMessage(DnsMessage message) {\r\n                // Store a original message so we can replay it later on.\r\n                messageRef.set(message);\r\n", "    }\r\n\r\n    @Test(timeout = 3000)\r\n    public void testTimeoutNotCached() {\r\n        DnsCache cache = new DnsCache() {\r\n", "        } else {\r\n            queryLifecycleObserver.queryCancelled(allowedQueries);\r\n        }\r\n\r\n        // We have at least one resolved record or tried CNAME as the last resort..\r\n", "        final String hostname = \"test.netty.io\";\r\n        final String ns1Name = \"ns1.\" + domain;\r\n        final InetSocketAddress ns1Address = new InetSocketAddress(\r\n                InetAddress.getByAddress(ns1Name, new byte[] { 10, 0, 0, 1 }),\r\n                DefaultDnsServerAddressStreamProvider.DNS_PORT);\r\n", "        try {\r\n            assertResponseEquals(response, response.content(), newInstance);\r\n        } finally {\r\n            response.release();\r\n            newInstance.release();\r\n", "                return Collections.emptySet();\r\n            }\r\n        });\r\n        server.start();\r\n        DnsNameResolver resolver = newResolver(ResolvedAddressTypes.IPV4_ONLY)\r\n", " * Contains all possible status values a {@link BinaryMemcacheResponse} can return.\r\n */\r\n@UnstableApi\r\npublic final class BinaryMemcacheResponseStatus {\r\n\r\n", "\r\n    @Before\r\n    public void setup() throws Exception {\r\n        channel = new EmbeddedChannel(\r\n                new BinaryMemcacheRequestEncoder(),\r\n", "            assertEntry(entries.get(0), addr1);\r\n            assertEntry(entries.get(1), addr2);\r\n        } finally {\r\n            group.shutdownGracefully();\r\n        }\r\n", "        switch (resolvedAddressTypes) {\r\n        case IPV4_ONLY:\r\n        case IPV4_PREFERRED:\r\n            return InternetProtocolFamily.IPv4;\r\n        case IPV6_ONLY:\r\n", "import java.util.LinkedHashMap;\r\nimport java.util.LinkedHashSet;\r\nimport java.util.List;\r\nimport java.util.Locale;\r\nimport java.util.Map;\r\n", "    public void queryFailed(Throwable cause) {\r\n        if (dnsServerAddress != null) {\r\n            logger.log(level, \"from {} : {} failure\", dnsServerAddress, question, cause);\r\n        } else {\r\n            logger.log(level, \"{} query never written and failed\", question, cause);\r\n", "public class BinaryMemcacheEncoderTest {\r\n\r\n    public static final int DEFAULT_HEADER_SIZE = 24;\r\n\r\n    private EmbeddedChannel channel;\r\n", "        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeControlFrameHeader(buf, type, flags, length);\r\n        buf.writeInt(streamId);\r\n        buf.writeInt(statusCode);\r\n\r\n", "                        requestResponseCounter.decrementAndGet();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n", "    private boolean completeEarly;\r\n\r\n    DnsResolveContext(DnsNameResolver parent, Promise<?> originalPromise,\r\n                      String hostname, int dnsClass, DnsRecordType[] expectedTypes,\r\n                      DnsRecord[] additionals, DnsServerAddressStream nameServerAddrs, int allowedQueries) {\r\n", "    }\r\n\r\n    @Test\r\n    public void defaultValueReturnedIfTimeoutOptionsIsNotPresent() throws IOException {\r\n        File f = buildFile(\"search localdomain\\n\" +\r\n", "                        .addFirst(\"codec\", new ProtocolCodecFilter(\r\n                                new TestDnsProtocolUdpCodecFactory(dropAAAAQueries)));\r\n            }\r\n        });\r\n\r\n", "\r\n    static final class TestResourceRecord extends ResourceRecordImpl {\r\n\r\n        TestResourceRecord(String domainName, RecordType recordType, Map<String, Object> attributes) {\r\n            super(domainName, recordType, RecordClass.IN, 100, attributes);\r\n", "            cache.cache(\"netty.io\", \"mapping2.netty.io\", 10000, loop);\r\n\r\n            assertEquals(\"mapping2.netty.io\", cache.get(\"netty.io\"));\r\n        } finally {\r\n            group.shutdownGracefully();\r\n", "\r\n        @Override\r\n        public void channelInactive(ChannelHandlerContext ctx) throws Exception {\r\n            super.channelInactive(ctx);\r\n\r\n", "        buf.release();\r\n    }\r\n\r\n    @Test\r\n    public void testIndependentSpdySynStreamFrame() throws Exception {\r\n", "        checkNotNull(promise, \"promise\");\r\n        DnsRecord[] additionalsArray = toArray(additionals, true);\r\n        try {\r\n            doResolveAll(inetHost, additionalsArray, promise, resolveCache);\r\n            return promise;\r\n", "    }\r\n\r\n    @Override\r\n    public BinaryMemcacheMessage retain(int increment) {\r\n        super.retain(increment);\r\n", "                    ByteBuf chunkBuffer = in.readRetainedSlice(toRead);\r\n\r\n                    MemcacheContent chunk;\r\n                    if ((alreadyReadChunkSize += toRead) >= valueLength) {\r\n                        chunk = new DefaultLastMemcacheContent(chunkBuffer);\r\n", "\r\n        Iterator<DnsRecord> additionalsIt = additionals.iterator();\r\n        if (!additionalsIt.hasNext()) {\r\n            return EMPTY_ADDITIONALS;\r\n        }\r\n", "                        if (o1.isUnresolved()) {\r\n                            return 1;\r\n                        } else {\r\n                            return -1;\r\n                        }\r\n", "                DefaultDnsServerAddressStreamProvider.DNS_PORT);\r\n        final InetSocketAddress ns2Address = new InetSocketAddress(\r\n                InetAddress.getByAddress(ns1Name, new byte[] { 10, 0, 0, 2 }),\r\n                DefaultDnsServerAddressStreamProvider.DNS_PORT);\r\n        final InetSocketAddress ns3Address = new InetSocketAddress(\r\n", "            DnsNameResolver resolver,\r\n            Map<String, Future<AddressedEnvelope<DnsResponse, InetSocketAddress>>> futures,\r\n            String hostname) {\r\n        futures.put(hostname, resolver.query(new DefaultDnsQuestion(hostname, DnsRecordType.MX)));\r\n    }\r\n", "        @Override\r\n        public InetSocketAddress next() {\r\n            if (resolved.hasNext()) {\r\n                return nextResolved0();\r\n            }\r\n", "                    map.put(new InetSocketAddress(toIPv4Address(a6), port), newContexts);\r\n                }\r\n            }\r\n\r\n            return newContexts;\r\n", "            assertResolvedAddress(resolver.resolve(domain).syncUninterruptibly().getNow(), ipv4Addr, domain);\r\n            assertEquals(2, server2Counter.get());\r\n            assertEquals(2, server3Counter.get());\r\n        } finally {\r\n            dnsServer2.stop();\r\n", "            throw new UnsupportedOperationException();\r\n        }\r\n\r\n        @Override\r\n        public Object get(long timeout, TimeUnit unit) {\r\n", "        if (cached == null || cached.isEmpty()) {\r\n            return null;\r\n        }\r\n        // We can never have more then one record.\r\n        return cached.get(0);\r\n", "                socket.getOutputStream().flush();\r\n                // Let's wait until we received the envelope before closing the socket.\r\n                envelopeFuture.syncUninterruptibly();\r\n\r\n                socket.close();\r\n", "            if (finalResult == null) {\r\n                finalResult = new ArrayList<T>(8);\r\n                finalResult.add(converted);\r\n            } else if (isDuplicateAllowed() || !finalResult.contains(converted)) {\r\n                finalResult.add(converted);\r\n", "\r\n        assertThat(channel.readInbound(), nullValue());\r\n\r\n        assertFalse(channel.finish());\r\n    }\r\n", "        this.dnsQueryLifecycleObserverFactory = checkNotNull(lifecycleObserverFactory, \"lifecycleObserverFactory\");\r\n        return this;\r\n    }\r\n\r\n    /**\r\n", "        fullResponse.setDataType(response.dataType());\r\n        fullResponse.setTotalBodyLength(response.totalBodyLength());\r\n        fullResponse.setOpaque(response.opaque());\r\n        fullResponse.setCas(response.cas());\r\n        fullResponse.setStatus(response.status());\r\n", "        @Override\r\n        public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\r\n            events.add(new QueryWrittenEvent(dnsServerAddress));\r\n        }\r\n\r\n", "    /**\r\n     * Ask this provider for the name servers to query for {@code hostname}.\r\n     * @param hostname The hostname for which to lookup the DNS server addressed to use.\r\n     *                 If this is the final {@link DnsServerAddressStreamProvider} to be queried then generally empty\r\n     *                 string or {@code '.'} correspond to the default {@link DnsServerAddressStream}.\r\n", "        final TestDnsServer dnsServer1 = new TestDnsServer(Collections.<String>emptySet()) {\r\n            @Override\r\n            protected DnsMessage filterMessage(DnsMessage message) {\r\n                promise.cancel(true);\r\n                return message;\r\n", "\r\n            assertResolvedAddress(resolver.resolve(domain).syncUninterruptibly().getNow(), ipv4Addr, domain);\r\n            assertEquals(1, server2Counter.get());\r\n            assertEquals(0, server3Counter.get());\r\n            assertResolvedAddress(resolver.resolve(domain).syncUninterruptibly().getNow(), ipv4Addr, domain);\r\n", "        public LastMemcacheContent retain() {\r\n            return this;\r\n        }\r\n\r\n        @Override\r\n", "            throws Exception {\r\n        DnsNameResolverBuilder builder = dnsResolverBuilder.copy();\r\n\r\n        // once again, channelFactory and nameServerProvider are most probably set in builder already,\r\n        // but I do reassign them again to avoid corner cases with override methods\r\n", "    @Test\r\n    public void testInvalidSpdySettingsFrameNumSettings() throws Exception {\r\n        short type = 4;\r\n        byte flags = 0;\r\n        int numSettings = 2;\r\n", "                    });\r\n                    tcpCtx.query(true, future.channel().newPromise());\r\n                }\r\n            });\r\n        }\r\n", "        IPV4ADDRESS3 = new InetSocketAddress(InetAddress.getByAddress(\"ns3\", new byte[] { 10, 0, 0, 3 }), 53);\r\n\r\n        IPV6ADDRESS1 = new InetSocketAddress(InetAddress.getByAddress(\r\n                \"ns1\", new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 }), 53);\r\n        IPV6ADDRESS2 = new InetSocketAddress(InetAddress.getByAddress(\r\n", "        try {\r\n            return DefaultDnsRecordDecoder.decodeName(in);\r\n        } catch (CorruptedFrameException e) {\r\n            // In this case we just return null.\r\n            return null;\r\n", "    public void attemptsOptionIsParsedIfPresent() throws IOException {\r\n        File f = buildFile(\"search localdomain\\n\" +\r\n            \"nameserver 127.0.0.11\\n\" +\r\n            \"options attempts:0\\n\");\r\n        assertEquals(0, parseEtcResolverOptions(f).attempts());\r\n", "                        return;\r\n                    }\r\n                }\r\n\r\n                queryLifecycleObserver.queryFailed(UNRECOGNIZED_TYPE_QUERY_FAILED_EXCEPTION);\r\n", "        headerBlock.release();\r\n    }\r\n\r\n    @Test\r\n    public void testOneNameValuePair() throws Exception {\r\n", "        // Ensure we remove the id from the QueryContextManager once the query completes.\r\n        promise.addListener(this);\r\n\r\n        if (parent.isOptResourceEnabled()) {\r\n            optResource = new AbstractDnsOptPseudoRrRecord(parent.maxPayloadSize(), 0, 0) {\r\n", "    private final DnsQueryLifecycleObserverFactory a;\r\n    private final DnsQueryLifecycleObserverFactory b;\r\n\r\n    /**\r\n     * Create a new instance.\r\n", "            doResolveUncached(hostname, additionals, promise, resolveCache, true);\r\n        }\r\n    }\r\n\r\n    private boolean doResolveCached(String hostname,\r\n", "    }\r\n\r\n    @Test\r\n    public void defaultValueReturnedIfNdotsOptionsNotPresent() throws IOException {\r\n        File f = buildFile(\"search localdomain\\n\" +\r\n", "    public DefaultBinaryMemcacheRequest(ByteBuf key, ByteBuf extras) {\r\n        super(key, extras);\r\n        setMagic(REQUEST_MAGIC_BYTE);\r\n    }\r\n\r\n", "            promise.tryFailure(cause);\r\n            return;\r\n        }\r\n\r\n        try {\r\n", "        final String overriddenIP = \"12.34.12.34\";\r\n        final TestDnsServer dnsServer2 = new TestDnsServer(new RecordStore() {\r\n            @Override\r\n            public Set<ResourceRecord> getRecords(QuestionRecord question) {\r\n                switch (question.getRecordType()) {\r\n", "package io.netty.handler.codec.memcache.binary;\r\n\r\nimport io.netty.channel.CombinedChannelDuplexHandler;\r\nimport io.netty.util.internal.UnstableApi;\r\n\r\n", "            \"google.com.eg\",\r\n            \"pixnet.net\",\r\n            \"localhost\")));\r\n\r\n    private static final Map<String, String> DOMAINS_PUNYCODE = new HashMap<String, String>();\r\n", "                new UnixResolverDnsServerAddressStreamProvider(f, folder.newFolder().listFiles());\r\n\r\n        DnsServerAddressStream stream = p.nameServerAddressStream(\"somehost\");\r\n        assertHostNameEquals(\"127.0.0.2\", stream.next());\r\n    }\r\n", "        }\r\n        return Collections.emptyList();\r\n    }\r\n\r\n    private static final DatagramDnsResponseDecoder DATAGRAM_DECODER = new DatagramDnsResponseDecoder() {\r\n", "            if (failOnMissingResponse) {\r\n                long missingResponses = requestResponseCounter.get();\r\n                if (missingResponses > 0) {\r\n                    ctx.fireExceptionCaught(new PrematureChannelClosureException(\r\n                        \"channel gone inactive with \" + missingResponses +\r\n", "                String dnsName = \"dns\" + idx + '.' + domain;\r\n                message.getAuthorityRecords().add(newNsRecord(name, dnsName));\r\n                message.getAdditionalRecords().add(newARecord(dnsName, i == 0 ? dnsAddress : \"1.2.3.\" + idx));\r\n\r\n                // Add an unresolved NS record (with no additionals as well)\r\n", "                new BinaryMemcacheRequestDecoder(),\r\n                new BinaryMemcacheObjectAggregator(1024));\r\n    }\r\n\r\n    @After\r\n", "                new UnixResolverDnsServerAddressStreamProvider(f, null);\r\n\r\n        DnsServerAddressStream stream = p.nameServerAddressStream(\"somehost\");\r\n        assertHostNameEquals(\"127.0.0.2\", stream.next());\r\n    }\r\n", "    }\r\n\r\n    @Override\r\n    public BinaryMemcacheMessage setKey(ByteBuf key) {\r\n        if (this.key != null) {\r\n", "                10, true, 4096, false, HostsFileEntriesResolver.DEFAULT,\r\n                new SingletonDnsServerAddressStreamProvider(dnsServer.localAddress()),\r\n                DnsNameResolver.DEFAULT_SEARCH_DOMAINS, 0, true) {\r\n            @Override\r\n            InetSocketAddress newRedirectServerAddress(InetAddress server) {\r\n", "                             Promise<List<T>> promise) {\r\n        final DnsQuestion cnameQuestion;\r\n        final DnsServerAddressStream stream;\r\n        try {\r\n            cname = cnameResolveFromCache(cnameCache(), cname);\r\n", "        @Override\r\n        public DnsServerAddressStream duplicate() {\r\n            return this;\r\n        }\r\n\r\n", "\r\n        content1.release();\r\n        content2.release();\r\n    }\r\n\r\n", "\r\n    @Test\r\n    public void shouldRetainByteBufWhenAggregating() {\r\n        channel = new EmbeddedChannel(\r\n                new BinaryMemcacheRequestEncoder(),\r\n", "                        // Server did not respond or I/O error occurred; try again.\r\n                        queryLifecycleObserver.queryFailed(queryCause);\r\n                        query(nameServerAddrStream, nameServerAddrStreamIndex + 1, question,\r\n                              newDnsQueryLifecycleObserver(question), true, promise, queryCause);\r\n                    }\r\n", "        assertThat(request, notNullValue());\r\n        request.release();\r\n\r\n        Object lastContent = channel.readInbound();\r\n        assertThat(lastContent, instanceOf(LastMemcacheContent.class));\r\n", "    FullBinaryMemcacheResponse retain(int increment);\r\n\r\n    @Override\r\n    FullBinaryMemcacheResponse retain();\r\n\r\n", "                serverSocket.close();\r\n            }\r\n\r\n            AddressedEnvelope<DnsResponse, InetSocketAddress> envelope = envelopeFuture.syncUninterruptibly().getNow();\r\n            assertNotNull(envelope.sender());\r\n", "    }\r\n\r\n    private static void testResolveAll0(ResolvedAddressTypes addressTypes, InetAddress expectedAddr, String name) {\r\n        DnsNameResolver resolver = newResolver(addressTypes).build();\r\n        try {\r\n", "    DatagramDnsQueryContext(DnsNameResolver parent, InetSocketAddress nameServerAddr, DnsQuestion question,\r\n                            DnsRecord[] additionals,\r\n                            Promise<AddressedEnvelope<DnsResponse, InetSocketAddress>> promise) {\r\n        super(parent, nameServerAddr, question, additionals, promise);\r\n    }\r\n", "            @Override\r\n            public Set<ResourceRecord> getRecords(QuestionRecord question) {\r\n                server3Counter.incrementAndGet();\r\n                ResourceRecordModifier rm = new ResourceRecordModifier();\r\n                rm.setDnsClass(RecordClass.IN);\r\n", "            }\r\n            assertThat(content.content().readableBytes(), is(2));\r\n            content.release();\r\n        }\r\n        assertThat(channel.readInbound(), nullValue());\r\n", "    @Override\r\n    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\r\n        super.channelInactive(ctx);\r\n\r\n        resetDecoder();\r\n", "                }\r\n            }\r\n            DnsNameResolver resolver = newResolver(false, new DnsServerAddressStreamProvider() {\r\n                @Override\r\n                public DnsServerAddressStream nameServerAddressStream(String hostname) {\r\n", "import java.net.InetSocketAddress;\r\nimport java.util.Comparator;\r\nimport java.util.concurrent.Callable;\r\nimport java.util.concurrent.TimeUnit;\r\n\r\n", "                if (bytes == null) {\r\n                    throw new IllegalStateException(resourceRecord.get(DnsAttribute.IP_ADDRESS));\r\n                }\r\n                // encode the ::1\r\n                ioBuffer.put(bytes);\r\n", "@UnstableApi\r\npublic final class BinaryMemcacheOpcodes {\r\n\r\n    private BinaryMemcacheOpcodes() {\r\n        // disallow construction\r\n", "    @Test(expected = EncoderException.class)\r\n    public void shouldFailWithoutLastContent() {\r\n        channel.writeOutbound(new DefaultMemcacheContent(Unpooled.EMPTY_BUFFER));\r\n        channel.writeOutbound(new DefaultBinaryMemcacheRequest());\r\n    }\r\n", "        verify(delegate).readGoAwayFrame(lastGoodStreamId, statusCode);\r\n        assertFalse(buf.isReadable());\r\n        buf.release();\r\n    }\r\n\r\n", "        encodeControlFrameHeader(buf, type, flags, length + headerBlockLength);\r\n        buf.writeInt(streamId);\r\n\r\n        ByteBuf headerBlock = Unpooled.buffer(headerBlockLength);\r\n        for (int i = 0; i < 256; i ++) {\r\n", "            InetAddress addr = resolver.resolve(inetHost).syncUninterruptibly().getNow();\r\n            assertEquals(SocketUtils.addressByName(inetHost), addr);\r\n        } finally {\r\n            resolver.close();\r\n        }\r\n", "        }\r\n        ch = future.channel();\r\n        ch.config().setRecvByteBufAllocator(new FixedRecvByteBufAllocator(maxPayloadSize));\r\n\r\n        ch.closeFuture().addListener(new ChannelFutureListener() {\r\n", "        DnsNameResolver resolver = null;\r\n        try {\r\n            DnsNameResolverBuilder builder = newResolver()\r\n                    .recursionDesired(true)\r\n                    .maxQueriesPerResolve(16)\r\n", "            cache.cache(\"netty.io\", \"mapping.netty.io\", TimeUnit.DAYS.toSeconds(days), loop);\r\n            assertEquals(\"mapping.netty.io\", cache.get(\"netty.io\"));\r\n        } finally {\r\n            group.shutdownGracefully();\r\n        }\r\n", "        public DecoderResult decoderResult() {\r\n            return DecoderResult.SUCCESS;\r\n        }\r\n\r\n        @Override\r\n", "                // Also add the mapping for the IPv4 address if this IPv6 address is compatible.\r\n                final Inet6Address a6 = (Inet6Address) a;\r\n                if (a6.isLoopbackAddress()) {\r\n                    map.put(new InetSocketAddress(NetUtil.LOCALHOST4, port), newContexts);\r\n                } else if (a6.isIPv4CompatibleAddress()) {\r\n", "    private DefaultFullBinaryMemcacheRequest newInstance(ByteBuf key, ByteBuf extras, ByteBuf content) {\r\n        DefaultFullBinaryMemcacheRequest newInstance = new DefaultFullBinaryMemcacheRequest(key, extras, content);\r\n        copyMeta(newInstance);\r\n        return newInstance;\r\n    }\r\n", "                        new TestResourceRecord(name, questionRecord.getRecordType(), attr));\r\n            }\r\n            return null;\r\n        }\r\n    }\r\n", "            } else if (o instanceof QueryWrittenEvent) {\r\n                QuerySucceededEvent succeededEvent = (QuerySucceededEvent) observer.events.poll();\r\n            } else {\r\n                fail(\"unexpected event type: \" + o);\r\n            }\r\n", "\r\n    @Test\r\n    public void testSpdySynReplyFrame() throws Exception {\r\n        short type = 2;\r\n        byte flags = 0;\r\n", "            }\r\n        };\r\n\r\n        final AtomicReference<DnsServerAddressStream> redirectedRef = new AtomicReference<DnsServerAddressStream>();\r\n        final DnsNameResolver resolver = new DnsNameResolver(\r\n", "\r\n    @Override\r\n    public String toString() {\r\n        return StringUtil.simpleClassName(this) + '(' + delegate + ')';\r\n    }\r\n", "import io.netty.handler.codec.memcache.binary.BinaryMemcacheRequestDecoder;\r\nimport io.netty.handler.codec.memcache.binary.BinaryMemcacheResponseEncoder;\r\nimport io.netty.util.internal.UnstableApi;\r\n\r\n/**\r\n", "        }\r\n        if (msg instanceof MemcacheContent) {\r\n            return ((MemcacheContent) msg).content().retain();\r\n        }\r\n        if (msg instanceof FileRegion) {\r\n", "        }\r\n        final ChannelPromise writePromise = parent.ch.newPromise();\r\n        final Promise<AddressedEnvelope<? extends DnsResponse, InetSocketAddress>> queryPromise =\r\n                parent.ch.eventLoop().newPromise();\r\n\r\n", "\r\n    private final class CombinedDnsServerAddressStream implements DnsServerAddressStream {\r\n        private final InetSocketAddress replaced;\r\n        private final DnsServerAddressStream originalStream;\r\n        private final List<InetAddress> resolvedAddresses;\r\n", "        return resolveAll(inetHost, executor.<List<T>>newPromise());\r\n    }\r\n\r\n    @Override\r\n    public void close() {\r\n", "                    final Channel channel = future.channel();\r\n\r\n                    Promise<AddressedEnvelope<DnsResponse, InetSocketAddress>> promise =\r\n                            channel.eventLoop().newPromise();\r\n                    final TcpDnsQueryContext tcpCtx = new TcpDnsQueryContext(DnsNameResolver.this, channel,\r\n", "        query.addRecord(DnsSection.QUESTION, question);\r\n\r\n        for (DnsRecord record: additionals) {\r\n            query.addRecord(DnsSection.ADDITIONAL, record);\r\n        }\r\n", "import java.net.InetSocketAddress;\r\nimport java.util.Collections;\r\nimport java.util.Comparator;\r\nimport java.util.List;\r\nimport java.util.concurrent.ConcurrentMap;\r\n", "            // We should have put the unresolved address in the AuthoritativeDnsServerCache (but only 1 time)\r\n            assertEquals(unresolved(ns1Address), cached.get(2));\r\n        } finally {\r\n            resolver.close();\r\n            group.shutdownGracefully(0, 0, TimeUnit.SECONDS);\r\n", "            DnsResolveContextException.newStatic(\"No answer found and NXDOMAIN response code returned\",\r\n            DnsResolveContext.class, \"onResponse(..)\");\r\n    private static final RuntimeException CNAME_NOT_FOUND_QUERY_FAILED_EXCEPTION =\r\n            DnsResolveContextException.newStatic(\"No matching CNAME record found\",\r\n            DnsResolveContext.class, \"onResponseCNAME(..)\");\r\n", "            this.ndots = ndots;\r\n        }\r\n\r\n        void setTimeout(int timeout) {\r\n            this.timeout = timeout;\r\n", "        headerBlock.writeBytes(valueBytes);\r\n        decoder.decode(ByteBufAllocator.DEFAULT, headerBlock, frame);\r\n        decoder.endHeaderBlock(frame);\r\n\r\n        assertFalse(headerBlock.isReadable());\r\n", "\r\n        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeControlFrameHeader(buf, type, flags, length);\r\n        buf.writeInt(streamId);\r\n        buf.writeInt(associatedToStreamId);\r\n", "        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeControlFrameHeader(buf, type, flags, length);\r\n        buf.writeInt(streamId);\r\n        buf.writeInt(associatedToStreamId);\r\n\r\n", "                            question.getDomainName(), RecordType.CNAME,\r\n                            Collections.<String, Object>singletonMap(\r\n                                    DnsAttribute.DOMAIN_NAME.toLowerCase(), \"x.netty.io\")));\r\n                }\r\n                return Collections.emptySet();\r\n", "        cache.cache(ns1Name, null, ns1Address.getAddress(), 10000, loop);\r\n        cache.cache(ns1Name, null, ns2Address.getAddress(), 10000, loop);\r\n        cache.cache(ns1Name, null, ns3Address.getAddress(), 10000, loop);\r\n        cache.cache(ns1Name, null, ns4Address.getAddress(), 10000, loop);\r\n\r\n", "        buf.writeInt(numSettings);\r\n        for (int i = 0; i < numSettings; i++) {\r\n            buf.writeByte(idFlags);\r\n            buf.writeMedium(id);\r\n            buf.writeInt(value);\r\n", "        buf.writeInt(numSettings);\r\n        for (int i = 0; i < numSettings; i++) {\r\n            buf.writeByte(idFlags);\r\n            buf.writeMedium(id);\r\n            buf.writeInt(value);\r\n", "        buf.writeInt(numSettings);\r\n        for (int i = 0; i < numSettings; i++) {\r\n            buf.writeByte(idFlags);\r\n            buf.writeMedium(id);\r\n            buf.writeInt(value);\r\n", "                    List<InetAddress> resolvedAddresses = future.getNow();\r\n                    DnsServerAddressStream addressStream = new CombinedDnsServerAddressStream(\r\n                            nameServerAddr, resolvedAddresses, nameServerAddrStream);\r\n                    query(addressStream, nameServerAddrStreamIndex, question,\r\n                          queryLifecycleObserver, true, promise, cause);\r\n", "        headerBlock.release();\r\n    }\r\n\r\n    @Test\r\n    public void testZeroNameValuePairs() throws Exception {\r\n", "\r\n    @Override\r\n    public String toString() {\r\n        return StringUtil.simpleClassName(this) +\r\n               \"(data: \" + content() + \", decoderResult: \" + decoderResult() + ')';\r\n", "\r\n        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeControlFrameHeader(buf, type, flags, length);\r\n        buf.writeInt(streamId);\r\n\r\n", "\r\n        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeControlFrameHeader(buf, type, flags, length);\r\n        buf.writeInt(streamId);\r\n\r\n", "\r\n        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeControlFrameHeader(buf, type, flags, length);\r\n        buf.writeInt(streamId);\r\n\r\n", "        return this;\r\n    }\r\n\r\n    @Override\r\n    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\r\n", "        return this;\r\n    }\r\n\r\n    @Override\r\n    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\r\n", "     * The timeout of each DNS query performed by this resolver (in seconds).\r\n     * The default value is {@code 5}.\r\n     */\r\n    int timeout() {\r\n        return timeout;\r\n", "                    QueryFailedEvent failedEvent = (QueryFailedEvent) observer.events.poll();\r\n                } else if (!(o instanceof QueryFailedEvent)) {\r\n                    fail(\"unexpected event type: \" + o);\r\n                }\r\n                assertTrue(observer.events.isEmpty());\r\n", "    private HostsFileEntriesResolver hostsFileEntriesResolver = HostsFileEntriesResolver.DEFAULT;\r\n    private DnsServerAddressStreamProvider dnsServerAddressStreamProvider =\r\n            DnsServerAddressStreamProviders.platformDefault();\r\n    private DnsQueryLifecycleObserverFactory dnsQueryLifecycleObserverFactory =\r\n            NoopDnsQueryLifecycleObserverFactory.INSTANCE;\r\n", "\r\n        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeControlFrameHeader(buf, type, flags, length);\r\n        buf.writeInt(streamId | 0x80000000); // should ignore reserved bit\r\n        buf.writeInt(statusCode);\r\n", "\r\n    @Test\r\n    public void shouldEncodeContent() {\r\n        DefaultMemcacheContent content1 =\r\n            new DefaultMemcacheContent(Unpooled.copiedBuffer(\"Netty\", CharsetUtil.UTF_8));\r\n", "        request.release();\r\n\r\n        lastContent = channel.readInbound();\r\n        assertThat(lastContent, instanceOf(LastMemcacheContent.class));\r\n        ((ReferenceCounted) lastContent).release();\r\n", "                InetSocketAddress newRedirectServerAddress(InetAddress server) {\r\n                    int port = hitServer2.get() ? dnsServer3.localAddress().getPort() :\r\n                            dnsServer2.localAddress().getPort();\r\n                    return new InetSocketAddress(server, port);\r\n                }\r\n", "                if (server.equals(dnsServerAuthority.localAddress().getAddress())) {\r\n                    return new InetSocketAddress(server, dnsServerAuthority.localAddress().getPort());\r\n                }\r\n                return super.newRedirectServerAddress(server);\r\n            }\r\n", "    void cache(String hostname, DnsRecord[] additionals,\r\n               DnsRecord result, InetAddress convertedResult) {\r\n        resolveCache.cache(hostname, additionals, convertedResult, result.timeToLive(), parent.ch.eventLoop());\r\n    }\r\n\r\n", "                    delegate.resolveAll(inetHost, castPromise);\r\n                } else {\r\n                    @SuppressWarnings(\"unchecked\")\r\n                    final Promise<T> castPromise = (Promise<T>) promise; // U is T\r\n                    delegate.resolve(inetHost, castPromise);\r\n", "            events.add(new QueryFailedEvent(cause));\r\n        }\r\n\r\n        @Override\r\n        public void querySucceed() {\r\n", "        }\r\n    }\r\n\r\n    private static Map<String, InetAddress> testResolve0(DnsNameResolver resolver, Set<String> excludedDomains,\r\n                                                         DnsRecordType cancelledType)\r\n", "        promise.tryFailure(unknownHostException);\r\n    }\r\n\r\n    static String decodeDomainName(ByteBuf in) {\r\n        in.markReaderIndex();\r\n", "            }\r\n        };\r\n        dnsServer1.start();\r\n        final AtomicBoolean isQuerySentToSecondServer = new AtomicBoolean();\r\n        final TestDnsServer dnsServer2 = new TestDnsServer(Collections.<String>emptySet()) {\r\n", "    }\r\n\r\n    public BinaryMemcacheResponseDecoder(int chunkSize) {\r\n        super(chunkSize);\r\n    }\r\n", "        @Override\r\n        public ProtocolDecoder getDecoder(IoSession session) {\r\n            return new ProtocolDecoderAdapter() {\r\n                private DnsMessageDecoder decoder = new DnsMessageDecoder();\r\n\r\n", "                new SingletonDnsServerAddressStreamProvider(redirectServer.localAddress()),\r\n                DnsNameResolver.DEFAULT_SEARCH_DOMAINS, 0, true) {\r\n\r\n            @Override\r\n            protected DnsServerAddressStream newRedirectDnsServerStream(\r\n", "\r\n    @Override\r\n    void cache(String hostname, DnsRecord[] additionals, UnknownHostException cause) {\r\n        // Do not cache.\r\n        // XXX: When we implement cache, we would need to retain the reference count of the result record.\r\n", "\r\n    @Override\r\n    public int compare(InetAddress o1, InetAddress o2) {\r\n        if (o1.getClass() == o2.getClass()) {\r\n            return 0;\r\n", "            resolver.resolve(domain).syncUninterruptibly();\r\n            List<? extends DnsCacheEntry> cached = cache.get(domain, null);\r\n            List<? extends DnsCacheEntry> cached2 = cache.get(domainWithDot, null);\r\n\r\n            assertEquals(1, cached.size());\r\n", "/**\r\n * This interface provides visibility into individual DNS queries. The lifecycle of an objects is as follows:\r\n * <ol>\r\n *     <li>Object creation</li>\r\n *     <li>{@link #queryCancelled(int)}</li>\r\n", "    void doSearchDomainQuery(String hostname, Promise<List<T>> nextPromise) {\r\n        DnsResolveContext<T> nextContext = newResolverContext(parent, originalPromise, hostname, dnsClass,\r\n                                                              expectedTypes, additionals, nameServerAddrs,\r\n                parent.maxQueriesPerResolve());\r\n        nextContext.internalResolve(hostname, nextPromise);\r\n", "\r\n        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeControlFrameHeader(buf, type, flags, length + headerBlockLength);\r\n        buf.writeInt(streamId);\r\n\r\n", "                                                    Promise<List<DnsRecord>> promise) {\r\n        final DnsRecord[] additionalsArray = toArray(additionals, true);\r\n        return resolveAll(question, additionalsArray, promise);\r\n    }\r\n\r\n", "\r\n        assertThat(request, notNullValue());\r\n        assertThat(request.key(), notNullValue());\r\n        assertThat(request.extras(), nullValue());\r\n\r\n", "                assertEquals(dnsServerAuthority.localAddress(), writtenEvent1.dnsServerAddress);\r\n                succeededEvent = (QuerySucceededEvent) observer.events.poll();\r\n\r\n                resolver.resolveAll(hostname2).syncUninterruptibly();\r\n\r\n", "                            message.getAuthorityRecords().add(TestDnsServer.newNsRecord(domain, ns1Name));\r\n                        } else {\r\n                            message.getAuthorityRecords().add(TestDnsServer.newNsRecord(domain, ns1Name));\r\n                            message.getAuthorityRecords().add(TestDnsServer.newNsRecord(domain, ns2Name));\r\n                        }\r\n", "            // We want to ensure we do not have duplicates in finalResult as this may be unexpected.\r\n            //\r\n            // While using a LinkedHashSet or HashSet may sound like the perfect fit for this we will use an\r\n            // ArrayList here as duplicates should be found quite unfrequently in the wild and we dont want to pay\r\n            // for the extra memory copy and allocations in this cases later on.\r\n", "            a.queryCancelled(queriesRemaining);\r\n        } finally {\r\n            b.queryCancelled(queriesRemaining);\r\n        }\r\n    }\r\n", "                .resolvedAddressTypes(types)\r\n                .ndots(1)\r\n                .searchDomains(singletonList(\".\")).build();\r\n        try {\r\n            resolver.resolve(\"invalid.com\").syncUninterruptibly();\r\n", "            observer = lifecycleObserverFactory.observers.poll();\r\n            assertEquals(2, observer.events.size());\r\n            writtenEvent = (QueryWrittenEvent) observer.events.poll();\r\n            assertEquals(dnsServer2.localAddress(), writtenEvent.dnsServerAddress);\r\n            QuerySucceededEvent succeededEvent = (QuerySucceededEvent) observer.events.poll();\r\n", "    protected DnsMessage filterMessage(DnsMessage message) {\r\n        return message;\r\n    }\r\n\r\n    protected static ResourceRecord newARecord(String name, String ipAddress) {\r\n", "        header.setOpcode(in.readByte());\r\n        header.setKeyLength(in.readShort());\r\n        header.setExtrasLength(in.readByte());\r\n        header.setDataType(in.readByte());\r\n        header.setStatus(in.readShort());\r\n", "\r\n    private final DnsNameResolverBuilder dnsResolverBuilder;\r\n\r\n    private final ConcurrentMap<String, Promise<InetAddress>> resolvesInProgress = newConcurrentHashMap();\r\n    private final ConcurrentMap<String, Promise<List<InetAddress>>> resolveAllsInProgress = newConcurrentHashMap();\r\n", "            if (earlyPromise.isDone()) {\r\n                transferResult(earlyPromise, promise);\r\n            } else {\r\n                earlyPromise.addListener(new FutureListener<U>() {\r\n                    @Override\r\n", "\r\n    @Before\r\n    public void setup() throws Exception {\r\n        channel = new EmbeddedChannel(new BinaryMemcacheRequestEncoder());\r\n    }\r\n", "\r\n    @Override\r\n    protected BinaryMemcacheResponse decodeHeader(ByteBuf in) {\r\n        DefaultBinaryMemcacheResponse header = new DefaultBinaryMemcacheResponse();\r\n        header.setMagic(in.readByte());\r\n", "        b.option(ChannelOption.DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION, true);\r\n        final DnsResponseHandler responseHandler = new DnsResponseHandler(executor().<Channel>newPromise());\r\n        b.handler(new ChannelInitializer<DatagramChannel>() {\r\n            @Override\r\n            protected void initChannel(DatagramChannel ch) {\r\n", "        @Override\r\n        public AddressedEnvelope<DnsResponse, InetSocketAddress> touch() {\r\n            response.touch();\r\n            return this;\r\n        }\r\n", "    /**\r\n     * Sets if this resolver should generate the detailed trace information in an exception message so that\r\n     * it is easier to understand the cause of resolution failure.\r\n     *\r\n     * @param traceEnabled true if trace is enabled\r\n", "            resolver = builder.build();\r\n            List<InetAddress> resolvedAddresses =\r\n                    resolver.resolveAll(\"somehost.netty.io\").syncUninterruptibly().getNow();\r\n            assertEquals(2, resolvedAddresses.size());\r\n            assertTrue(resolvedAddresses.contains(InetAddress.getByAddress(new byte[] { 10, 0, 0, 99 })));\r\n", "                    key.readableBytes(), extras.readableBytes(), 0);\r\n\r\n            testSettingLengths(new DefaultBinaryMemcacheResponse(), 0, 0, 0);\r\n            testSettingLengths(new DefaultBinaryMemcacheResponse(key.retain()), key.readableBytes(), 0, 0);\r\n            testSettingLengths(new DefaultBinaryMemcacheResponse(key.retain(), extras.retain()),\r\n", "    public void testSpdySynStreamFrame() throws Exception {\r\n        short type = 1;\r\n        byte flags = 0;\r\n        int length = 10;\r\n        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;\r\n", "    DnsNameResolver parent() {\r\n        return parent;\r\n    }\r\n\r\n    protected abstract DnsQuery newQuery(int id);\r\n", "    public DecoderResult decoderResult() {\r\n        return decoderResult;\r\n    }\r\n\r\n    @Override\r\n", "    }\r\n\r\n    @Test(timeout = DEFAULT_TEST_TIMEOUT_MS)\r\n    public void testNonCachedResolveAllEmptyHostName() throws Exception {\r\n        testNonCachedResolveAllEmptyHostName(\"\");\r\n", "\r\n        DnsAddressStreamList(DnsServerAddressStream stream) {\r\n            duplicate = stream.duplicate();\r\n        }\r\n\r\n", "        UnixResolverDnsServerAddressStreamProvider p =\r\n                new UnixResolverDnsServerAddressStreamProvider(f, f2);\r\n\r\n        DnsServerAddressStream stream = p.nameServerAddressStream(\"somehost\");\r\n        assertHostNameEquals(\"127.0.0.2\", stream.next());\r\n", "            QueryWrittenEvent writtenEvent2 = (QueryWrittenEvent) observer.events.poll();\r\n            assertEquals(dnsServerAuthority.localAddress(), writtenEvent2.dnsServerAddress);\r\n            QuerySucceededEvent succeededEvent = (QuerySucceededEvent) observer.events.poll();\r\n\r\n            if (cache) {\r\n", "        server.start();\r\n        DnsNameResolver resolver = newResolver(ResolvedAddressTypes.IPV4_ONLY)\r\n                .searchDomains(Collections.singletonList(\"netty.io\"))\r\n                .nameServerProvider(new SingletonDnsServerAddressStreamProvider(server.localAddress()))\r\n                .resolveCache(cache).build();\r\n", "import java.util.Map.Entry;\r\nimport java.util.Queue;\r\nimport java.util.Set;\r\nimport java.util.concurrent.CancellationException;\r\nimport java.util.concurrent.ConcurrentHashMap;\r\n", "        int x = comparator.compare(UNRESOLVED1, UNRESOLVED2);\r\n        int y = comparator.compare(UNRESOLVED2, UNRESOLVED1);\r\n\r\n        assertEquals(0, x);\r\n        assertEquals(x, -y);\r\n", "        headerBlock.writeInt(0);\r\n        decoder.decode(ByteBufAllocator.DEFAULT, headerBlock, frame);\r\n\r\n        assertFalse(headerBlock.isReadable());\r\n        assertTrue(frame.isInvalid());\r\n", "\r\n    @Override\r\n    protected BinaryMemcacheRequest decodeHeader(ByteBuf in) {\r\n        DefaultBinaryMemcacheRequest header = new DefaultBinaryMemcacheRequest();\r\n        header.setMagic(in.readByte());\r\n", "        assertThat(seq.stream(), is(sameInstance(seq.stream())));\r\n\r\n        DnsServerAddressStream i = seq.stream();\r\n        assertNext(i, ADDR1);\r\n        assertNext(i, ADDR1);\r\n", "            containsString(\"foo.com\"));\r\n    }\r\n\r\n    @Test\r\n    public void testExceptionMsgDoesNotContainSearchDomainIfNdotsIsNotReached() throws Exception {\r\n", "    }\r\n\r\n    @Test(timeout = DEFAULT_TEST_TIMEOUT_MS)\r\n    public void testNonCachedResolveEmptyHostName() throws Exception {\r\n        testNonCachedResolveEmptyHostName(\"\");\r\n", "        return domainToNameServerStreamMap;\r\n    }\r\n\r\n    private static void putIfAbsent(Map<String, DnsServerAddresses> domainToNameServerStreamMap,\r\n                                    String domainName,\r\n", "    private FullBinaryMemcacheResponse newInstance(ByteBuf key, ByteBuf extras, ByteBuf content) {\r\n        DefaultFullBinaryMemcacheResponse newInstance = new DefaultFullBinaryMemcacheResponse(key, extras, content);\r\n        copyMeta(newInstance);\r\n        return newInstance;\r\n    }\r\n", "    public MultiDnsServerAddressStreamProvider(List<DnsServerAddressStreamProvider> providers) {\r\n        this.providers = providers.toArray(new DnsServerAddressStreamProvider[0]);\r\n    }\r\n\r\n    /**\r\n", "\r\n    private static InetSocketAddress validateRemoteAddress(InetSocketAddress remoteAddress) {\r\n        return ObjectUtil.checkNotNull(remoteAddress, \"remoteAddress\");\r\n    }\r\n\r\n", "    public int compare(InetSocketAddress addr1, InetSocketAddress addr2) {\r\n        if (addr1.equals(addr2)) {\r\n            return 0;\r\n        }\r\n        if (!addr1.isUnresolved() && !addr2.isUnresolved()) {\r\n", "    public DefaultBinaryMemcacheResponse(ByteBuf key, ByteBuf extras) {\r\n        super(key, extras);\r\n        setMagic(RESPONSE_MAGIC_BYTE);\r\n    }\r\n\r\n", "        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeControlFrameHeader(buf, type, flags, length);\r\n        buf.writeInt(streamId);\r\n        buf.writeInt(associatedToStreamId);\r\n        buf.writeByte(priority << 5);\r\n", "        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeControlFrameHeader(buf, type, flags, length);\r\n        buf.writeInt(streamId);\r\n        buf.writeInt(associatedToStreamId);\r\n        buf.writeByte(priority << 5);\r\n", "        }\r\n\r\n        @Override\r\n        public int hashCode() {\r\n            return System.identityHashCode(this);\r\n", "\r\n        decoder.decode(buf);\r\n        verify(delegate).readGoAwayFrame(lastGoodStreamId, statusCode);\r\n        assertFalse(buf.isReadable());\r\n        buf.release();\r\n", "\r\n    @Override\r\n    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\r\n        try {\r\n            a.queryCNAMEd(cnameQuestion);\r\n", "                            if (record.getRecordType() == RecordType.AAAA) {\r\n                                return;\r\n                            }\r\n                        }\r\n                    }\r\n", "\r\n        // return what was on the 'domain' line only if there were no 'search' lines\r\n        return localDomain != null && searchDomains.isEmpty()\r\n                ? Collections.singletonList(localDomain)\r\n                : searchDomains;\r\n", "        return this;\r\n    }\r\n\r\n    @Override\r\n    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\r\n", "    public DnsServerAddressStream stream() {\r\n        for (;;) {\r\n            int curStartIdx = startIdx;\r\n            int nextStartIdx = curStartIdx + 1;\r\n            if (nextStartIdx >= addresses.size()) {\r\n", "    public void releaseBuffers() {\r\n        testDelegate.releaseAll();\r\n    }\r\n\r\n    private final class TestSpdyFrameDecoderDelegate implements SpdyFrameDecoderDelegate {\r\n", "        content.release();\r\n\r\n        // Second message\r\n        response = channel.readInbound();\r\n        assertThat(response.status(), is(BinaryMemcacheResponseStatus.KEY_ENOENT));\r\n", "\r\n    private DnsRecordResolveContext(DnsNameResolver parent, Promise<?> originalPromise, String hostname,\r\n                                    int dnsClass, DnsRecordType[] expectedTypes,\r\n                                    DnsRecord[] additionals,\r\n                                    DnsServerAddressStream nameServerAddrs,\r\n", "                        }\r\n                    } else if (compareAndSet(entries, singletonList(e))) {\r\n                        scheduleCacheExpirationIfNeeded(ttl, loop);\r\n                        return;\r\n                    }\r\n", "        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeControlFrameHeader(buf, type, flags, length);\r\n        buf.writeInt(streamId | 0x80000000); // should ignore reserved bit\r\n        buf.writeInt(deltaWindowSize | 0x80000000); // should ignore reserved bit\r\n\r\n", "    @Override\r\n    protected final AddressResolver<InetSocketAddress> newResolver(EventExecutor executor) throws Exception {\r\n        if (!(executor instanceof EventLoop)) {\r\n            throw new IllegalStateException(\r\n                    \"unsupported executor type: \" + StringUtil.simpleClassName(executor) +\r\n", "                return message;\r\n            }\r\n\r\n            private ResourceRecord newARecord(InetSocketAddress address) {\r\n                return TestDnsServer.newARecord(address.getHostName(), address.getAddress().getHostAddress());\r\n", "                return message;\r\n            }\r\n\r\n            private ResourceRecord newARecord(InetSocketAddress address) {\r\n                return TestDnsServer.newARecord(address.getHostName(), address.getAddress().getHostAddress());\r\n", "\r\nfinal class DirContextUtils {\r\n    private static final InternalLogger logger =\r\n            InternalLoggerFactory.getInstance(DirContextUtils.class);\r\n\r\n", "        fullRequest.setReserved(request.reserved());\r\n\r\n        return fullRequest;\r\n    }\r\n\r\n", "                Arrays.asList(hostname, hostname2)));\r\n        dnsServerAuthority.start();\r\n\r\n        TestDnsServer dnsServer = new RedirectingTestDnsServer(hostname,\r\n                dnsServerAuthority.localAddress().getAddress().getHostAddress());\r\n", "        }\r\n\r\n        @Override\r\n        public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\r\n            events.add(new QueryNoAnswerEvent(code));\r\n", "    }\r\n\r\n    public BinaryMemcacheRequestDecoder(int chunkSize) {\r\n        super(chunkSize);\r\n    }\r\n", "                } else if (opt.startsWith(\"attempts:\")) {\r\n                    builder.setAttempts(parseResIntOption(opt, \"attempts:\"));\r\n                } else if (opt.startsWith(\"timeout:\")) {\r\n                    builder.setTimeout(parseResIntOption(opt, \"timeout:\"));\r\n                }\r\n", " * p.addLast(\"encoder\", new {@link BinaryMemcacheResponseEncoder}());\r\n * p.addLast(\"handler\", new YourMemcacheRequestHandler());\r\n * </pre>\r\n */\r\n@UnstableApi\r\n", "\r\n    @Test\r\n    public void ignoreInvalidEntries() throws Exception {\r\n        File f = buildFile(\"domain netty.local\\n\" +\r\n                \"nameserver nil\\n\" +\r\n", "\r\n    @Test\r\n    public void testIllegalSpdyDataFrameStreamId() throws Exception {\r\n        int streamId = 0; // illegal stream identifier\r\n        byte flags = 0;\r\n", "                checkNotNull(dnsServerAddressStreamProvider, \"dnsServerAddressStreamProvider\");\r\n        return this;\r\n    }\r\n\r\n    /**\r\n", "    @Override\r\n    public DnsServerAddressStream stream() {\r\n        return stream;\r\n    }\r\n\r\n", "        final TestDnsServer dnsServer1 = new TestDnsServer(Collections.singleton(\"notnetty.com\"));\r\n        final TestDnsServer dnsServer2 = new TestDnsServer(Collections.singleton(knownHostName));\r\n        DnsNameResolver resolver = null;\r\n        try {\r\n            final InetSocketAddress dnsServer1Address;\r\n", "        }\r\n\r\n        assertQueryObserver(resolver, cancelledType);\r\n\r\n        return results;\r\n", "\r\n    @Before\r\n    public void setup() throws Exception {\r\n        channel = new EmbeddedChannel(new BinaryMemcacheRequestDecoder());\r\n    }\r\n", "        int smallBatchSize = 2;\r\n        channel = new EmbeddedChannel(\r\n            new BinaryMemcacheRequestDecoder(smallBatchSize),\r\n            new BinaryMemcacheObjectAggregator(MAX_CONTENT_SIZE));\r\n\r\n", "    @Override\r\n    public String get(String hostname) {\r\n        return null;\r\n    }\r\n\r\n", "                                        ctx.channel().remoteAddress(), cause);\r\n                            }\r\n                        }\r\n                    });\r\n\r\n", "                // This can happen if we enabled EDNS0 but our MTU is not big enough to handle all the\r\n                // data.\r\n                response.setTruncated(true);\r\n\r\n                if (logger.isDebugEnabled()) {\r\n", "    public FullBinaryMemcacheRequest duplicate() {\r\n        ByteBuf key = key();\r\n        if (key != null) {\r\n            key = key.duplicate();\r\n        }\r\n", "                public DatagramChannel newChannel() {\r\n                    throw exception;\r\n                }\r\n            }).build();\r\n            fail();\r\n", "    /**\r\n     * Creates a new instance with the specified content.\r\n     */\r\n    public DefaultMemcacheContent(ByteBuf content) {\r\n        this.content = ObjectUtil.checkNotNull(content, \"content\");\r\n", "            this.response = response;\r\n        }\r\n\r\n        @Override\r\n        public DnsResponse content() {\r\n", "    @Override\r\n    BinaryMemcacheRequest touch();\r\n\r\n    @Override\r\n    BinaryMemcacheRequest touch(Object hint);\r\n", "            .group(executor())\r\n            .channelFactory(socketChannelFactory)\r\n            .handler(TCP_ENCODER);\r\n            bs.connect(res.sender()).addListener(new ChannelFutureListener() {\r\n                @Override\r\n", "final class SingletonDnsServerAddresses extends DnsServerAddresses {\r\n\r\n    private final InetSocketAddress address;\r\n\r\n    private final DnsServerAddressStream stream = new DnsServerAddressStream() {\r\n", "        header.setOpcode(in.readByte());\r\n        header.setKeyLength(in.readShort());\r\n        header.setExtrasLength(in.readByte());\r\n        header.setDataType(in.readByte());\r\n        header.setReserved(in.readShort());\r\n", "        return newAddressRecord(name, RecordType.A, ipAddress);\r\n    }\r\n\r\n    protected static ResourceRecord newNsRecord(String dnsname, String domainName) {\r\n        ResourceRecordModifier rm = new ResourceRecordModifier();\r\n", "            group.shutdownGracefully(0, 0, TimeUnit.SECONDS);\r\n        }\r\n    }\r\n\r\n    private static DnsNameResolverBuilder newResolver(EventLoopGroup group) {\r\n", "    public FullBinaryMemcacheResponse duplicate() {\r\n        ByteBuf key = key();\r\n        if (key != null) {\r\n            key = key.duplicate();\r\n        }\r\n", "    private final Comparator<InetSocketAddress> nameServerComparator;\r\n    /**\r\n     * Manages the {@link DnsQueryContext}s in progress and their query IDs.\r\n     */\r\n    final DnsQueryContextManager queryContextManager = new DnsQueryContextManager();\r\n", "            }\r\n            return false;\r\n        } else {\r\n            tryFailure(promise, cause);\r\n            return true;\r\n", "        // This is used to simulate a query timeout...\r\n        final DatagramSocket socket = new DatagramSocket(new InetSocketAddress(0));\r\n\r\n        final TestDnsServer dnsServerAuthority = new TestDnsServer(new RecordStore() {\r\n            @Override\r\n", "        this.hostsFileEntriesResolver = hostsFileEntriesResolver;\r\n        return this;\r\n    }\r\n\r\n    protected DnsServerAddressStreamProvider nameServerProvider() {\r\n", "                }\r\n                return records;\r\n            }\r\n        });\r\n        dnsServer2.start();\r\n", "\r\n    @Test\r\n    public void searchDomainsWithOnlyDomain() throws IOException {\r\n        File f = buildFile(\"domain linecorp.local\\n\" +\r\n                           \"nameserver 127.0.0.2\\n\");\r\n", "\r\npublic class DefaultFullBinaryMemcacheResponseTest {\r\n\r\n    private DefaultFullBinaryMemcacheResponse response;\r\n\r\n", "        } catch (Exception e) {\r\n            return promise.setFailure(e);\r\n        }\r\n    }\r\n\r\n", "            return response;\r\n        }\r\n    };\r\n    private static final DatagramDnsQueryEncoder DATAGRAM_ENCODER = new DatagramDnsQueryEncoder();\r\n    private static final TcpDnsQueryEncoder TCP_ENCODER = new TcpDnsQueryEncoder();\r\n", "\r\n    @Override\r\n    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\r\n        try {\r\n            a.queryNoAnswer(code);\r\n", "     * @param failOnMissingResponse report if after close there are outstanding requests.\r\n     */\r\n    public BinaryMemcacheClientCodec(int decodeChunkSize, boolean failOnMissingResponse) {\r\n        this.failOnMissingResponse = failOnMissingResponse;\r\n        init(new Decoder(decodeChunkSize), new Encoder());\r\n", "        try {\r\n            new DatagramDnsQueryContext(this, nameServerAddr, question, additionals, castPromise)\r\n                    .query(flush, writePromise);\r\n            return castPromise;\r\n        } catch (Exception e) {\r\n", "        buf.release();\r\n    }\r\n\r\n    @Test\r\n    public void testSpdySettingsPersistedValues() throws Exception {\r\n", "        } while (additionalsIt.hasNext());\r\n\r\n        return records.toArray(new DnsRecord[records.size()]);\r\n    }\r\n\r\n", "        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);\r\n        encodeControlFrameHeader(buf, type, flags, length);\r\n        buf.writeInt(streamId | 0x80000000); // should ignore reserved bit\r\n\r\n        decoder.decode(buf);\r\n", "                    @Override\r\n                    public void channelRead(ChannelHandlerContext ctx, Object msg) {\r\n                        if (msg instanceof DatagramPacket) {\r\n                            // Truncate the packet by 1 byte.\r\n                            DatagramPacket packet = (DatagramPacket) msg;\r\n", "public interface FullBinaryMemcacheRequest extends BinaryMemcacheRequest, FullMemcacheMessage {\r\n\r\n    @Override\r\n    FullBinaryMemcacheRequest copy();\r\n\r\n", "                    .recursionDesired(false)\r\n                    .queryTimeoutMillis(500)\r\n                    .resolvedAddressTypes(ResolvedAddressTypes.IPV4_PREFERRED)\r\n                    .maxQueriesPerResolve(16)\r\n                    .nameServerProvider(new SingletonDnsServerAddressStreamProvider(dnsServer2.localAddress()));\r\n", "\r\n        @Override\r\n        public void channelActive(ChannelHandlerContext ctx) throws Exception {\r\n            super.channelActive(ctx);\r\n            channelActivePromise.setSuccess(ctx.channel());\r\n", "\r\n        @Override\r\n        public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\r\n            events.add(new QueryCnamedEvent(cnameQuestion));\r\n            return this;\r\n", "\r\n    @Override\r\n    public BinaryMemcacheMessage retain() {\r\n        super.retain();\r\n        return this;\r\n", "        switch (this.resolvedAddressTypes) {\r\n            case IPV4_ONLY:\r\n                supportsAAAARecords = false;\r\n                supportsARecords = true;\r\n                resolveRecordTypes = IPV4_ONLY_RESOLVED_RECORD_TYPES;\r\n", "                assertThat(actual, is(expected));\r\n            }\r\n        } finally {\r\n            resolver.close();\r\n        }\r\n", "                int txnId = in.read() << 8 | (in.read() & 0xff);\r\n\r\n                IoBuffer ioBuffer = IoBuffer.allocate(1024);\r\n                // Must replace the transactionId with the one from the TCP request\r\n                DnsMessageModifier modifier = modifierFrom(messageRef.get());\r\n", "        channel = new EmbeddedChannel(new BinaryMemcacheRequestDecoder(smallBatchSize));\r\n\r\n        ByteBuf incoming = Unpooled.buffer();\r\n        incoming.writeBytes(SET_REQUEST_WITH_CONTENT);\r\n        channel.writeInbound(incoming);\r\n", "                Future<AddressedEnvelope<DnsResponse, InetSocketAddress>> f = e.getValue().awaitUninterruptibly();\r\n\r\n                DnsResponse response = f.getNow().content();\r\n                assertThat(response.code(), is(DnsResponseCode.NOERROR));\r\n\r\n", "\r\n        f = buildFile(\"search localdomain\\n\" +\r\n            \"nameserver 127.0.0.11\\n\" +\r\n            \"options foo:bar attempts:12\\n\");\r\n        assertEquals(12, parseEtcResolverOptions(f).attempts());\r\n", "\r\n    /**\r\n     * Enable the automatic inclusion of a optional records that tries to give the remote DNS server a hint about\r\n     * how much data the resolver can read per response. Some DNSServer may not support this and so fail to answer\r\n     * queries. If you find problems you may want to disable this.\r\n", "    private static void resolve(DnsNameResolver resolver, Map<String, Future<InetAddress>> futures, String hostname) {\r\n        futures.put(hostname, resolver.resolve(hostname));\r\n    }\r\n\r\n    private static void queryMx(\r\n", "        assertEquals(1, stream.size());\r\n        assertHostNameEquals(\"127.0.0.3\", stream.next());\r\n    }\r\n\r\n    private File buildFile(String contents) throws IOException {\r\n", "                Unpooled.copiedBuffer(\"some value\", CharsetUtil.UTF_8));\r\n        request.setReserved((short) 534);\r\n        request.setMagic((byte) 0x03);\r\n        request.setOpcode((byte) 0x02);\r\n        request.setKeyLength((short) 32);\r\n", "            writeFuture.addListener(new ChannelFutureListener() {\r\n                @Override\r\n                public void operationComplete(ChannelFuture future) {\r\n                    onQueryWriteCompletion(writeFuture);\r\n                }\r\n", "                        message.getAdditionalRecords().add(newARecord(ns5Address));\r\n\r\n                        return message;\r\n                    }\r\n                }\r\n", "        decoder.decode(headerBlock);\r\n        verify(delegate).readHeadersFrame(streamId, false);\r\n        verify(delegate).readHeaderBlock(headerBlock.slice(0, headerBlock.writerIndex()));\r\n        verify(delegate).readHeaderBlockEnd();\r\n        assertFalse(buf.isReadable());\r\n", "\r\n    @Test\r\n    public void shouldEncodeDefaultHeader() {\r\n        BinaryMemcacheRequest request = new DefaultBinaryMemcacheRequest();\r\n\r\n", "\r\n                if (type == DnsRecordType.CNAME) {\r\n                    onResponseCNAME(question, buildAliasMap(envelope.content(), cnameCache(), parent.executor()),\r\n                                    queryLifecycleObserver, promise);\r\n                    return;\r\n", "    @Test\r\n    public void shouldEncodeCustomHeader() {\r\n        BinaryMemcacheRequest request = new DefaultBinaryMemcacheRequest();\r\n        request.setMagic((byte) 0xAA);\r\n        request.setOpcode(BinaryMemcacheOpcodes.GET);\r\n", "                        public boolean clear(String hostname) {\r\n                            return false;\r\n                        }\r\n                    });\r\n            resolver = builder.build();\r\n", "                \"youtube.com\",\r\n                \"wikipedia.org\",\r\n                \"google.co.in\",\r\n                \"blogspot.com\",\r\n                \"vk.com\",\r\n", "\r\n    /**\r\n     * Create a new {@link BinaryMemcacheClientCodec} with custom settings.\r\n     *\r\n     * @param decodeChunkSize       the maximum chunk size.\r\n", "        decoder.decode(buf);\r\n        verify(delegate).readPingFrame(id);\r\n        assertFalse(buf.isReadable());\r\n        buf.release();\r\n    }\r\n", "        } finally {\r\n            resolver.close();\r\n            testDnsServer.stop();\r\n        }\r\n    }\r\n", "        Constructor<? extends DnsServerAddressStreamProvider> constructor = null;\r\n        if (PlatformDependent.isOsx()) {\r\n            try {\r\n                // As MacOSDnsServerAddressStreamProvider is contained in another jar which depends on this jar\r\n                // we use reflection to use it if its on the classpath.\r\n", "        RecordStore arbitrarilyOrderedStore = new RecordStore() {\r\n            @Override\r\n            public Set<ResourceRecord> getRecords(QuestionRecord questionRecord) {\r\n                return recordsIterator.next();\r\n            }\r\n", "        decoder.decode(buf);\r\n        verify(delegate).readGoAwayFrame(lastGoodStreamId, statusCode);\r\n        assertFalse(buf.isReadable());\r\n        buf.release();\r\n    }\r\n", "        }\r\n\r\n        @Override\r\n        public DnsServerAddressStream get(String hostname) {\r\n            DnsServerAddressStream cached = cache.get(hostname);\r\n", "        }\r\n\r\n        return cnames != null? cnames : Collections.<String, String>emptyMap();\r\n    }\r\n\r\n", "                    // so use a fairly large TTL (1 day, i.e. 86400 seconds).\r\n                    trySuccess(promise, Collections.<DnsRecord>singletonList(\r\n                            new DefaultDnsRawRecord(hostname, type, 86400, content)));\r\n                    return promise;\r\n                }\r\n", "            promise.setSuccess(hostsFileEntry);\r\n            return;\r\n        }\r\n\r\n        if (!doResolveCached(hostname, additionals, promise, resolveCache)) {\r\n", "                nextStartIdx = 0;\r\n            }\r\n            if (startIdxUpdater.compareAndSet(this, curStartIdx, nextStartIdx)) {\r\n                return new SequentialDnsServerAddressStream(addresses, curStartIdx);\r\n            }\r\n", "        }\r\n    }\r\n\r\n    static <T> boolean trySuccess(Promise<T> promise, T result) {\r\n        final boolean notifiedRecords = promise.trySuccess(result);\r\n", "            cache.cache(\"netty.io\", new InetSocketAddress(NetUtil.LOCALHOST, 53), days, loop);\r\n        } finally {\r\n            group.shutdownGracefully();\r\n        }\r\n    }\r\n", "                            } else {\r\n                                // TCP fallback failed, just use the truncated response.\r\n                                qCtx.finish(res);\r\n                            }\r\n                        }\r\n", "            \"nameserver 127.0.0.11\\n\");\r\n        assertEquals(5, parseEtcResolverOptions(f).timeout());\r\n    }\r\n\r\n    @Test\r\n", "    }\r\n\r\n    @Test\r\n    public void testQueryMx() {\r\n        DnsNameResolver resolver = newResolver().build();\r\n", "    @Test\r\n    public void testInvalidSpdySettingsFrameLength() throws Exception {\r\n        short type = 4;\r\n        byte flags = 0;\r\n        int numSettings = 2;\r\n", "\r\n        if (msg instanceof MemcacheContent || msg instanceof ByteBuf || msg instanceof FileRegion) {\r\n            int contentLength = contentLength(msg);\r\n            if (contentLength > 0) {\r\n                out.add(encodeAndRetain(msg));\r\n", "            throws InterruptedException {\r\n\r\n        assertThat(resolver.isRecursionDesired(), is(true));\r\n\r\n        final Map<String, InetAddress> results = new HashMap<String, InetAddress>();\r\n", "    @Test\r\n    public void testCNameCached() throws Exception {\r\n        final Map<String, String> cache = new ConcurrentHashMap<String, String>();\r\n        final AtomicInteger cnameQueries = new AtomicInteger();\r\n        final AtomicInteger aQueries = new AtomicInteger();\r\n", "                .ttl(Integer.MAX_VALUE, Integer.MAX_VALUE)\r\n                .build();\r\n        try {\r\n            final Map<String, InetAddress> resultA = testResolve0(resolver, EXCLUSIONS_RESOLVE_A, null);\r\n\r\n", " * content, which defaults to 8192. This chunk size is the maximum, so if smaller chunks arrive they\r\n * will be passed up the pipeline and not queued up to the chunk size.\r\n */\r\n@UnstableApi\r\npublic final class BinaryMemcacheClientCodec extends\r\n", "                }\r\n\r\n                while (ioBuffer.hasRemaining()) {\r\n                    socket.getOutputStream().write(ioBuffer.get());\r\n                }\r\n", "            promise.setSuccess(Collections.singletonList(hostsFileEntry));\r\n            return;\r\n        }\r\n\r\n        if (!doResolveAllCached(hostname, additionals, promise, resolveCache, resolvedInternetProtocolFamilies)) {\r\n", "            Throwable cause = resolver.resolveAll(hostname).await().cause();\r\n            assertTrue(cause instanceof UnknownHostException);\r\n            DnsServerAddressStream redirected = redirectedRef.get();\r\n            assertNotNull(redirected);\r\n            assertEquals(6, redirected.size());\r\n", "            assertNotNull(resolver.resolve(knownHostName).syncUninterruptibly().getNow());\r\n\r\n            TestDnsQueryLifecycleObserver observer = lifecycleObserverFactory.observers.poll();\r\n            assertNotNull(observer);\r\n            assertEquals(1, lifecycleObserverFactory.observers.size());\r\n", "                public Throwable call() {\r\n                    try {\r\n                        assertNull(cache.get(\"netty.io\"));\r\n                        return null;\r\n                    } catch (Throwable cause) {\r\n", "                public Throwable call() {\r\n                    try {\r\n                        assertNull(cache.get(\"netty.io\"));\r\n                        return null;\r\n                    } catch (Throwable cause) {\r\n", "public interface FullBinaryMemcacheResponse extends BinaryMemcacheResponse, FullMemcacheMessage {\r\n\r\n    @Override\r\n    FullBinaryMemcacheResponse copy();\r\n\r\n", "    /**\r\n     * Create a new {@link AbstractBinaryMemcacheDecoder} with default settings.\r\n     */\r\n    protected AbstractBinaryMemcacheDecoder() {\r\n        this(DEFAULT_MAX_CHUNK_SIZE);\r\n", "            // If cause != null we know this was caused by a timeout / cancel / transport exception. In this case we\r\n            // won't try to resolve the CNAME as we only should do this if we could not get the expected records\r\n            // because they do not exist and the DNS server did probably signal it.\r\n            if (cause == null && !triedCNAME) {\r\n                // As the last resort, try to query CNAME, just in case the name server has it.\r\n", "        ObjectUtil.checkNotNull(address, \"address\");\r\n        if (address.isUnresolved()) {\r\n            throw new IllegalArgumentException(\"cannot use an unresolved DNS server address: \" + address);\r\n        }\r\n\r\n", "/**\r\n * The full server codec that combines the correct encoder and decoder.\r\n * <p/>\r\n * Use this codec if you need to implement a server that speaks the memcache binary protocol.\r\n * Internally, it combines the {@link BinaryMemcacheRequestDecoder} and the\r\n", "        try {\r\n            resolveNonExistentDomain(resolver);\r\n\r\n            final int size = 10000;\r\n            final List<UnknownHostException> exceptions = new ArrayList<UnknownHostException>();\r\n", "        if (bytes != null) {\r\n            // The unresolvedAddress was created via a String that contains an ipaddress.\r\n            promise.setSuccess(Collections.singletonList(InetAddress.getByAddress(bytes)));\r\n            return;\r\n        }\r\n", "                logger.info(\"{} has the following MX records:{}\", hostname, buf);\r\n                response.release();\r\n\r\n                // We only track query lifecycle if it is managed by the DnsNameResolverContext, and not direct calls\r\n                // to query.\r\n", "    private BinaryMemcacheResponseStatus() {\r\n        // disallow construction\r\n    }\r\n\r\n    public static final short SUCCESS = 0x00;\r\n", "    @Test\r\n    public void testMultipleSearchDomain() throws Exception {\r\n        Set<String> domains = new HashSet<String>();\r\n        domains.add(\"host1.foo.com\");\r\n        domains.add(\"host2.bar.com\");\r\n", "import io.netty.util.concurrent.Promise;\r\n\r\nfinal class DnsRecordResolveContext extends DnsResolveContext<DnsRecord> {\r\n\r\n    DnsRecordResolveContext(DnsNameResolver parent, Promise<?> originalPromise, DnsQuestion question,\r\n", "    @Override\r\n    public BinaryMemcacheMessage setDataType(byte dataType) {\r\n        this.dataType = dataType;\r\n        return this;\r\n    }\r\n", "            return null;\r\n        }\r\n        return new SequentialDnsServerAddressStream(addresses, 0);\r\n    }\r\n\r\n", "            stream = getNameServers(cname);\r\n            cnameQuestion = new DefaultDnsQuestion(cname, question.type(), dnsClass);\r\n        } catch (Throwable cause) {\r\n            queryLifecycleObserver.queryFailed(cause);\r\n            PlatformDependent.throwException(cause);\r\n", "\r\nabstract class DnsQueryContext implements FutureListener<AddressedEnvelope<DnsResponse, InetSocketAddress>> {\r\n\r\n    private static final InternalLogger logger = InternalLoggerFactory.getInstance(DnsQueryContext.class);\r\n\r\n", "        TestDnsServer dnsServer2 = new TestDnsServer(new RecordStore() {\r\n            @Override\r\n            public Set<ResourceRecord> getRecords(QuestionRecord question) {\r\n                String name = question.getDomainName();\r\n                if (name.equals(\"service.netty.io\")) {\r\n", "                return message;\r\n            }\r\n        };\r\n        testDnsServer.start();\r\n        DnsNameResolverBuilder builder = newResolver();\r\n", "        final Map<String, Future<InetAddress>> futures =\r\n                new LinkedHashMap<String, Future<InetAddress>>();\r\n\r\n        for (String name : DOMAINS) {\r\n            if (excludedDomains.contains(name)) {\r\n", "            assertTrue(resolvedAddresses.contains(InetAddress.getByAddress(new byte[] { 10, 0, 0, 2 })));\r\n        } finally {\r\n            dnsServer2.stop();\r\n            if (resolver != null) {\r\n                resolver.close();\r\n", "            assertNotNull(cache.cache(\"netty.io\", null, NetUtil.LOCALHOST, 100, loop));\r\n        } finally {\r\n            group.shutdownGracefully();\r\n        }\r\n    }\r\n", "            assertSame(cached, cached2);\r\n        } finally {\r\n            resolver.close();\r\n        }\r\n    }\r\n", "        if (!notifiedRecords) {\r\n            // There is nothing really wrong with not be able to notify the promise as we may have raced here because\r\n            // of multiple queries that have been executed. Log it with trace level anyway just in case the user\r\n            // wants to better understand what happened.\r\n            logger.trace(\"Failed to notify success ({}) to a promise: {}\", result, promise);\r\n", "            }\r\n\r\n            assertThat(typeMatches, is(true));\r\n\r\n            results.put(resolved.getHostName(), resolved);\r\n", "                // If we tried to resolve localhost we need workaround that windows removed localhost from its\r\n                // hostfile in later versions.\r\n                // See https://github.com/netty/netty/issues/5386\r\n                return LOCALHOST_ADDRESS;\r\n            }\r\n", "            return singleton(addresses.get(0));\r\n        }\r\n\r\n        return new RotationalDnsServerAddresses(addresses);\r\n    }\r\n", "        this.channel = channel;\r\n    }\r\n\r\n    @Override\r\n    protected DnsQuery newQuery(int id) {\r\n", "        return decodeIdn;\r\n    }\r\n\r\n    /**\r\n     * Returns {@code true} if and only if this resolver sends a DNS query with the RD (recursion desired) flag set.\r\n", "        } catch (Exception e) {\r\n            assertThat(e, is(instanceOf(CancellationException.class)));\r\n        }\r\n        assertThat(isQuerySentToSecondServer.get(), is(false));\r\n    }\r\n", "    @Override\r\n    public FullBinaryMemcacheRequest retain() {\r\n        super.retain();\r\n        return this;\r\n    }\r\n", "    }\r\n\r\n    @Override\r\n    public LastMemcacheContent retain(int increment) {\r\n        super.retain(increment);\r\n", "        try {\r\n            assertThat(resolver.isRecursionDesired(), is(true));\r\n\r\n            Map<String, Future<AddressedEnvelope<DnsResponse, InetSocketAddress>>> futures =\r\n                    new LinkedHashMap<String, Future<AddressedEnvelope<DnsResponse, InetSocketAddress>>>();\r\n", "                public void encode(IoSession session, Object message, ProtocolEncoderOutput out) {\r\n                    IoBuffer buf = IoBuffer.allocate(1024);\r\n                    DnsMessage dnsMessage = filterMessage((DnsMessage) message);\r\n                    encoder.encode(buf, dnsMessage);\r\n                    for (ResourceRecord record : dnsMessage.getAnswerRecords()) {\r\n", "     * @return the encoded object.\r\n     */\r\n    private static Object encodeAndRetain(Object msg) {\r\n        if (msg instanceof ByteBuf) {\r\n            return ((ByteBuf) msg).retain();\r\n", "            DnsNameResolverBuilder builder = newResolver()\r\n                    .recursionDesired(true)\r\n                    .resolvedAddressTypes(ResolvedAddressTypes.IPV4_ONLY)\r\n                    .maxQueriesPerResolve(16)\r\n                    .nameServerProvider(new SingletonDnsServerAddressStreamProvider(dnsServer2.localAddress()))\r\n", "        final String host = \"somehost.netty.io\";\r\n        TestDnsServer dnsServer2 = new TestDnsServer(new RecordStore() {\r\n            @Override\r\n            public Set<ResourceRecord> getRecords(QuestionRecord question) throws DnsException {\r\n                String name = question.getDomainName();\r\n", "        if (channelType == null) {\r\n            return socketChannelFactory(null);\r\n        }\r\n        return socketChannelFactory(new ReflectiveChannelFactory<SocketChannel>(channelType));\r\n    }\r\n", "            list.add(f);\r\n        }\r\n\r\n        this.searchDomains = list.toArray(new String[0]);\r\n        return this;\r\n", "                }\r\n                return super.newRedirectServerAddress(server);\r\n            }\r\n        };\r\n\r\n", "                builder.resolvedAddressTypes(ResolvedAddressTypes.IPV6_PREFERRED);\r\n            }\r\n            resolver = builder.build();\r\n            InetAddress resolvedAddress = resolver.resolve(firstName).syncUninterruptibly().getNow();\r\n            if (ipv4Preferred) {\r\n", "            ByteBuf buffer = channel.readOutbound();\r\n            if (buffer == null) {\r\n                break;\r\n            }\r\n            channel.writeInbound(buffer);\r\n", " * This interface can be used to track metrics for individual DNS servers. Methods which may lead to another DNS query\r\n * return an object of type {@link DnsQueryLifecycleObserver}. Implementations may use this to build a query tree to\r\n * understand the \"sub queries\" generated by a single query.\r\n */\r\npublic interface DnsQueryLifecycleObserver {\r\n", "                    .queryTimeoutMillis(10000)\r\n                    .resolvedAddressTypes(ResolvedAddressTypes.IPV4_PREFERRED)\r\n                    .maxQueriesPerResolve(16)\r\n                    .nameServerProvider(new SingletonDnsServerAddressStreamProvider(dnsServer2.localAddress()));\r\n\r\n", "            }\r\n        } finally {\r\n            resolver.close();\r\n        }\r\n    }\r\n", "        assertThat(result, is(true));\r\n        result = channel.writeOutbound(content2);\r\n        assertThat(result, is(true));\r\n\r\n        ByteBuf written = channel.readOutbound();\r\n", "        channel = new EmbeddedChannel(\r\n                new BinaryMemcacheRequestEncoder(),\r\n                new BinaryMemcacheRequestDecoder());\r\n\r\n        ByteBuf key = Unpooled.copiedBuffer(\"Netty\", CharsetUtil.UTF_8);\r\n", "\r\n        // Remove the id from the manager as soon as the query completes. This may be because of success, failure or\r\n        // cancellation\r\n        parent.queryContextManager.remove(nameServerAddr, id);\r\n    }\r\n", "            return address;\r\n        }\r\n\r\n        private InetSocketAddress nextResolved0() {\r\n            return parent.newRedirectServerAddress(resolved.next());\r\n", "                observer = lifecycleObserverFactory.observers.poll();\r\n                assertNotNull(observer);\r\n                assertTrue(lifecycleObserverFactory.observers.isEmpty());\r\n                assertEquals(2, observer.events.size());\r\n                writtenEvent1 = (QueryWrittenEvent) observer.events.poll();\r\n", "                    key.readableBytes(), 0, content.readableBytes());\r\n            testSettingLengths(new DefaultFullBinaryMemcacheResponse(null, null, content.retain()),\r\n                    0, 0, content.readableBytes());\r\n        } finally {\r\n            key.release();\r\n", "        assertEquals(store.getAddress(\"host1.foo.com\"), resolved);\r\n\r\n        // \"host2\" shouldn't resolve because it is not in the known domain names, and \"host2\" has 0 dots which is not\r\n        // less ndots (which is also 0).\r\n        assertNotResolve(resolver, \"host2\");\r\n", "\r\n            // We are resolving the local address, so we shouldn't make any queries.\r\n            assertNoQueriesMade(resolver);\r\n        } finally {\r\n            resolver.close();\r\n", "    protected EventLoop executor() {\r\n        return (EventLoop) super.executor();\r\n    }\r\n\r\n    private InetAddress resolveHostsFileEntry(String hostname) {\r\n", "            }\r\n            Future<AddressedEnvelope<DnsResponse, InetSocketAddress>> envelopeFuture = resolver.query(\r\n                    new DefaultDnsQuestion(host, DnsRecordType.TXT));\r\n\r\n            if (tcpFallback) {\r\n", "        public LastMemcacheContent retain(int increment) {\r\n            return this;\r\n        }\r\n\r\n        @Override\r\n", "\r\n    @Override\r\n    public LastMemcacheContent retain() {\r\n        super.retain();\r\n        return this;\r\n", "\r\n                    return Collections.singleton(rm.getEntry());\r\n                } else {\r\n                    throw new DnsException(ResponseCode.REFUSED);\r\n                }\r\n", "        private final Queue<ByteBuf> buffers = new ArrayDeque<ByteBuf>();\r\n\r\n        @Override\r\n        public void readDataFrame(int streamId, boolean last, ByteBuf data) {\r\n            delegate.readDataFrame(streamId, last, data);\r\n", "    BinaryMemcacheRequest retain();\r\n\r\n    @Override\r\n    BinaryMemcacheRequest retain(int increment);\r\n\r\n", "        return builder.eventLoop(eventLoop)\r\n                .channelFactory(channelFactory)\r\n                .nameServerProvider(nameServerProvider)\r\n                .build();\r\n    }\r\n", "                    return Collections.singleton(rm.getEntry());\r\n                } else {\r\n                    throw new DnsException(ResponseCode.REFUSED);\r\n                }\r\n            }\r\n", "            buf.writeMedium(id);\r\n            buf.writeInt(value);\r\n        }\r\n\r\n        decoder.decode(buf);\r\n", "            buf.writeMedium(id);\r\n            buf.writeInt(value);\r\n        }\r\n\r\n        decoder.decode(buf);\r\n", "            dnsServer2.start();\r\n\r\n            TestRecursiveCacheDnsQueryLifecycleObserverFactory lifecycleObserverFactory =\r\n                    new TestRecursiveCacheDnsQueryLifecycleObserverFactory();\r\n\r\n", "\r\n            assertEquals(\"10.0.0.1\", address.getHostAddress());\r\n\r\n            // This address is already resolved, and so we shouldn't have to query for anything.\r\n            assertNoQueriesMade(resolver);\r\n", "        buf.release();\r\n        headerBlock.release();\r\n    }\r\n\r\n    @Test\r\n", "                builder.socketChannelType(NioSocketChannel.class);\r\n            }\r\n            resolver = builder.build();\r\n            if (truncatedBecauseOfMtu) {\r\n                resolver.ch.pipeline().addFirst(new ChannelInboundHandlerAdapter() {\r\n", "        BinaryMemcacheRequest request = new DefaultBinaryMemcacheRequest(key, extras);\r\n\r\n        DefaultMemcacheContent content1 =\r\n                new DefaultMemcacheContent(Unpooled.copiedBuffer(\"Netty\", CharsetUtil.UTF_8));\r\n        DefaultLastMemcacheContent content2 =\r\n", "                    Class<? extends DnsServerAddressStreamProvider> providerClass =\r\n                            (Class<? extends DnsServerAddressStreamProvider>) maybeProvider;\r\n                    constructor = providerClass.getConstructor();\r\n                    constructor.newInstance();  // ctor ensures availability\r\n                    LOGGER.debug(\"{}: available\", MACOS_PROVIDER_CLASS_NAME);\r\n", "/**\r\n * The default implementation of the {@link BinaryMemcacheResponse}.\r\n */\r\n@UnstableApi\r\npublic class DefaultBinaryMemcacheResponse extends AbstractBinaryMemcacheMessage implements BinaryMemcacheResponse {\r\n", "        if (hostsFileEntriesResolver == null) {\r\n            return null;\r\n        } else {\r\n            InetAddress address = hostsFileEntriesResolver.address(hostname, resolvedAddressTypes);\r\n            if (address == null && PlatformDependent.isWindows() && LOCALHOST.equalsIgnoreCase(hostname)) {\r\n", "            assertNoQueriesMade(resolver);\r\n        } finally {\r\n            resolver.close();\r\n        }\r\n    }\r\n", "     * @param queryTimeoutMillis the query timeout\r\n     * @return {@code this}\r\n     */\r\n    public DnsNameResolverBuilder queryTimeoutMillis(long queryTimeoutMillis) {\r\n        this.queryTimeoutMillis = queryTimeoutMillis;\r\n", "\r\n    @Override\r\n    public FullBinaryMemcacheRequest retain(int increment) {\r\n        super.retain(increment);\r\n        return this;\r\n", "        @Override\r\n        public void queryCancelled(int queriesRemaining) {\r\n            events.add(new QueryCancelledEvent(queriesRemaining));\r\n        }\r\n\r\n", "    @Override\r\n    public FullBinaryMemcacheResponse retain() {\r\n        super.retain();\r\n        return this;\r\n    }\r\n", "            buf.writeByte(idFlags);\r\n            buf.writeMedium(id);\r\n            buf.writeInt(value);\r\n        }\r\n\r\n", "                    // It is possible that\r\n                    // 1. task will fire in between this line, or\r\n                    // 2. multiple timers may be set if there is concurrency\r\n                    // (1) Shouldn't be a problem because we will fail the CAS and then the next loop will see CANCELLED\r\n                    //     so the ttl will not be less, and we will bail out of the loop.\r\n", "                return entry.address().equals(otherEntry.address());\r\n            }\r\n            if (otherEntry.address() != null) {\r\n                return false;\r\n            }\r\n", "\r\nimport java.net.InetAddress;\r\nimport java.util.Collections;\r\nimport java.util.List;\r\nimport java.util.concurrent.ConcurrentMap;\r\n", "    }\r\n\r\n    /**\r\n     * This test will start an second DNS test server which returns fixed results that can be easily verified as\r\n     * originating from the second DNS test server. The resolver will put {@link DnsServerAddressStreamProvider} under\r\n", "\r\n    @Override\r\n    protected BinaryMemcacheResponse buildInvalidMessage() {\r\n        return new DefaultBinaryMemcacheResponse(Unpooled.EMPTY_BUFFER, Unpooled.EMPTY_BUFFER);\r\n    }\r\n", "        File f = buildFile(\"domain linecorp.local\\n\" +\r\n                           \"nameserver 127.0.0.2\\n\" +\r\n                           \"nameserver 127.0.0.3\\n\");\r\n        UnixResolverDnsServerAddressStreamProvider p =\r\n                new UnixResolverDnsServerAddressStreamProvider(f, null);\r\n", "            }\r\n        });\r\n        dnsServer2.start();\r\n        dnsServer3.start();\r\n        DnsNameResolver resolver = null;\r\n", "                        return cause;\r\n                    }\r\n                }\r\n            }, 1, TimeUnit.SECONDS).get();\r\n            if (error != null) {\r\n", "                        return cause;\r\n                    }\r\n                }\r\n            }, 1, TimeUnit.SECONDS).get();\r\n            if (error != null) {\r\n", "        if (executor.inEventLoop()) {\r\n            doResolveAllUncached0(hostname, additionals, originalPromise,\r\n                                  promise, resolveCache, completeEarlyIfPossible);\r\n        } else {\r\n            executor.execute(new Runnable() {\r\n", "        ByteBuf headerBlock = Unpooled.buffer(4);\r\n        headerBlock.writeInt(0);\r\n        decoder.decode(ByteBufAllocator.DEFAULT, headerBlock, frame);\r\n        decoder.endHeaderBlock(frame);\r\n\r\n", "        if (!promise.tryFailure(cause)) {\r\n            // There is nothing really wrong with not be able to notify the promise as we may have raced here because\r\n            // of multiple queries that have been executed. Log it with trace level anyway just in case the user\r\n            // wants to better understand what happened.\r\n            logger.trace(\"Failed to notify failure to a promise: {}\", promise, cause);\r\n", "                            DnsAttribute.IP_ADDRESS.toLowerCase(), ipv4Addr)));\r\n                } else {\r\n                    records.add(new TestDnsServer.TestResourceRecord(qName,\r\n                            RecordType.A, Collections.<String, Object>singletonMap(\r\n                            DnsAttribute.IP_ADDRESS.toLowerCase(), ipv4Addr)));\r\n", "\r\n            resolver.cnameCache().cache(name, name2, Long.MAX_VALUE, resolver.executor());\r\n            resolver.cnameCache().cache(name2, name, Long.MAX_VALUE, resolver.executor());\r\n            resolver.resolve(name).syncUninterruptibly().getNow();\r\n        } finally {\r\n", "    public LoggingDnsQueryLifeCycleObserverFactory(Class<?> classContext, LogLevel level) {\r\n        this.level = checkAndConvertLevel(level);\r\n        logger = InternalLoggerFactory.getInstance(checkNotNull(classContext, \"classContext\"));\r\n    }\r\n\r\n", "            \"nameserver 127.0.0.2\\n\" +\r\n            \"nameserver 127.0.0.3\\n\" +\r\n            \"nameserver 127.0.0.4\\n\");\r\n        UnixResolverDnsServerAddressStreamProvider p =\r\n            new UnixResolverDnsServerAddressStreamProvider(f, null);\r\n", "            \"nameserver 127.0.0.2\\n\" +\r\n            \"nameserver 127.0.0.3\\n\" +\r\n            \"nameserver 127.0.0.4\\n\");\r\n        UnixResolverDnsServerAddressStreamProvider p =\r\n            new UnixResolverDnsServerAddressStreamProvider(f, null);\r\n", "        try {\r\n            resolver.resolve(\"test\").syncUninterruptibly();\r\n\r\n            assertNull(cache.cacheHits.get(\"test.netty.io\"));\r\n\r\n", "        buf.writeInt(lastGoodStreamId);\r\n        buf.writeInt(statusCode);\r\n\r\n        decoder.decode(buf);\r\n        verify(delegate).readFrameError(anyString());\r\n", "        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets if this resolver has to send a DNS query with the RD (recursion desired) flag set.\r\n", "                @Override\r\n                protected DnsServerAddressStream initialValue() {\r\n                    return dnsServerAddressStreamProvider.nameServerAddressStream(\"\");\r\n                }\r\n            };\r\n", "        ByteBuf headerBlock = Unpooled.buffer(4);\r\n        headerBlock.writeInt(1);\r\n        decoder.decode(ByteBufAllocator.DEFAULT, headerBlock, frame);\r\n        decoder.endHeaderBlock(frame);\r\n\r\n", " * A {@link DnsServerAddressStreamProvider} which always uses a single DNS server for resolution.\r\n */\r\npublic final class SingletonDnsServerAddressStreamProvider extends UniSequentialDnsServerAddressStreamProvider {\r\n    /**\r\n     * Create a new instance.\r\n", "        protected void encode(ChannelHandlerContext ctx, Object msg, List<Object> out) throws Exception {\r\n            super.encode(ctx, msg, out);\r\n\r\n            if (failOnMissingResponse && msg instanceof LastMemcacheContent) {\r\n                requestResponseCounter.incrementAndGet();\r\n", "\r\n        assertEquals(0, comparator.compare(UNRESOLVED1, UNRESOLVED1));\r\n        assertEquals(0, comparator.compare(UNRESOLVED2, UNRESOLVED2));\r\n    }\r\n\r\n", "    @Override\r\n    void cache(String hostname, DnsRecord[] additionals, DnsRecord result, DnsRecord convertedResult) {\r\n        // Do not cache.\r\n        // XXX: When we implement cache, we would need to retain the reference count of the result record.\r\n    }\r\n", "            TestDnsQueryLifecycleObserver observer = new TestDnsQueryLifecycleObserver(question);\r\n            observers.add(observer);\r\n            return observer;\r\n        }\r\n    }\r\n", "                server2Counter.incrementAndGet();\r\n                ResourceRecordModifier rm = new ResourceRecordModifier();\r\n                rm.setDnsClass(RecordClass.IN);\r\n                rm.setDnsName(question.getDomainName());\r\n                rm.setDnsTtl(100);\r\n", "                            doSearchDomainQuery(hostname + '.' + searchDomains[searchDomainIdx++], newPromise);\r\n                        } else if (!startWithoutSearchDomain) {\r\n                            internalResolve(hostname, promise);\r\n                        } else {\r\n                            promise.tryFailure(new SearchDomainUnknownHostException(cause, hostname));\r\n", "\r\n                            if (compareAndSet(entries, singletonList(e))) {\r\n                                scheduleCacheExpirationIfNeeded(ttl, loop);\r\n                                return;\r\n                            } else {\r\n", "                            \"nameserver 127.0.0.5\\n\");\r\n        UnixResolverDnsServerAddressStreamProvider p =\r\n                new UnixResolverDnsServerAddressStreamProvider(f, f2);\r\n\r\n        DnsServerAddressStream stream = p.nameServerAddressStream(\"myhost.dc1.linecorp.local\");\r\n", "    public void testEncodeDecode() throws Exception {\r\n        ByteBuf key = Unpooled.wrappedBuffer(\"key\".getBytes(CharsetUtil.UTF_8));\r\n        ByteBuf content = Unpooled.wrappedBuffer(\"content\".getBytes(CharsetUtil.UTF_8));\r\n        ByteBuf extras = Unpooled.wrappedBuffer(\"extras\".getBytes(CharsetUtil.UTF_8));\r\n        FullBinaryMemcacheRequest req = new DefaultFullBinaryMemcacheRequest(key, extras, content);\r\n", "            if (a == null) {\r\n                break;\r\n            }\r\n            if (a.isUnresolved()) {\r\n                throw new IllegalArgumentException(\"cannot use an unresolved DNS server address: \" + a);\r\n", "\r\n    @Test\r\n    public void testSearchDomainWithNdots0() throws Exception {\r\n        Set<String> domains = new HashSet<String>();\r\n        domains.add(\"host1\");\r\n", "\r\n        final DnsNameResolverException e;\r\n        if (timeout) {\r\n            // This was caused by an timeout so use DnsNameResolverTimeoutException to allow the user to\r\n            // handle it special (like retry the query).\r\n", "    DnsResolveContext<DnsRecord> newResolverContext(DnsNameResolver parent, Promise<?> originalPromise,\r\n                                                    String hostname,\r\n                                                    int dnsClass, DnsRecordType[] expectedTypes,\r\n                                                    DnsRecord[] additionals,\r\n                                                    DnsServerAddressStream nameServerAddrs,\r\n", "        buf.writeInt(streamId);\r\n\r\n        decoder.decode(buf);\r\n        verify(delegate).readFrameError(anyString());\r\n        assertFalse(buf.isReadable());\r\n", "            if (cached != null) {\r\n                cacheHits.put(hostname, cached.duplicate());\r\n            }\r\n            return cached;\r\n        }\r\n", "            TestDnsQueryLifecycleObserver observer = lifecycleObserverFactory.observers.poll();\r\n            assertNotNull(observer);\r\n            assertTrue(lifecycleObserverFactory.observers.isEmpty());\r\n            assertEquals(4, observer.events.size());\r\n            QueryWrittenEvent writtenEvent1 = (QueryWrittenEvent) observer.events.poll();\r\n", "        return queryTimeoutMillis;\r\n    }\r\n\r\n    /**\r\n     * Returns the {@link ResolvedAddressTypes} resolved by {@link #resolve(String)}.\r\n", "        public AddressedEnvelope<DnsResponse, InetSocketAddress> retain(int increment) {\r\n            response.retain(increment);\r\n            return this;\r\n        }\r\n\r\n", "        public int refCnt() {\r\n            return 1;\r\n        }\r\n\r\n        @Override\r\n", "\r\n        BinaryMemcacheRequest request = channel.readInbound();\r\n\r\n        assertThat(request, notNullValue());\r\n        assertThat(request.key(), notNullValue());\r\n", "        String host = \"somehost.netty.io\";\r\n        TestDnsServer dnsServer2 = new TestDnsServer(Collections.singleton(host));\r\n        dnsServer2.start(true);\r\n        DnsNameResolver resolver = null;\r\n        try {\r\n", "/**\r\n * The default implementation of the {@link BinaryMemcacheRequest}.\r\n */\r\n@UnstableApi\r\npublic class DefaultBinaryMemcacheRequest extends AbstractBinaryMemcacheMessage implements BinaryMemcacheRequest {\r\n", "\r\n        resolver = newResolver().searchDomains(Collections.singleton(\"foo.com\")).ndots(2).build();\r\n\r\n        String resolved = assertResolve(resolver, \"host1.sub\");\r\n        assertEquals(store.getAddress(\"host1.sub.foo.com\"), resolved);\r\n", "    private DnsServerAddressStream getNameServers(String name) {\r\n        DnsServerAddressStream stream = getNameServersFromCache(name);\r\n        if (stream == null) {\r\n            // We need to obtain a new stream from the parent DnsNameResolver if the hostname is not the same as\r\n            // for the original query (for example we may follow CNAMEs). Otherwise let's just duplicate the\r\n", "                assertNoQueriesMade(resolver);\r\n            }\r\n        } finally {\r\n            resolver.close();\r\n        }\r\n", " * The difference in the protocols (header) is implemented by the subclasses.\r\n */\r\n@UnstableApi\r\npublic abstract class AbstractBinaryMemcacheDecoder<M extends BinaryMemcacheMessage>\r\n    extends AbstractMemcacheObjectDecoder {\r\n", "        dnsServer.start();\r\n\r\n        resolver = newResolver().searchDomains(Collections.singletonList(\"foo.com\")).ndots(1).build();\r\n\r\n        Future<InetAddress> fut = resolver.resolve(\"unknown.hostname\");\r\n", "        BinaryMemcacheRequest request = channel.readInbound();\r\n\r\n        assertThat(request, notNullValue());\r\n        assertThat(request.key(), notNullValue());\r\n        assertThat(request.extras(), nullValue());\r\n", "    @Test\r\n    public void testResolveIp() {\r\n        DnsNameResolver resolver = newResolver().build();\r\n        try {\r\n            InetAddress address = resolver.resolve(\"10.0.0.1\").syncUninterruptibly().getNow();\r\n", "\r\n    @Override\r\n    protected BinaryMemcacheRequest buildInvalidMessage() {\r\n        return new DefaultBinaryMemcacheRequest(Unpooled.EMPTY_BUFFER, Unpooled.EMPTY_BUFFER);\r\n    }\r\n", "                        RecordType.A, Collections.<String, Object>singletonMap(\r\n                        DnsAttribute.IP_ADDRESS.toLowerCase(), ipv4Addr)));\r\n                records.add(new TestDnsServer.TestResourceRecord(qName,\r\n                        RecordType.A, Collections.<String, Object>singletonMap(\r\n                        DnsAttribute.IP_ADDRESS.toLowerCase(), ipv4Addr)));\r\n", "                        promise.setSuccess(null);\r\n                    } catch (Throwable cause) {\r\n                        promise.setFailure(cause);\r\n                    }\r\n                }\r\n", "                    } else {\r\n                        chunk = new DefaultMemcacheContent(chunkBuffer);\r\n                    }\r\n\r\n                    out.add(chunk);\r\n", "    @Test(timeout = 2000L)\r\n    public void testCachesClearedOnClose() throws Exception {\r\n        final CountDownLatch resolveLatch = new CountDownLatch(1);\r\n        final CountDownLatch authoritativeLatch = new CountDownLatch(1);\r\n\r\n", "\r\n        decoder.decode(buf);\r\n        verify(delegate).readHeadersFrame(streamId, false);\r\n        verify(delegate).readHeaderBlockEnd();\r\n        assertFalse(buf.isReadable());\r\n", "        acceptor.setHandler(new DnsProtocolHandler(this, store) {\r\n            @Override\r\n            public void sessionCreated(IoSession session) {\r\n                // USe our own codec to support AAAA testing\r\n                session.getFilterChain()\r\n", "    private Future<List<DnsRecord>> resolveAll(DnsQuestion question, DnsRecord[] additionals,\r\n                                               Promise<List<DnsRecord>> promise) {\r\n        checkNotNull(question, \"question\");\r\n        checkNotNull(promise, \"promise\");\r\n\r\n", "    }\r\n\r\n    @Override\r\n    public MemcacheContent copy() {\r\n        return replace(content.copy());\r\n", "            copiedBuilder.socketChannelFactory(socketChannelFactory);\r\n        }\r\n\r\n        if (resolveCache != null) {\r\n            copiedBuilder.resolveCache(resolveCache);\r\n", "        } finally {\r\n            resolver.close();\r\n        }\r\n    }\r\n\r\n", "        } finally {\r\n            resolver.close();\r\n        }\r\n    }\r\n\r\n", "        decoder.decode(buf);\r\n        verify(delegate).readHeadersFrame(streamId, false);\r\n        verify(delegate).readHeaderBlockEnd();\r\n        assertFalse(buf.isReadable());\r\n        buf.release();\r\n", "\r\n    @Test\r\n    public void testSpdySynReplyFrameHeaderBlock() throws Exception {\r\n        short type = 2;\r\n        byte flags = 0;\r\n", "    @Override\r\n    BinaryMemcacheResponse touch();\r\n\r\n    @Override\r\n    BinaryMemcacheResponse touch(Object hint);\r\n", "                        URI uri = new URI(server);\r\n                        String host = new URI(server).getHost();\r\n\r\n                        if (host == null || host.isEmpty()) {\r\n                            logger.debug(\r\n", "    @Override\r\n    List<DnsRecord> filterResults(List<DnsRecord> unfiltered) {\r\n        return unfiltered;\r\n    }\r\n\r\n", "            request.release();\r\n            newInstance.release();\r\n        }\r\n    }\r\n\r\n", "        ((DatagramSessionConfig) acceptor.getSessionConfig()).setReuseAddress(true);\r\n\r\n        // Start the listener\r\n        acceptor.bind();\r\n    }\r\n", "                    .channelType(NioDatagramChannel.class)\r\n                    .queryTimeoutMillis(1000) // We expect timeouts if startDnsServer1 is false\r\n                    .optResourceEnabled(false)\r\n                    .ndots(1);\r\n\r\n", "                Unpooled.copiedBuffer(\"some value\", CharsetUtil.UTF_8));\r\n        response.setStatus((short) 1);\r\n        response.setMagic((byte) 0x03);\r\n        response.setOpcode((byte) 0x02);\r\n        response.setKeyLength((short) 32);\r\n", "                .nameServerProvider(new SingletonDnsServerAddressStreamProvider(server.localAddress()))\r\n                .build();\r\n        try {\r\n            AddressedEnvelope<DnsResponse, InetSocketAddress> envelope = resolver.query(\r\n                    new DefaultDnsQuestion(hostname, DnsRecordType.TXT)).syncUninterruptibly().getNow();\r\n", "            public Set<ResourceRecord> getRecords(QuestionRecord question) {\r\n                if (question.getDomainName().equals(expected.getHostName())) {\r\n                    return Collections.singleton(TestDnsServer.newARecord(\r\n                            expected.getHostName(), expected.getHostAddress()));\r\n                }\r\n", "        }\r\n    }\r\n\r\n    DnsQueryContext get(InetSocketAddress nameServerAddr, int id) {\r\n        final IntObjectMap<DnsQueryContext> contexts = getContextMap(nameServerAddr);\r\n", "                        public DnsServerAddressStream nameServerAddressStream(String hostname) {\r\n                            return addresses.stream();\r\n                        }\r\n                    })\r\n                    .resolvedAddressTypes(ResolvedAddressTypes.IPV4_ONLY).build();\r\n", "            TestDnsQueryLifecycleObserver observer = lifecycleObserverFactory.observers.poll();\r\n            assertNotNull(observer);\r\n            assertEquals(1, lifecycleObserverFactory.observers.size());\r\n            assertEquals(2, observer.events.size());\r\n            QueryWrittenEvent writtenEvent = (QueryWrittenEvent) observer.events.poll();\r\n", "    private static Promise<AddressedEnvelope<DnsResponse, InetSocketAddress>> cast(Promise<?> promise) {\r\n        return (Promise<AddressedEnvelope<DnsResponse, InetSocketAddress>>) promise;\r\n    }\r\n\r\n    final DnsServerAddressStream newNameServerAddressStream(String hostname) {\r\n", "                    case A:\r\n                        Map<String, Object> attr = new HashMap<String, Object>();\r\n                        attr.put(DnsAttribute.IP_ADDRESS.toLowerCase(Locale.US), overriddenIP);\r\n                        return Collections.<ResourceRecord>singleton(\r\n                                new TestDnsServer.TestResourceRecord(\r\n", "            }, 1, TimeUnit.SECONDS).get();\r\n            if (error != null) {\r\n                throw error;\r\n            }\r\n        } finally {\r\n", "                                                    int allowedQueries) {\r\n        return new DnsRecordResolveContext(parent, originalPromise, hostname, dnsClass,\r\n                                           expectedTypes, additionals, nameServerAddrs, allowedQueries);\r\n    }\r\n\r\n", "    extends AbstractBinaryMemcacheEncoder<BinaryMemcacheRequest> {\r\n\r\n    @Override\r\n    protected void encodeHeader(ByteBuf buf, BinaryMemcacheRequest msg) {\r\n        buf.writeByte(msg.magic());\r\n", "        public void readGoAwayFrame(int lastGoodStreamId, int statusCode) {\r\n            delegate.readGoAwayFrame(lastGoodStreamId, statusCode);\r\n        }\r\n\r\n        @Override\r\n", "            public Set<ResourceRecord> getRecords(QuestionRecord question) {\r\n                String name = question.getDomainName();\r\n                if (name.equals(host)) {\r\n                    return Collections.<ResourceRecord>singleton(\r\n                            new TestDnsServer.TestResourceRecord(name, RecordType.TXT,\r\n", "        this.dnsServerAddressStreamProvider =\r\n                checkNotNull(dnsServerAddressStreamProvider, \"dnsServerAddressStreamProvider\");\r\n        this.resolveCache = checkNotNull(resolveCache, \"resolveCache\");\r\n        this.cnameCache = checkNotNull(cnameCache, \"cnameCache\");\r\n        this.dnsQueryLifecycleObserverFactory = traceEnabled ?\r\n", "                return null;\r\n            }\r\n        });\r\n        dnsServer3.start();\r\n        DnsNameResolver resolver = null;\r\n", "            assertEquals(2, cnameQueries.get());\r\n            assertEquals(4, aQueries.get());\r\n        } finally {\r\n            dnsServer2.stop();\r\n            if (resolver != null) {\r\n", "    }\r\n\r\n    @Test(timeout = DEFAULT_TEST_TIMEOUT_MS)\r\n    public void testNonCachedResolveAllNullHostName() throws Exception {\r\n        testNonCachedResolveAllEmptyHostName(null);\r\n", "                    map1.put(DnsAttribute.CHARACTER_STRING.toLowerCase(), txt1);\r\n\r\n                    Map<String, Object> map2 = new HashMap<String, Object>();\r\n                    map2.put(DnsAttribute.CHARACTER_STRING.toLowerCase(), txt2);\r\n\r\n", "\r\n            TestRecursiveCacheDnsQueryLifecycleObserverFactory lifecycleObserverFactory =\r\n                    (TestRecursiveCacheDnsQueryLifecycleObserverFactory) resolver.dnsQueryLifecycleObserverFactory();\r\n            TestDnsQueryLifecycleObserver observer = lifecycleObserverFactory.observers.poll();\r\n            if (observer != null) {\r\n", "                \"nameserver 127.0.0.3\\n\");\r\n        UnixResolverDnsServerAddressStreamProvider p =\r\n                new UnixResolverDnsServerAddressStreamProvider(f, null);\r\n\r\n        DnsServerAddressStream stream = p.nameServerAddressStream(\"somehost\");\r\n", "        headerBlock.writeInt(1);\r\n        headerBlock.writeInt(4);\r\n        decoder.decode(ByteBufAllocator.DEFAULT, headerBlock, frame);\r\n        decoder.endHeaderBlock(frame);\r\n\r\n", "    }\r\n\r\n    @Test(timeout = DEFAULT_TEST_TIMEOUT_MS)\r\n    public void testNonCachedResolveNullHostName() throws Exception {\r\n        testNonCachedResolveEmptyHostName(null);\r\n", "    extends AbstractBinaryMemcacheEncoder<BinaryMemcacheResponse> {\r\n\r\n    @Override\r\n    protected void encodeHeader(ByteBuf buf, BinaryMemcacheResponse msg) {\r\n        buf.writeByte(msg.magic());\r\n", "                redirectedRef.set(stream);\r\n                return stream;\r\n            }\r\n        };\r\n\r\n", "        encodeControlFrameHeader(buf, type, flags, length);\r\n        buf.writeInt(id);\r\n\r\n        decoder.decode(buf);\r\n        verify(delegate).readPingFrame(id);\r\n", "        } finally {\r\n            b.queryCNAMEd(cnameQuestion);\r\n        }\r\n        return this;\r\n    }\r\n", "                            channel.close();\r\n\r\n                            if (future.isSuccess()) {\r\n                                qCtx.finish(future.getNow());\r\n                                res.release();\r\n", "        decoder.decode(buf);\r\n        verify(delegate).readDataFrame(streamId, false, Unpooled.EMPTY_BUFFER);\r\n        assertFalse(buf.isReadable());\r\n        buf.release();\r\n    }\r\n", "        decoder.decode(buf);\r\n        verify(delegate).readDataFrame(streamId, false, Unpooled.EMPTY_BUFFER);\r\n        assertFalse(buf.isReadable());\r\n        buf.release();\r\n    }\r\n", "    }\r\n\r\n    private InetAddress loopbackAddress() {\r\n        return preferredAddressType().localhost();\r\n    }\r\n", "\r\n    @Test\r\n    public void testExceptionMsgContainsSearchDomain() throws Exception {\r\n        TestDnsServer.MapRecordStoreA store = new TestDnsServer.MapRecordStoreA(Collections.<String>emptySet());\r\n        dnsServer = new TestDnsServer(store);\r\n", "        }\r\n\r\n        @Override\r\n        public DnsServerAddressStream duplicate() {\r\n            return new CombinedDnsServerAddressStream(replaced, resolvedAddresses, originalStream.duplicate());\r\n", "                triedCNAME = true;\r\n\r\n                query(hostname, DnsRecordType.CNAME, getNameServers(hostname), true, promise);\r\n                return;\r\n            }\r\n", "    }\r\n\r\n    @Override\r\n    protected boolean closeAfterContinueResponse(Object msg) throws Exception {\r\n        throw new UnsupportedOperationException();\r\n", "            return toFullRequest((BinaryMemcacheRequest) start, content);\r\n        }\r\n\r\n        if (start instanceof BinaryMemcacheResponse) {\r\n            return toFullResponse((BinaryMemcacheResponse) start, content);\r\n", "        verify(delegate).readSynReplyFrame(streamId, false);\r\n        verify(delegate).readHeaderBlock(headerBlock.slice(0, headerBlock.writerIndex()));\r\n        verify(delegate).readHeaderBlockEnd();\r\n        assertFalse(buf.isReadable());\r\n        assertFalse(headerBlock.isReadable());\r\n", "    public void shouldEncodeKey() {\r\n        ByteBuf key = Unpooled.copiedBuffer(\"netty\", CharsetUtil.UTF_8);\r\n        int keyLength = key.readableBytes();\r\n\r\n        BinaryMemcacheRequest request = new DefaultBinaryMemcacheRequest(key);\r\n", "        // TODO(scott): how is this done on Windows? This may require a JNI call to GetNetworkParams\r\n        // https://msdn.microsoft.com/en-us/library/aa365968(VS.85).aspx.\r\n        static final DnsServerAddressStreamProvider DEFAULT_DNS_SERVER_ADDRESS_STREAM_PROVIDER =\r\n                new DnsServerAddressStreamProvider() {\r\n                    private volatile DnsServerAddressStreamProvider currentProvider = provider();\r\n", "            return true;\r\n        }\r\n\r\n        @Override\r\n        public Object get() {\r\n", "        state = State.BAD_MESSAGE;\r\n        M message = buildInvalidMessage();\r\n        message.setDecoderResult(DecoderResult.failure(cause));\r\n        return message;\r\n    }\r\n", "\r\n                    private DnsServerAddressStreamProvider provider() {\r\n                        // If on windows just use the DefaultDnsServerAddressStreamProvider.INSTANCE as otherwise\r\n                        // we will log some error which may be confusing.\r\n                        return PlatformDependent.isWindows() ? DefaultDnsServerAddressStreamProvider.INSTANCE :\r\n", "\r\n        copiedBuilder.queryTimeoutMillis(queryTimeoutMillis);\r\n        copiedBuilder.resolvedAddressTypes(resolvedAddressTypes);\r\n        copiedBuilder.recursionDesired(recursionDesired);\r\n        copiedBuilder.maxQueriesPerResolve(maxQueriesPerResolve);\r\n", "        final String ipv4Addr = \"1.2.3.4\";\r\n        final AtomicInteger server2Counter = new AtomicInteger();\r\n        final TestDnsServer dnsServer2 = new TestDnsServer(new RecordStore() {\r\n            @Override\r\n            public Set<ResourceRecord> getRecords(QuestionRecord question) {\r\n", "        }\r\n\r\n        public List<String> getAddresses(String domain) {\r\n            return domainMap.get(domain);\r\n        }\r\n", "        modifier.setRecursionDesired(message.isRecursionDesired());\r\n        modifier.setReserved(message.isReserved());\r\n        modifier.setResponseCode(message.getResponseCode());\r\n        modifier.setTransactionId(message.getTransactionId());\r\n        modifier.setTruncated(message.isTruncated());\r\n", "        public DnsServerAddressStream get(String hostname) {\r\n            // To not risk falling into any loop, we will not use the cache while following redirects but only\r\n            // on the initial query.\r\n            return null;\r\n        }\r\n", "            return ((MemcacheContent) msg).content().readableBytes();\r\n        }\r\n        if (msg instanceof ByteBuf) {\r\n            return ((ByteBuf) msg).readableBytes();\r\n        }\r\n", "        verify(delegate).readHeaderBlockEnd();\r\n        assertFalse(buf.isReadable());\r\n        buf.release();\r\n    }\r\n\r\n", "        verify(delegate).readHeaderBlockEnd();\r\n        assertFalse(buf.isReadable());\r\n        buf.release();\r\n    }\r\n\r\n", "        verify(delegate).readHeaderBlockEnd();\r\n        assertFalse(buf.isReadable());\r\n        buf.release();\r\n    }\r\n\r\n", "\r\n    @Override\r\n    public FullBinaryMemcacheResponse retain(int increment) {\r\n        super.retain(increment);\r\n        return this;\r\n", "        final TestDnsServer dnsServer1 = new TestDnsServer(Collections.singleton(\"notnetty.com\"));\r\n        final TestDnsServer dnsServer2 = new TestDnsServer(Collections.singleton(knownHostName));\r\n        DnsNameResolver resolver = null;\r\n        try {\r\n            dnsServer1.start();\r\n", "            }\r\n        });\r\n        dnsServer2.start();\r\n        DnsNameResolver resolver = null;\r\n        try {\r\n", "\r\n    TestDnsServer(RecordStore store) {\r\n        this.store = store;\r\n    }\r\n\r\n", "        }\r\n    }\r\n\r\n    private static final class TestRecordStore implements RecordStore {\r\n        private static final int[] NUMBERS = new int[254];\r\n", "import java.util.Map.Entry;\r\nimport java.util.concurrent.ConcurrentMap;\r\nimport java.util.concurrent.Delayed;\r\nimport java.util.concurrent.ScheduledFuture;\r\nimport java.util.concurrent.TimeUnit;\r\n", "                            Collections.<String, Object>singletonMap(\r\n                                    DnsAttribute.IP_ADDRESS.toLowerCase(), \"10.0.0.99\")));\r\n                }\r\n                if (\"x.netty.io\".equals(question.getDomainName())) {\r\n                    cnameQueries.incrementAndGet();\r\n", "\r\n                // Test again via cache.\r\n                resolver.resolveAll(hostname).syncUninterruptibly();\r\n\r\n                observer = lifecycleObserverFactory.observers.poll();\r\n", "        decoder.decode(buf);\r\n        verify(delegate).readDataFrame(streamId, true, Unpooled.EMPTY_BUFFER);\r\n        assertFalse(buf.isReadable());\r\n        buf.release();\r\n    }\r\n", "    protected void resetDecoder() {\r\n        if (currentMessage != null) {\r\n            currentMessage.release();\r\n            currentMessage = null;\r\n        }\r\n", "\r\n        String a = \"host1.foo.com\";\r\n        List<String> resolved = assertResolveAll(resolver, a);\r\n        assertEquals(store.getAddresses(\"host1.foo.com\"), resolved);\r\n\r\n", "                    map.put(new InetSocketAddress(NetUtil.LOCALHOST6, port), newContexts);\r\n                } else {\r\n                    map.put(new InetSocketAddress(toCompactAddress(a4), port), newContexts);\r\n                }\r\n            } else if (a instanceof Inet6Address) {\r\n", "            }\r\n\r\n            // Check if the response was truncated and if we can fallback to TCP to retry.\r\n            if (!res.isTruncated() || socketChannelFactory == null) {\r\n                qCtx.finish(res);\r\n", "        }\r\n\r\n        if (cnameCache != null) {\r\n            copiedBuilder.cnameCache(cnameCache);\r\n        }\r\n", "            }\r\n\r\n            ScheduledFuture<?> expirationFuture = FUTURE_UPDATER.getAndSet(this, CANCELLED);\r\n            if (expirationFuture != null) {\r\n                expirationFuture.cancel(false);\r\n", "    @Test\r\n    public void testResolveAll() throws Exception {\r\n        Set<String> domains = new HashSet<String>();\r\n        domains.add(\"host1.foo.com\");\r\n        domains.add(\"host1\");\r\n", "        return this.dnsServerAddressStreamProvider;\r\n    }\r\n\r\n    /**\r\n     * Set the {@link DnsServerAddressStreamProvider} which is used to determine which DNS server is used to resolve\r\n", "        buf.writeInt(streamId);\r\n        buf.writeInt(deltaWindowSize);\r\n\r\n        decoder.decode(buf);\r\n        verify(delegate).readFrameError(anyString());\r\n", "                    records.add(new TestResourceRecord(name, questionRecord.getRecordType(), attributes));\r\n                }\r\n                return records;\r\n            }\r\n            return null;\r\n", "        }\r\n        BinaryMemcacheRequest read = channel.readInbound();\r\n        read.release();\r\n        // tearDown will call \"channel.finish()\"\r\n    }\r\n", "            writtenEvent = (QueryWrittenEvent) observer.events.poll();\r\n            assertEquals(dnsServer2.localAddress(), writtenEvent.dnsServerAddress);\r\n            QuerySucceededEvent succeededEvent = (QuerySucceededEvent) observer.events.poll();\r\n        } finally {\r\n            if (resolver != null) {\r\n", "            builder.resolvedAddressTypes(ResolvedAddressTypes.IPV4_ONLY);\r\n\r\n            resolver = builder.build();\r\n            List<DnsRecord> resolvedAddresses = resolver.resolveAll(new DefaultDnsQuestion(name, A))\r\n                    .syncUninterruptibly().getNow();\r\n", "                    // Check if we need to release the envelope itself. If the query was cancelled the getNow() will\r\n                    // return null as well as the Future will be failed with a CancellationException.\r\n                    AddressedEnvelope<DnsResponse, InetSocketAddress> result = future.getNow();\r\n                    if (result != null) {\r\n                        result.release();\r\n", "\r\n    protected ChannelFactory<? extends DatagramChannel> channelFactory() {\r\n        return this.channelFactory;\r\n    }\r\n\r\n", "        verify(delegate).readHeadersFrame(streamId, false);\r\n        verify(delegate).readHeaderBlockEnd();\r\n        assertFalse(buf.isReadable());\r\n        buf.release();\r\n    }\r\n", "            return null;\r\n        }\r\n\r\n        synchronized (contexts) {\r\n            return  contexts.remove(id);\r\n", "\r\n            resolver = builder.build();\r\n            List<InetAddress> addressList = resolver.resolveAll(host).syncUninterruptibly().getNow();\r\n            assertEquals(1, addressList.size());\r\n            assertEquals(host, addressList.get(0).getHostName());\r\n", "            channel.writeInbound(incoming.readBytes(5));\r\n        }\r\n        incoming.release();\r\n\r\n        BinaryMemcacheRequest request = channel.readInbound();\r\n", "                    .completeOncePreferredResolved(true)\r\n                    .maxQueriesPerResolve(16)\r\n                    .nameServerProvider(new SingletonDnsServerAddressStreamProvider(dnsServer2.localAddress()));\r\n\r\n            resolver = builder.build();\r\n", "        }\r\n    }\r\n\r\n    private IntObjectMap<DnsQueryContext> getContextMap(InetSocketAddress nameServerAddr) {\r\n        synchronized (map) {\r\n", "        encodeControlFrameHeader(buf, type, flags, length);\r\n        buf.writeInt(lastGoodStreamId | 0x80000000); // should ignore reserved bit\r\n        buf.writeInt(statusCode);\r\n\r\n        decoder.decode(buf);\r\n", "\r\n                            if (logger.isDebugEnabled()) {\r\n                                logger.debug(\"{} RECEIVED: TCP [{}: {}], {}\", channel, queryId,\r\n                                        channel.remoteAddress(), response);\r\n                            }\r\n", "\r\n        decoder.decode(buf);\r\n        verify(delegate).readSettingsFrame(false);\r\n        verify(delegate).readSettingsEnd();\r\n        assertFalse(buf.isReadable());\r\n", "\r\n        decoder.decode(buf);\r\n        verify(delegate).readSettingsFrame(false);\r\n        verify(delegate).readSettingsEnd();\r\n        assertFalse(buf.isReadable());\r\n", "        // is used.\r\n        resolved = assertResolve(resolver, \"host5.sub\");\r\n        assertEquals(store.getAddress(\"host5.sub.foo.com\"), resolved);\r\n    }\r\n\r\n", "\r\n        decoder.decode(buf);\r\n        verify(delegate).readRstStreamFrame(streamId, statusCode);\r\n        assertFalse(buf.isReadable());\r\n        buf.release();\r\n", "    @Test\r\n    public void testResolve() throws Exception {\r\n        Set<String> domains = new HashSet<String>();\r\n        domains.add(\"host1.foo.com\");\r\n        domains.add(\"host1\");\r\n", "            resolver.resolve(\"non-existent.netty.io\").sync();\r\n            fail();\r\n            return null;\r\n        } catch (Exception e) {\r\n            assertThat(e, is(instanceOf(UnknownHostException.class)));\r\n", "        });\r\n        dnsServer2.start();\r\n\r\n        final AtomicInteger server3Counter = new AtomicInteger();\r\n        final TestDnsServer dnsServer3 = new TestDnsServer(new RecordStore() {\r\n", "        // is used.\r\n        resolved = assertResolveAll(resolver, \"host5.sub\");\r\n        assertEquals(store.getAddresses(\"host5.sub.foo.com\"), resolved);\r\n    }\r\n\r\n", "                message.getAuthorityRecords().add(newNsRecord(name, \"unresolved.\" + dnsName));\r\n            }\r\n\r\n            return message;\r\n        }\r\n", "    /**\r\n     * Returns the timeout of each DNS query performed by this resolver (in milliseconds).\r\n     * The default value is 5 seconds.\r\n     */\r\n    public long queryTimeoutMillis() {\r\n", "    public void testTruncatedWithoutTcpFallback() throws IOException {\r\n        testTruncated0(false, false);\r\n    }\r\n\r\n    @Test(timeout = 5000)\r\n", "        String resolved = assertResolve(resolver, \"host1\");\r\n        assertEquals(store.getAddress(\"host1.foo.com\"), resolved);\r\n\r\n        // \"host2\" resolves via the \"bar.com\" search path\r\n        resolved = assertResolve(resolver, \"host2\");\r\n", "                        question.getDomainName(), RecordType.CNAME,\r\n                        Collections.<String, Object>singletonMap(\r\n                                DnsAttribute.DOMAIN_NAME.toLowerCase(), \"cname.netty.io\")));\r\n                return records;\r\n            }\r\n", "        ).close();\r\n    }\r\n\r\n    @Test\r\n    public void testQueryTxt() throws Exception {\r\n", "        channel = new EmbeddedChannel(\r\n                new BinaryMemcacheResponseEncoder(),\r\n                new BinaryMemcacheResponseDecoder(),\r\n                new BinaryMemcacheObjectAggregator(1024));\r\n    }\r\n", "    @Test\r\n    public void testSearchDomainWithNdots2() throws Exception {\r\n        Set<String> domains = new HashSet<String>();\r\n        domains.add(\"host1.sub.foo.com\");\r\n        domains.add(\"host2.sub.foo.com\");\r\n", " * Use this codec if you want to implement a memcache client that speaks the binary protocol. It\r\n * combines both the {@link BinaryMemcacheResponseDecoder} and the {@link BinaryMemcacheRequestEncoder}.\r\n * <p/>\r\n * Optionally, it counts the number of outstanding responses and raises an exception if - on connection\r\n * close - the list is not 0 (this is turned off by default). You can also define a chunk size for the\r\n", "        resolver.close();\r\n        resolveLatch.await();\r\n        authoritativeLatch.await();\r\n    }\r\n\r\n", "        try {\r\n            DnsNameResolverBuilder builder = newResolver()\r\n                    .recursionDesired(true)\r\n                    .maxQueriesPerResolve(16)\r\n                    .nameServerProvider(new SingletonDnsServerAddressStreamProvider(dnsServer2.localAddress()));\r\n", "        ((ReferenceCounted) lastContent).release();\r\n\r\n        request = channel.readInbound();\r\n        assertThat(request, instanceOf(BinaryMemcacheRequest.class));\r\n        assertThat(request, notNullValue());\r\n", "    public MemcacheContent touch() {\r\n        super.touch();\r\n        return this;\r\n    }\r\n\r\n", "        } finally {\r\n            resolver.close();\r\n            group.shutdownGracefully(0, 0, TimeUnit.SECONDS);\r\n            redirectServer.stop();\r\n        }\r\n", "        buf.release();\r\n    }\r\n\r\n    @Test\r\n    public void testSpdySynStreamFrameHeaderBlock() throws Exception {\r\n", "        return resolve(resolveAllsInProgress, inetHost, promise, true);\r\n    }\r\n\r\n    private <U> Promise<U> resolve(\r\n            final ConcurrentMap<String, Promise<U>> resolveMap,\r\n", "                    return overriddenHostnames.contains(hostname) ? sequential(dnsServer2.localAddress()).stream() :\r\n                            null;\r\n                }\r\n            }).build();\r\n            try {\r\n", "\r\n        f = buildFile(\"search localdomain\\n\" +\r\n            \"nameserver 127.0.0.11\\n\" +\r\n            \"options foo:bar timeout:124\\n\");\r\n        assertEquals(124, parseEtcResolverOptions(f).timeout());\r\n", "        try {\r\n            Throwable cause = resolver.resolveAll(hostname).await().cause();\r\n            assertTrue(cause instanceof UnknownHostException);\r\n            DnsServerAddressStream redirected = redirectedRef.get();\r\n            assertNotNull(redirected);\r\n", "                    }\r\n                }\r\n\r\n                if (content != null) {\r\n                    // Our current implementation does not support reloading the hosts file,\r\n", "        buf.writeInt(streamId);\r\n        buf.writeInt(statusCode);\r\n\r\n        decoder.decode(buf);\r\n        verify(delegate).readFrameError(anyString());\r\n", "        encodeControlFrameHeader(buf, type, flags, length);\r\n        buf.writeInt(streamId);\r\n        buf.writeInt(deltaWindowSize);\r\n\r\n        decoder.decode(buf);\r\n", "    public DnsServerAddressStream get(String hostname) {\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n", "     * @param cnameQuestion the question we would use if we issue a new query.\r\n     * @return An observer for the new query which we may issue.\r\n     */\r\n    DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion);\r\n\r\n", "                            (InetSocketAddress) channel.remoteAddress(), qCtx.question(),\r\n                            EMPTY_ADDITIONALS, promise);\r\n\r\n                    channel.pipeline().addLast(new TcpDnsResponseDecoder());\r\n                    channel.pipeline().addLast(new ChannelInboundHandlerAdapter() {\r\n", "import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\r\n\r\nfinal class RotationalDnsServerAddresses extends DefaultDnsServerAddresses {\r\n\r\n    private static final AtomicIntegerFieldUpdater<RotationalDnsServerAddresses> startIdxUpdater =\r\n", "        return dnsServerAddressStreamProvider.nameServerAddressStream(hostname);\r\n    }\r\n\r\n    private final class DnsResponseHandler extends ChannelInboundHandlerAdapter {\r\n\r\n", "                }\r\n                if (\"y.netty.io\".equals(question.getDomainName())) {\r\n                    cnameQueries.incrementAndGet();\r\n\r\n                    return Collections.<ResourceRecord>singleton(new TestDnsServer.TestResourceRecord(\r\n", "        try {\r\n            a.queryWritten(dnsServerAddress, future);\r\n        } finally {\r\n            b.queryWritten(dnsServerAddress, future);\r\n        }\r\n", "\r\n                        // TCP fallback failed, just use the truncated response.\r\n                        qCtx.finish(res);\r\n                        return;\r\n                    }\r\n", "        }\r\n\r\n        if (dnsQueryLifecycleObserverFactory != null) {\r\n            copiedBuilder.dnsQueryLifecycleObserverFactory(dnsQueryLifecycleObserverFactory);\r\n        }\r\n", "    @Override\r\n    MemcacheContent retain();\r\n\r\n    @Override\r\n    MemcacheContent retain(int increment);\r\n", "        if (channelFactory != null) {\r\n            copiedBuilder.channelFactory(channelFactory);\r\n        }\r\n\r\n        if (socketChannelFactory != null) {\r\n", "        headerBlock.writeInt(1);\r\n        headerBlock.writeByte(0);\r\n        headerBlock.writeInt(5);\r\n        headerBlock.writeBytes(valueBytes);\r\n        decoder.decode(ByteBufAllocator.DEFAULT, headerBlock, frame);\r\n", "                public void operationComplete(ChannelFuture future) {\r\n                    if (!future.isSuccess()) {\r\n                        if (logger.isDebugEnabled()) {\r\n                            logger.debug(\"Unable to fallback to TCP [{}]\", queryId, future.cause());\r\n                        }\r\n", "        switch (state) {\r\n            case READ_HEADER: try {\r\n                if (in.readableBytes() < 24) {\r\n                    return;\r\n                }\r\n", "    }\r\n\r\n    @Override\r\n    public MemcacheContent retain() {\r\n        super.retain();\r\n", "                records.add(new TestDnsServer.TestResourceRecord(\r\n                        \"cname.netty.io\", RecordType.CNAME,\r\n                        Collections.<String, Object>singletonMap(\r\n                                DnsAttribute.DOMAIN_NAME.toLowerCase(), \"cname2.netty.io\")));\r\n                records.add(new TestDnsServer.TestResourceRecord(\r\n", "        } finally {\r\n            resolver.close();\r\n            group.shutdownGracefully(0, 0, TimeUnit.SECONDS);\r\n            dnsServer.stop();\r\n            dnsServerAuthority.stop();\r\n", "        buf.writeInt(statusCode);\r\n\r\n        decoder.decode(buf);\r\n        verify(delegate).readRstStreamFrame(streamId, statusCode);\r\n        assertFalse(buf.isReadable());\r\n", "            if (addr1.getAddress().getClass() == addr2.getAddress().getClass()) {\r\n                return 0;\r\n            }\r\n            return preferredAddressType.isAssignableFrom(addr1.getAddress().getClass()) ? -1 : 1;\r\n        }\r\n", "@UnstableApi\r\npublic abstract class AbstractMemcacheObject extends AbstractReferenceCounted implements MemcacheObject {\r\n\r\n    private DecoderResult decoderResult = DecoderResult.SUCCESS;\r\n\r\n", "        return this;\r\n    }\r\n\r\n    @Override\r\n    public BinaryMemcacheRequest touch() {\r\n", "            int hashCode = response.hashCode();\r\n            if (sender() != null) {\r\n                hashCode = hashCode * 31 + sender().hashCode();\r\n            }\r\n            if (recipient() != null) {\r\n", "        }\r\n\r\n        if (finalResult != null) {\r\n            if (!promise.isDone()) {\r\n                // Found at least one resolved record.\r\n", "            // Now, try to resolve again to see if it's cached.\r\n            // This test works because the DNS servers usually randomizes the order of the records in a response.\r\n            // If cached, the resolved addresses must be always same, because we reuse the same response.\r\n\r\n            final Map<String, InetAddress> resultB = testResolve0(resolver, EXCLUSIONS_RESOLVE_A, null);\r\n", "                                DnsAttribute.IP_ADDRESS.toLowerCase(), \"10.0.0.99\")));\r\n                records.add(new TestDnsServer.TestResourceRecord(\r\n                        \"cname2.netty.io\", RecordType.CNAME,\r\n                        Collections.<String, Object>singletonMap(\r\n                                DnsAttribute.DOMAIN_NAME.toLowerCase(), \"cname.netty.io\")));\r\n", " * {@link BinaryMemcacheResponseEncoder} to request decoding and response encoding.\r\n */\r\n@UnstableApi\r\npublic class BinaryMemcacheServerCodec extends\r\n        CombinedChannelDuplexHandler<BinaryMemcacheRequestDecoder, BinaryMemcacheResponseEncoder> {\r\n", "\r\n        // \"host2.sub\" is resolved with the foo.com search domain as ndots = 2\r\n        resolved = assertResolve(resolver, \"host2.sub\");\r\n        assertEquals(store.getAddress(\"host2.sub.foo.com\"), resolved);\r\n    }\r\n", "        File f = folder.newFile();\r\n        OutputStream out = new FileOutputStream(f);\r\n        try {\r\n            out.write(contents.getBytes(CharsetUtil.UTF_8));\r\n        } finally {\r\n", "            found = true;\r\n\r\n            if (shouldRelease) {\r\n                ReferenceCountUtil.release(converted);\r\n            }\r\n", "                try {\r\n                    if (queryCause == null) {\r\n                        onResponse(nameServerAddrStream, nameServerAddrStreamIndex, question, future.getNow(),\r\n                                   queryLifecycleObserver, promise);\r\n                    } else {\r\n", "\r\n        if (optResource != null) {\r\n            query.addRecord(DnsSection.ADDITIONAL, optResource);\r\n        }\r\n\r\n", "        // See:\r\n        // - https://docs.oracle.com/javase/8/docs/technotes/guides/jndi/jndi-dns.html\r\n        // - https://mail.openjdk.java.net/pipermail/net-dev/2017-March/010695.html\r\n        Hashtable<String, String> env = new Hashtable<String, String>();\r\n        env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.dns.DnsContextFactory\");\r\n", "                    .nameServerProvider(new SingletonDnsServerAddressStreamProvider(dnsServer2.localAddress()));\r\n            builder.resolvedAddressTypes(ResolvedAddressTypes.IPV4_ONLY);\r\n\r\n            resolver = builder.build();\r\n            List<InetAddress> resolvedAddresses = resolver.resolveAll(name).syncUninterruptibly().getNow();\r\n", "        encodeControlFrameHeader(buf, type, flags, length);\r\n        buf.writeInt(streamId);\r\n        buf.writeInt(statusCode);\r\n\r\n        decoder.decode(buf);\r\n", "    @Override\r\n    public BinaryMemcacheResponse setStatus(short status) {\r\n        this.status = status;\r\n        return this;\r\n    }\r\n", "    }\r\n\r\n    @Override\r\n    public void operationComplete(Future<AddressedEnvelope<DnsResponse, InetSocketAddress>> future) {\r\n        // Cancel the timeout task.\r\n", "     * Create a new instance.\r\n     * @param providers The providers to use for DNS resolution. They will be queried in order.\r\n     */\r\n    public MultiDnsServerAddressStreamProvider(DnsServerAddressStreamProvider... providers) {\r\n        this.providers = providers.clone();\r\n", "                            qName, RecordType.CNAME,\r\n                            Collections.<String, Object>singletonMap(\r\n                                    DnsAttribute.DOMAIN_NAME.toLowerCase(), \"cname.netty.io\")));\r\n                    records.add(new TestDnsServer.TestResourceRecord(qName,\r\n                            RecordType.A, Collections.<String, Object>singletonMap(\r\n", "    BinaryMemcacheResponse retain();\r\n\r\n    @Override\r\n    BinaryMemcacheResponse retain(int increment);\r\n\r\n", "\r\n    @Override\r\n    public FullBinaryMemcacheRequest copy() {\r\n        ByteBuf key = key();\r\n        if (key != null) {\r\n", "        File f = buildFile(\"domain linecorp.local\\n\" +\r\n                           \"nameserver 127.0.0.2\\n\" +\r\n                           \"nameserver 127.0.0.3\\n\");\r\n        File f2 = buildFile(\"domain dc1.linecorp.local\\n\" +\r\n                            \"nameserver 127.0.0.4\\n\" +\r\n", "        buf.writeInt(associatedToStreamId);\r\n        buf.writeByte(priority << 5);\r\n        buf.writeByte(0);\r\n\r\n        decoder.decode(buf);\r\n", "    private DnsServerAddressStreamProviders() {\r\n    }\r\n\r\n    /**\r\n     * A {@link DnsServerAddressStreamProvider} which inherits the DNS servers from your local host's configuration.\r\n", "            this.domains = domains;\r\n        }\r\n\r\n        @Override\r\n        public Set<ResourceRecord> getRecords(QuestionRecord questionRecord) {\r\n", "        if (addr1.isUnresolved() && addr2.isUnresolved()) {\r\n            return 0;\r\n        }\r\n        return addr1.isUnresolved() ? 1 : -1;\r\n    }\r\n", "                if (name.equals(host)) {\r\n                    Set<ResourceRecord> records = new HashSet<ResourceRecord>(2);\r\n                    records.add(new TestDnsServer.TestResourceRecord(name, RecordType.A,\r\n                            Collections.<String, Object>singletonMap(DnsAttribute.IP_ADDRESS.toLowerCase(),\r\n                                    \"10.0.0.1\")));\r\n", "        String resolved = assertResolve(resolver, \"host1\");\r\n        assertEquals(store.getAddress(\"host1\"), resolved);\r\n\r\n        // \"host1.foo.com\" resolves to host1.foo\r\n        resolved = assertResolve(resolver, \"host1.foo.com\");\r\n", "    }\r\n\r\n    @Override\r\n    public BinaryMemcacheRequest retain(int increment) {\r\n        super.retain(increment);\r\n", "            @Override\r\n            public Set<ResourceRecord> getRecords(QuestionRecord question) {\r\n                Set<ResourceRecord> records = new LinkedHashSet<ResourceRecord>(2);\r\n                String qName = question.getDomainName().toLowerCase();\r\n                records.add(new TestDnsServer.TestResourceRecord(qName,\r\n", "                // be invoked very concurrently and also we use SECONDS anyway. If this ever becomes a problem\r\n                // we can reconsider.\r\n                ScheduledFuture<?> oldFuture = FUTURE_UPDATER.get(this);\r\n                if (oldFuture == null || oldFuture.getDelay(TimeUnit.SECONDS) > ttl) {\r\n                    ScheduledFuture<?> newFuture = loop.schedule(this, ttl, TimeUnit.SECONDS);\r\n", "                dnsServerAddressStreamProvider.nameServerAddressStream(hostname);\r\n        new DnsRecordResolveContext(this, promise, question, additionals, nameServerAddrs, maxQueriesPerResolve)\r\n                .resolve(promise);\r\n        return promise;\r\n    }\r\n", "    @Override\r\n    DnsRecord convertRecord(DnsRecord record, String hostname, DnsRecord[] additionals, EventLoop eventLoop) {\r\n        return ReferenceCountUtil.retain(record);\r\n    }\r\n\r\n", "        if (!writeFuture.isSuccess()) {\r\n            tryFailure(\"failed to send a query via \" + protocol(), writeFuture.cause(), false);\r\n            return;\r\n        }\r\n\r\n", "        super(eventLoop);\r\n        this.queryTimeoutMillis = queryTimeoutMillis > 0\r\n            ? queryTimeoutMillis\r\n            : TimeUnit.SECONDS.toMillis(DEFAULT_OPTIONS.timeout());\r\n        this.resolvedAddressTypes = resolvedAddressTypes != null ? resolvedAddressTypes : DEFAULT_RESOLVE_ADDRESS_TYPES;\r\n", "            String name = questionRecord.getDomainName();\r\n            if (domains.contains(name)) {\r\n                Map<String, Object> attr = new HashMap<String, Object>();\r\n                switch (questionRecord.getRecordType()) {\r\n                    case A:\r\n", "        resolved = assertResolveAll(resolver, \"host1.\");\r\n        assertEquals(store.getAddresses(\"host1\"), resolved);\r\n\r\n        // \"host2\" not resolved\r\n        assertNotResolveAll(resolver, \"host2\");\r\n", "\r\n    @Override\r\n    public FullBinaryMemcacheResponse copy() {\r\n        ByteBuf key = key();\r\n        if (key != null) {\r\n", "    // Directly extend AtomicReference for intrinsics and also to keep memory overhead low.\r\n    private final class Entries extends AtomicReference<List<E>> implements Runnable {\r\n\r\n        private final String hostname;\r\n        // Needs to be package-private to be able to access it via the AtomicReferenceFieldUpdater\r\n", "        @Override\r\n        public void readHeaderBlockEnd() {\r\n            delegate.readHeaderBlockEnd();\r\n        }\r\n\r\n", "            if (addresses != null && questionRecord.getRecordType() == RecordType.A) {\r\n                Set<ResourceRecord> records = new LinkedHashSet<ResourceRecord>();\r\n                for (String address : addresses) {\r\n                    Map<String, Object> attributes = new HashMap<String, Object>();\r\n                    attributes.put(DnsAttribute.IP_ADDRESS.toLowerCase(), address);\r\n", "            public Set<ResourceRecord> getRecords(QuestionRecord question) {\r\n                Set<ResourceRecord> records = new LinkedHashSet<ResourceRecord>(4);\r\n                String qName = question.getDomainName().toLowerCase();\r\n                if (qName.equals(name)) {\r\n                    records.add(new TestDnsServer.TestResourceRecord(\r\n", "        return this;\r\n    }\r\n\r\n    @Override\r\n    public BinaryMemcacheResponse touch() {\r\n", "        encodeControlFrameHeader(buf, type, flags, length);\r\n        buf.writeInt(streamId);\r\n\r\n        decoder.decode(buf);\r\n        verify(delegate).readHeadersFrame(streamId, true);\r\n", "\r\n    public BinaryMemcacheServerCodec() {\r\n        this(AbstractBinaryMemcacheDecoder.DEFAULT_MAX_CHUNK_SIZE);\r\n    }\r\n\r\n", "                    // (2) This is a trade-off to avoid concurrency resulting in contention on a synchronized block.\r\n                    if (FUTURE_UPDATER.compareAndSet(this, oldFuture, newFuture)) {\r\n                        if (oldFuture != null) {\r\n                            oldFuture.cancel(true);\r\n                        }\r\n", "    public void testTruncatedWithTcpFallback() throws IOException {\r\n        testTruncated0(true, false);\r\n    }\r\n\r\n    @Test(timeout = 5000)\r\n", "        public void readPingFrame(int id) {\r\n            delegate.readPingFrame(id);\r\n        }\r\n\r\n        @Override\r\n", "        try {\r\n            testResolve0(resolver, EXCLUSIONS_RESOLVE_A, AAAA);\r\n        } finally {\r\n            resolver.close();\r\n        }\r\n", "        dnsServer.start();\r\n\r\n        resolver = newResolver().searchDomains(Collections.singleton(\"foo.com\")).ndots(0).build();\r\n\r\n        // \"host1\" resolves directly as ndots = 0\r\n", "            dnsServer3.stop();\r\n            if (resolver != null) {\r\n                resolver.close();\r\n            }\r\n        }\r\n", "            dnsServer3.stop();\r\n            if (resolver != null) {\r\n                resolver.close();\r\n            }\r\n        }\r\n", "            dnsServer3.stop();\r\n            if (resolver != null) {\r\n                resolver.close();\r\n            }\r\n        }\r\n", "    public void shouldDecodeRequestWithSimpleValue() {\r\n        ByteBuf incoming = Unpooled.buffer();\r\n        incoming.writeBytes(GET_REQUEST);\r\n        channel.writeInbound(incoming);\r\n\r\n", "            }\r\n        }\r\n        final UnknownHostException unknownHostException = new UnknownHostException(buf.toString());\r\n        if (cause == null) {\r\n            // Only cache if the failure was not because of an IO error / timeout that was caused by the query\r\n", "            Method open = configClass.getMethod(\"open\");\r\n            Method nameservers = configClass.getMethod(\"searchlist\");\r\n            Object instance = open.invoke(null);\r\n\r\n            return (List<String>) nameservers.invoke(instance);\r\n", "                                current = currentProvider = provider();\r\n                            }\r\n                        }\r\n                        return current.nameServerAddressStream(hostname);\r\n                    }\r\n", "        env.put(\"java.naming.provider.url\", \"dns://\");\r\n\r\n        try {\r\n            DirContext ctx = new InitialDirContext(env);\r\n            String dnsUrls = (String) ctx.getEnvironment().get(\"java.naming.provider.url\");\r\n", "        public void setDecoderResult(DecoderResult result) {\r\n            throw new UnsupportedOperationException(\"read only\");\r\n        }\r\n\r\n        @Override\r\n", "                        break;\r\n                    default:\r\n                        return null;\r\n                }\r\n                return Collections.<ResourceRecord>singleton(\r\n", "        if (dnsServer != null) {\r\n            dnsServer.stop();\r\n            dnsServer = null;\r\n        }\r\n        if (resolver != null) {\r\n", "        channel = new EmbeddedChannel(new BinaryMemcacheResponseDecoder());\r\n\r\n        channel.writeInbound(Unpooled.buffer().writeBytes(GET_RESPONSE_CHUNK_1));\r\n        channel.writeInbound(Unpooled.buffer().writeBytes(GET_RESPONSE_CHUNK_2));\r\n\r\n", "                resolver.close();\r\n            }\r\n        }\r\n    }\r\n\r\n", "                resolver.close();\r\n            }\r\n        }\r\n    }\r\n\r\n", "                resolver.close();\r\n            }\r\n        }\r\n    }\r\n\r\n", "        // host1 resolves host1.foo.com with foo.com search domain\r\n        resolved = assertResolve(resolver, \"host1\");\r\n        assertEquals(store.getAddress(\"host1.foo.com\"), resolved);\r\n\r\n        // \"host1.\" absolute query\r\n", "        }\r\n\r\n        private final Set<String> domains;\r\n\r\n        private TestRecordStore(Set<String> domains) {\r\n", "                .build();\r\n\r\n        try {\r\n            resolver.resolve(\"non-existent.netty.io\", promise).sync();\r\n            fail();\r\n", "            resolver.close();\r\n            group.shutdownGracefully(0, 0, TimeUnit.SECONDS);\r\n            redirectServer.stop();\r\n            dnsServerAuthority.stop();\r\n            socket.close();\r\n", "\r\n        decoder.decode(buf);\r\n        verify(delegate).readWindowUpdateFrame(streamId, deltaWindowSize);\r\n        assertFalse(buf.isReadable());\r\n        buf.release();\r\n", "        // host1 resolves host1.foo.com with foo.com search domain\r\n        resolved = assertResolveAll(resolver, \"host1\");\r\n        assertEquals(store.getAddresses(\"host1.foo.com\"), resolved);\r\n\r\n        // \"host1.\" absolute query\r\n", "    /**\r\n     * Create a new {@link BinaryMemcacheClientCodec} with the default settings applied.\r\n     */\r\n    public BinaryMemcacheClientCodec() {\r\n        this(AbstractBinaryMemcacheDecoder.DEFAULT_MAX_CHUNK_SIZE);\r\n", "                                overriddenIP, resolvedEntry.getValue().getHostAddress());\r\n                    }\r\n                }\r\n            } finally {\r\n                resolver.close();\r\n", "                        DnsServerAddressStreamProvider current = currentProvider;\r\n                        if (System.nanoTime() - last > REFRESH_INTERVAL) {\r\n                            // This is slightly racy which means it will be possible still use the old configuration\r\n                            // for a small amount of time, but that's ok.\r\n                            if (lastRefresh.compareAndSet(last, System.nanoTime())) {\r\n", "                        @Override\r\n                        public void channelRead(ChannelHandlerContext ctx, Object msg) {\r\n                            Channel channel = ctx.channel();\r\n                            DnsResponse response = (DnsResponse) msg;\r\n                            int queryId = response.id();\r\n", "                return;\r\n            }\r\n\r\n            // Retry with the next server if the server did not tell us that the domain does not exist.\r\n            if (code != DnsResponseCode.NXDOMAIN) {\r\n", "\r\n                            DnsQueryContext foundCtx = queryContextManager.get(res.sender(), queryId);\r\n                            if (foundCtx == tcpCtx) {\r\n                                tcpCtx.finish(new AddressedEnvelopeAdapter(\r\n                                        (InetSocketAddress) ctx.channel().remoteAddress(),\r\n", "            return;\r\n        }\r\n        query(stream, 0, cnameQuestion, queryLifecycleObserver.queryCNAMEd(cnameQuestion),\r\n              true, promise, null);\r\n    }\r\n", "        resolved = assertResolve(resolver, \"host1.\");\r\n        assertEquals(store.getAddress(\"host1\"), resolved);\r\n\r\n        // \"host2\" not resolved\r\n        assertNotResolve(resolver, \"host2\");\r\n", "        decoder.decode(buf);\r\n        verify(delegate).readSynReplyFrame(streamId, true);\r\n        verify(delegate).readHeaderBlockEnd();\r\n        assertFalse(buf.isReadable());\r\n        buf.release();\r\n", "        return this;\r\n    }\r\n\r\n    @Override\r\n    public MemcacheContent retain(int increment) {\r\n", "@UnstableApi\r\npublic interface MemcacheContent extends MemcacheObject, ByteBufHolder {\r\n\r\n    @Override\r\n    MemcacheContent copy();\r\n", "\r\n        String a = \"host1.foo.com\";\r\n        String resolved = assertResolve(resolver, a);\r\n        assertEquals(store.getAddress(\"host1.foo.com\"), resolved);\r\n\r\n", "            builder.nameServerProvider(new SequentialDnsServerAddressStreamProvider(dnsServer1Address,\r\n                    dnsServer2.localAddress()));\r\n            resolver = builder.build();\r\n            assertNotNull(resolver.resolve(knownHostName).syncUninterruptibly().getNow());\r\n\r\n", "            DnsServerAddressStream stream = provider.nameServerAddressStream(hostname);\r\n            if (stream != null) {\r\n                return stream;\r\n            }\r\n        }\r\n", "        public void readSynReplyFrame(int streamId, boolean last) {\r\n            delegate.readSynReplyFrame(streamId, last);\r\n        }\r\n\r\n        @Override\r\n", "\r\n    @Override\r\n    protected DnsQuery newQuery(int id) {\r\n        return new DatagramDnsQuery(null, nameServerAddr(), id);\r\n    }\r\n", "\r\n            final IntObjectMap<DnsQueryContext> newContexts = new IntObjectHashMap<DnsQueryContext>();\r\n            final InetAddress a = nameServerAddr.getAddress();\r\n            final int port = nameServerAddr.getPort();\r\n            map.put(nameServerAddr, newContexts);\r\n", "\r\n                    return Collections.<ResourceRecord>singleton(new TestDnsServer.TestResourceRecord(\r\n                            question.getDomainName(), RecordType.CNAME,\r\n                            Collections.<String, Object>singletonMap(\r\n                                    DnsAttribute.DOMAIN_NAME.toLowerCase(), \"cname.netty.io\")));\r\n", "    int add(DnsQueryContext qCtx) {\r\n        final IntObjectMap<DnsQueryContext> contexts = getOrCreateContextMap(qCtx.nameServerAddr());\r\n\r\n        int id = PlatformDependent.threadLocalRandom().nextInt(65536 - 1) + 1;\r\n        final int maxTries = 65535 << 1;\r\n", "        return promise.trySuccess((AddressedEnvelope<DnsResponse, InetSocketAddress>) envelope);\r\n    }\r\n\r\n    boolean tryFailure(String message, Throwable cause, boolean timeout) {\r\n        if (promise.isDone()) {\r\n", "        synchronized (map) {\r\n            final IntObjectMap<DnsQueryContext> contexts = map.get(nameServerAddr);\r\n            if (contexts != null) {\r\n                return contexts;\r\n            }\r\n", "\r\n        @Override\r\n        public Set<ResourceRecord> getRecords(QuestionRecord questionRecord) {\r\n            String name = questionRecord.getDomainName();\r\n            List<String> addresses = domainMap.get(name);\r\n", "        TestDnsServer dnsServer2 = new TestDnsServer(Collections.singleton(host));\r\n        dnsServer2.start(true);\r\n        DnsNameResolver resolver = null;\r\n        try {\r\n            DnsNameResolverBuilder builder = newResolver()\r\n", "\r\n        TestDnsServer dnsServer2 = new TestDnsServer(new RecordStore() {\r\n\r\n            @Override\r\n            public Set<ResourceRecord> getRecords(QuestionRecord question) {\r\n", "        verify(delegate, times(numSettings)).readSetting(id, value, false, false);\r\n        assertFalse(buf.isReadable());\r\n        buf.release();\r\n    }\r\n\r\n", "        verify(delegate, times(numSettings)).readSetting(id, value, false, false);\r\n        assertFalse(buf.isReadable());\r\n        buf.release();\r\n    }\r\n\r\n", "        decoder.decode(buf);\r\n        verify(delegate).readWindowUpdateFrame(streamId, deltaWindowSize);\r\n        assertFalse(buf.isReadable());\r\n        buf.release();\r\n    }\r\n", "                if (\"cname.netty.io\".equals(question.getDomainName())) {\r\n                    aQueries.incrementAndGet();\r\n\r\n                    return Collections.<ResourceRecord>singleton(new TestDnsServer.TestResourceRecord(\r\n                            question.getDomainName(), RecordType.A,\r\n", "        domains.add(\"host3\");\r\n        domains.add(\"host4.sub.foo.com\");\r\n        domains.add(\"host5.sub.foo.com\");\r\n        domains.add(\"host5.sub\");\r\n\r\n", "        domains.add(\"host3\");\r\n        domains.add(\"host4.sub.foo.com\");\r\n        domains.add(\"host5.sub.foo.com\");\r\n        domains.add(\"host5.sub\");\r\n\r\n", "abstract class Cache<E> {\r\n    private static final AtomicReferenceFieldUpdater<Cache.Entries, ScheduledFuture> FUTURE_UPDATER =\r\n            AtomicReferenceFieldUpdater.newUpdater(Cache.Entries.class, ScheduledFuture.class, \"expirationFuture\");\r\n\r\n    private static final ScheduledFuture<?> CANCELLED = new ScheduledFuture<Object>() {\r\n", "        }\r\n\r\n        @Override\r\n        public int refCnt() {\r\n            return response.refCnt();\r\n", "        decoder.decode(buf);\r\n        decoder.decode(headerBlock);\r\n        verify(delegate).readSynStreamFrame(streamId, associatedToStreamId, priority, false, false);\r\n        verify(delegate).readHeaderBlock(headerBlock.slice(0, headerBlock.writerIndex()));\r\n        verify(delegate).readHeaderBlockEnd();\r\n", "        dnsServer2.start();\r\n        DnsNameResolver resolver = null;\r\n        ServerSocket serverSocket = null;\r\n        try {\r\n            DnsNameResolverBuilder builder = newResolver()\r\n", "\r\n        decoder.decode(buf);\r\n        verify(delegate).readSynStreamFrame(streamId, associatedToStreamId, priority, false, true);\r\n        verify(delegate).readHeaderBlockEnd();\r\n        assertFalse(buf.isReadable());\r\n", "        verify(delegate, times(numSettings)).readSetting(id, value, false, true);\r\n        assertFalse(buf.isReadable());\r\n        buf.release();\r\n    }\r\n\r\n", "        dnsServer.start();\r\n\r\n        resolver = newResolver().searchDomains(Arrays.asList(\"foo.com\", \"bar.com\")).build();\r\n\r\n        // \"host1\" resolves via the \"foo.com\" search path\r\n", "        encodeControlFrameHeader(buf, type, flags, length);\r\n        buf.writeInt(streamId);\r\n        buf.writeInt(associatedToStreamId);\r\n        buf.writeByte(priority << 5);\r\n        buf.writeByte(0);\r\n", "                if (serverStream != null) {\r\n                    query(serverStream, 0, question,\r\n                          queryLifecycleObserver.queryRedirected(new DnsAddressStreamList(serverStream)),\r\n                          true, promise, null);\r\n                    return true;\r\n", "        }\r\n        return notifiedRecords;\r\n    }\r\n\r\n    private static void tryFailure(Promise<?> promise, Throwable cause) {\r\n", "                         ConcurrentMap<String, Promise<List<T>>> resolveAllsInProgress) {\r\n\r\n        this.executor = checkNotNull(executor, \"executor\");\r\n        this.delegate = checkNotNull(delegate, \"delegate\");\r\n        this.resolvesInProgress = checkNotNull(resolvesInProgress, \"resolvesInProgress\");\r\n", "\r\n            @Override\r\n            public Set<ResourceRecord> getRecords(QuestionRecord question) {\r\n                if (question.getDomainName().equals(hostname)) {\r\n                    Map<String, Object> map1 = new HashMap<String, Object>();\r\n", "        decoder.decode(buf);\r\n        verify(delegate).readSynStreamFrame(streamId, associatedToStreamId, priority, false, false);\r\n        verify(delegate).readHeaderBlockEnd();\r\n        assertFalse(buf.isReadable());\r\n        buf.release();\r\n", "        decoder.decode(buf);\r\n        verify(delegate).readSynStreamFrame(streamId, associatedToStreamId, priority, false, false);\r\n        verify(delegate).readHeaderBlockEnd();\r\n        assertFalse(buf.isReadable());\r\n        buf.release();\r\n", "        this.additionals = checkNotNull(additionals, \"additionals\");\r\n        this.promise = checkNotNull(promise, \"promise\");\r\n        recursionDesired = parent.isRecursionDesired();\r\n        id = parent.queryContextManager.add(this);\r\n\r\n", "\r\nfinal class DnsQueryContextManager {\r\n\r\n    /**\r\n     * A map whose key is the DNS server address and value is the map of the DNS query ID and its corresponding\r\n", "            }).await();\r\n            promise.sync();\r\n        } finally {\r\n            resolverGroup.close();\r\n            group.shutdownGracefully();\r\n", "    }\r\n\r\n    @Override\r\n    public BinaryMemcacheResponse retain(int increment) {\r\n        super.retain(increment);\r\n", "        TestDnsServer.MapRecordStoreA store = new TestDnsServer.MapRecordStoreA(Collections.<String>emptySet());\r\n        dnsServer = new TestDnsServer(store);\r\n        dnsServer.start();\r\n\r\n        resolver = newResolver().searchDomains(Collections.singletonList(\"foo.com\")).ndots(2).build();\r\n", "                            new TestDnsServer.TestResourceRecord(question.getDomainName(), RecordType.A, map1));\r\n                } else {\r\n                    Set<ResourceRecord> records = new LinkedHashSet<ResourceRecord>(2);\r\n                    Map<String, Object> map = new HashMap<String, Object>();\r\n                    map.put(DnsAttribute.DOMAIN_NAME.toLowerCase(), \"cname.netty.io\");\r\n", "        CombinedChannelDuplexHandler<BinaryMemcacheResponseDecoder, BinaryMemcacheRequestEncoder> {\r\n\r\n    private final boolean failOnMissingResponse;\r\n    private final AtomicLong requestResponseCounter = new AtomicLong();\r\n\r\n", "\r\n    @Override\r\n    public BinaryMemcacheRequest retain() {\r\n        super.retain();\r\n        return this;\r\n", "                    records.add(new TestDnsServer.TestResourceRecord(name, RecordType.A,\r\n                            Collections.<String, Object>singletonMap(DnsAttribute.IP_ADDRESS.toLowerCase(),\r\n                                    \"10.0.0.2\")));\r\n                    return records;\r\n                }\r\n", "        dnsServer2.start();\r\n        DnsNameResolver resolver = null;\r\n        try {\r\n            DnsNameResolverBuilder builder = newResolver()\r\n                    .recursionDesired(true)\r\n", "        encodeDataFrameHeader(buf, streamId2, flags, length);\r\n\r\n        decoder.decode(buf);\r\n        verify(delegate).readDataFrame(streamId1, false, Unpooled.EMPTY_BUFFER);\r\n        verify(delegate).readDataFrame(streamId2, false, Unpooled.EMPTY_BUFFER);\r\n", "        encodeControlFrameHeader(buf, type, flags, length);\r\n        buf.writeInt(streamId);\r\n\r\n        decoder.decode(buf);\r\n        verify(delegate).readSynReplyFrame(streamId, false);\r\n", "            resolver.close();\r\n        }\r\n        group.shutdownGracefully();\r\n    }\r\n\r\n", "                    .nameServerProvider(new SingletonDnsServerAddressStreamProvider(dnsServer2.localAddress()));\r\n\r\n            resolver = builder.build();\r\n            InetAddress address = resolver.resolve(host).syncUninterruptibly().getNow();\r\n            assertEquals(host, address.getHostName());\r\n", "        try {\r\n            testResolve0(resolver, EXCLUSIONS_RESOLVE_A, A);\r\n        } finally {\r\n            resolver.close();\r\n        }\r\n", "        verify(delegate).readSettingsFrame(true);\r\n        verify(delegate).readSettingsEnd();\r\n        assertFalse(buf.isReadable());\r\n        buf.release();\r\n    }\r\n", "            if (startDnsServer1) {\r\n                dnsServer1.start();\r\n                dnsServer1Address = dnsServer1.localAddress();\r\n            } else {\r\n                // Some address where a DNS server will not be running.\r\n", "                                        (InetSocketAddress) ctx.channel().localAddress(),\r\n                                        response));\r\n                            } else {\r\n                                response.release();\r\n                                tcpCtx.tryFailure(\"Received TCP DNS response with unexpected ID\", null, false);\r\n", "        byte priority, boolean last, boolean unidirectional) {\r\n            delegate.readSynStreamFrame(streamId, associatedToStreamId, priority, last, unidirectional);\r\n        }\r\n\r\n        @Override\r\n", "        try {\r\n            testResolve0(resolver, EXCLUSIONS_RESOLVE_AAAA, null);\r\n        } finally {\r\n            resolver.close();\r\n        }\r\n", "            buffers.add(data);\r\n        }\r\n\r\n        @Override\r\n        public void readSynStreamFrame(int streamId, int associatedToStreamId,\r\n", "        public void readSettingsEnd() {\r\n            delegate.readSettingsEnd();\r\n        }\r\n\r\n        @Override\r\n", "        // Schedule a query timeout task if necessary.\r\n        final long queryTimeoutMillis = parent.queryTimeoutMillis();\r\n        if (queryTimeoutMillis > 0) {\r\n            timeoutFuture = parent.ch.eventLoop().schedule(new Runnable() {\r\n                @Override\r\n", "            final DnsQueryContext qCtx = queryContextManager.get(res.sender(), queryId);\r\n            if (qCtx == null) {\r\n                logger.debug(\"Received a DNS response with an unknown ID: UDP [{}: {}]\", ch, queryId);\r\n                res.release();\r\n                return;\r\n", "                    contexts.put(id, qCtx);\r\n                    return id;\r\n                }\r\n\r\n                id = id + 1 & 0xFFFF;\r\n", "\r\n        decoder.decode(buf);\r\n        verify(delegate).readSynReplyFrame(streamId, false);\r\n        verify(delegate).readHeaderBlockEnd();\r\n\r\n", "        }\r\n\r\n        delegate.readSettingsEnd();\r\n        decoder.decode(buf);\r\n        verify(delegate).readSettingsFrame(false);\r\n", "        }\r\n\r\n        delegate.readSettingsEnd();\r\n        decoder.decode(buf);\r\n        verify(delegate).readSettingsFrame(false);\r\n", "        }\r\n\r\n        delegate.readSettingsEnd();\r\n        decoder.decode(buf);\r\n        verify(delegate).readSettingsFrame(false);\r\n", "        if (dnsServerAddressStreamProvider != null) {\r\n            copiedBuilder.nameServerProvider(dnsServerAddressStreamProvider);\r\n        }\r\n\r\n        if (searchDomains != null) {\r\n", "        verify(delegate).readSynStreamFrame(streamId, associatedToStreamId, priority, false, false);\r\n        verify(delegate).readHeaderBlockEnd();\r\n        assertFalse(buf.isReadable());\r\n        buf.release();\r\n    }\r\n", "            }\r\n        } finally {\r\n            dnsServer2.stop();\r\n            if (resolver != null) {\r\n                resolver.close();\r\n", "                           \"nameserver 127.0.0.2\\n\" +\r\n                           \"nameserver 127.0.0.3\\n\");\r\n        File f2 = buildFile(\"domain squarecorp.local\\n\" +\r\n                            \"nameserver 127.0.0.4\\n\" +\r\n                            \"nameserver 127.0.0.5\\n\");\r\n", "        TestDnsServer.MapRecordStoreA store = new TestDnsServer.MapRecordStoreA(domains);\r\n        dnsServer = new TestDnsServer(store);\r\n        dnsServer.start();\r\n\r\n        resolver = newResolver().searchDomains(Collections.singletonList(\"foo.com\")).ndots(2).build();\r\n", "import java.util.concurrent.atomic.AtomicReference;\r\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\r\n\r\nimport static java.util.Collections.singletonList;\r\n\r\n", "    private final RecordStore store;\r\n\r\n    TestDnsServer(Set<String> domains) {\r\n        this(new TestRecordStore(domains));\r\n    }\r\n", "                    if (f.addressType().isInstance(e.address())) {\r\n                        trySuccess(promise, e.address());\r\n                        return true;\r\n                    }\r\n                }\r\n", "                        return null;\r\n                    }\r\n                }).build();\r\n\r\n        final List<DnsRecord> records = resolver.resolveAll(new DefaultDnsQuestion(\"foo.com.\", A))\r\n", "                    new SingletonDnsServerAddressStreamProvider(dnsServer.localAddress())));\r\n        }\r\n\r\n        return builder;\r\n    }\r\n", "        buf.writeInt(streamId);\r\n        buf.writeInt(deltaWindowSize);\r\n\r\n        decoder.decode(buf);\r\n        verify(delegate).readWindowUpdateFrame(streamId, deltaWindowSize);\r\n", "        } finally {\r\n            if (resolver != null) {\r\n                resolver.close();\r\n            }\r\n            dnsServer1.stop();\r\n", "        final DnsQueryContext qCtx;\r\n        if (contexts != null) {\r\n            synchronized (contexts) {\r\n                qCtx = contexts.get(id);\r\n            }\r\n", "            return map.get(nameServerAddr);\r\n        }\r\n    }\r\n\r\n    private IntObjectMap<DnsQueryContext> getOrCreateContextMap(InetSocketAddress nameServerAddr) {\r\n", "        delegate.close();\r\n    }\r\n\r\n    @Override\r\n    public Promise<T> resolve(String inetHost, Promise<T> promise) {\r\n", "            this(domains, 1);\r\n        }\r\n\r\n        public String getAddress(String domain) {\r\n            return domainMap.get(domain).get(0);\r\n", "                    .ndots(1);\r\n\r\n            builder.nameServerProvider(new SequentialDnsServerAddressStreamProvider(dnsServer1.localAddress(),\r\n                    dnsServer2.localAddress()));\r\n            resolver = builder.build();\r\n", "                dnsServer1Address = new InetSocketAddress(\"127.0.0.1\", 22);\r\n            }\r\n            dnsServer2.start();\r\n\r\n            TestRecursiveCacheDnsQueryLifecycleObserverFactory lifecycleObserverFactory =\r\n", "    public void timeoutOptionIsParsedIfPresent() throws IOException {\r\n        File f = buildFile(\"search localdomain\\n\" +\r\n            \"nameserver 127.0.0.11\\n\" +\r\n            \"options timeout:0\\n\");\r\n        assertEquals(0, parseEtcResolverOptions(f).timeout());\r\n", "        } finally {\r\n            dnsServer2.stop();\r\n            if (resolver != null) {\r\n                resolver.close();\r\n            }\r\n", "        } finally {\r\n            dnsServer2.stop();\r\n            if (resolver != null) {\r\n                resolver.close();\r\n            }\r\n", "        } finally {\r\n            dnsServer2.stop();\r\n            if (resolver != null) {\r\n                resolver.close();\r\n            }\r\n", "\r\n        if (dnsServerAddressStreamProvider == null) {\r\n            builder.nameServerProvider(new SingletonDnsServerAddressStreamProvider(dnsServer.localAddress()));\r\n        } else {\r\n            builder.nameServerProvider(new MultiDnsServerAddressStreamProvider(dnsServerAddressStreamProvider,\r\n", "\r\n    @Override\r\n    public BinaryMemcacheResponse retain() {\r\n        super.retain();\r\n        return this;\r\n", "\r\n            resolver = builder.build();\r\n            // Add a CNAME loop into the cache\r\n            String name = \"somehost.netty.io.\";\r\n            String name2 = \"cname.netty.io.\";\r\n", "        TestDnsServer.MapRecordStoreA store = new TestDnsServer.MapRecordStoreA(domains, 2);\r\n        dnsServer = new TestDnsServer(store);\r\n        dnsServer.start();\r\n\r\n        resolver = newResolver().searchDomains(Collections.singletonList(\"foo.com\")).ndots(2).build();\r\n", "        buf.writeInt(streamId);\r\n        buf.writeInt(associatedToStreamId);\r\n        buf.writeByte(priority << 5);\r\n        buf.writeByte(0);\r\n\r\n", "        buf.writeInt(streamId);\r\n        buf.writeInt(associatedToStreamId);\r\n        buf.writeByte(priority << 5);\r\n        buf.writeByte(0);\r\n\r\n", "                    Set<ResourceRecord> records = new HashSet<ResourceRecord>();\r\n                    records.add(new TestDnsServer.TestResourceRecord(question.getDomainName(), RecordType.TXT, map1));\r\n                    records.add(new TestDnsServer.TestResourceRecord(question.getDomainName(), RecordType.TXT, map2));\r\n                    return records;\r\n                }\r\n", "        });\r\n        dnsServer2.start();\r\n        DnsNameResolver resolver = null;\r\n        try {\r\n            DnsNameResolverBuilder builder = newResolver()\r\n", "        });\r\n        dnsServer2.start();\r\n        DnsNameResolver resolver = null;\r\n        try {\r\n            DnsNameResolverBuilder builder = newResolver()\r\n", "        });\r\n        dnsServer2.start();\r\n        DnsNameResolver resolver = null;\r\n        try {\r\n            DnsNameResolverBuilder builder = newResolver()\r\n", "                    records.add(new TestDnsServer.TestResourceRecord(\r\n                            question.getDomainName(), RecordType.CNAME, map));\r\n\r\n                    Map<String, Object> map1 = new HashMap<String, Object>();\r\n                    map1.put(DnsAttribute.IP_ADDRESS.toLowerCase(), \"10.0.0.2\");\r\n", "                        @Override\r\n                        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\r\n                            if (tcpCtx.tryFailure(\"TCP fallback error\", cause, false) && logger.isDebugEnabled()) {\r\n                                logger.debug(\"{} Error during processing response: TCP [{}: {}]\",\r\n                                        ctx.channel(), queryId,\r\n", "                                return DnsServerAddresses.singleton(dnsServer3.localAddress()).stream();\r\n                            }\r\n                            return DnsServerAddresses.singleton(dnsServer2.localAddress()).stream();\r\n                        }\r\n                    })\r\n", "            public Set<ResourceRecord> getRecords(QuestionRecord question) {\r\n                Set<ResourceRecord> records = new LinkedHashSet<ResourceRecord>(4);\r\n\r\n                records.add(new TestDnsServer.TestResourceRecord(\"x.\" + question.getDomainName(),\r\n                        RecordType.A, Collections.<String, Object>singletonMap(\r\n", "        buf.writeInt(streamId | 0x80000000); // should ignore reserved bit\r\n        buf.writeInt(associatedToStreamId | 0x80000000); // should ignore reserved bit\r\n        buf.writeByte(priority << 5 | 0x1F); // should ignore reserved bits\r\n        buf.writeByte(0xFF); // should ignore reserved bits\r\n\r\n", "        delegate.readSettingsEnd();\r\n        decoder.decode(buf);\r\n        verify(delegate).readSettingsFrame(false);\r\n        verify(delegate, times(numSettings)).readSetting(id, value, true, false);\r\n        assertFalse(buf.isReadable());\r\n", "        buf.writeInt(streamId);\r\n\r\n        decoder.decode(buf);\r\n        verify(delegate).readSynReplyFrame(streamId, false);\r\n        verify(delegate).readHeaderBlockEnd();\r\n", "\r\n        @Override\r\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\r\n            final DatagramDnsResponse res = (DatagramDnsResponse) msg;\r\n            final int queryId = res.id();\r\n", "                resolver.close();\r\n            }\r\n            dnsServer1.stop();\r\n            dnsServer2.stop();\r\n        }\r\n", "                return null;\r\n            }\r\n        };\r\n        DnsNameResolverBuilder builder = newResolver();\r\n        builder.queryTimeoutMillis(100)\r\n", "public class BinaryMemcacheRequestDecoder\r\n    extends AbstractBinaryMemcacheDecoder<BinaryMemcacheRequest> {\r\n\r\n    public BinaryMemcacheRequestDecoder() {\r\n        this(DEFAULT_MAX_CHUNK_SIZE);\r\n", "            public Set<ResourceRecord> getRecords(QuestionRecord question) {\r\n                if (question.getDomainName().equals(\"cname.netty.io\")) {\r\n                    Map<String, Object> map1 = new HashMap<String, Object>();\r\n                    map1.put(DnsAttribute.IP_ADDRESS.toLowerCase(), \"10.0.0.99\");\r\n                    return Collections.<ResourceRecord>singleton(\r\n", "        public void readRstStreamFrame(int streamId, int statusCode) {\r\n            delegate.readRstStreamFrame(streamId, statusCode);\r\n        }\r\n\r\n        @Override\r\n", "public class BinaryMemcacheResponseDecoder\r\n    extends AbstractBinaryMemcacheDecoder<BinaryMemcacheResponse> {\r\n\r\n    public BinaryMemcacheResponseDecoder() {\r\n        this(DEFAULT_MAX_CHUNK_SIZE);\r\n", "        public void readHeaderBlock(ByteBuf headerBlock) {\r\n            delegate.readHeaderBlock(headerBlock);\r\n            buffers.add(headerBlock);\r\n        }\r\n\r\n", "\r\n        if (eventLoop != null) {\r\n            copiedBuilder.eventLoop(eventLoop);\r\n        }\r\n\r\n", "        };\r\n        dnsServer2.start();\r\n        DnsServerAddressStreamProvider nameServerProvider =\r\n                new SequentialDnsServerAddressStreamProvider(dnsServer1.localAddress(),\r\n                                                             dnsServer2.localAddress());\r\n", "                return records;\r\n            }\r\n        });\r\n        dnsServer2.start();\r\n        DnsNameResolver resolver = null;\r\n", "                    records.add(new TestDnsServer.TestResourceRecord(\r\n                            question.getDomainName(), RecordType.A, map1));\r\n                    return records;\r\n                }\r\n            }\r\n", "        try {\r\n            testResolve0(resolver, EXCLUSIONS_RESOLVE_A, null);\r\n        } finally {\r\n            resolver.close();\r\n        }\r\n", "\r\n        private final Map<String, List<String>> domainMap;\r\n\r\n        MapRecordStoreA(Set<String> domains, int length) {\r\n            domainMap = new HashMap<String, List<String>>(domains.size());\r\n", "                ch.pipeline().addLast(DATAGRAM_ENCODER, DATAGRAM_DECODER, responseHandler);\r\n            }\r\n        });\r\n\r\n        channelFuture = responseHandler.channelActivePromise;\r\n", "        domains.add(\"host3.bar.com\");\r\n        domains.add(\"host3.foo.com\");\r\n\r\n        TestDnsServer.MapRecordStoreA store = new TestDnsServer.MapRecordStoreA(domains);\r\n        dnsServer = new TestDnsServer(store);\r\n", "        final ScheduledFuture<?> timeoutFuture = this.timeoutFuture;\r\n        if (timeoutFuture != null) {\r\n            this.timeoutFuture = null;\r\n            timeoutFuture.cancel(false);\r\n        }\r\n", "                public void run() {\r\n                    if (promise.isDone()) {\r\n                        // Received a response before the query times out.\r\n                        return;\r\n                    }\r\n", "        public void readWindowUpdateFrame(int streamId, int deltaWindowSize) {\r\n            delegate.readWindowUpdateFrame(streamId, deltaWindowSize);\r\n        }\r\n\r\n        @Override\r\n", "        buf.writeByte(0);\r\n\r\n        decoder.decode(buf);\r\n        verify(delegate).readSynStreamFrame(streamId, associatedToStreamId, priority, false, false);\r\n        verify(delegate).readHeaderBlockEnd();\r\n", "        buf.writeByte(priority << 5);\r\n        buf.writeByte(0);\r\n\r\n        decoder.decode(buf);\r\n        verify(delegate).readSynStreamFrame(streamId, associatedToStreamId, priority, true, false);\r\n", "        request.release();\r\n\r\n        MemcacheContent content1 = channel.readInbound();\r\n        MemcacheContent content2 = channel.readInbound();\r\n\r\n", "                return null;\r\n            }\r\n        });\r\n        dnsServer2.start(true);\r\n        DnsNameResolver resolver = null;\r\n", "            dnsServer2.stop();\r\n            if (resolver != null) {\r\n                resolver.close();\r\n            }\r\n        }\r\n", "            if (result != null) {\r\n                trySuccess(promise, result);\r\n                return true;\r\n            }\r\n            return false;\r\n", "            if (tcpFallback) {\r\n                // If we are configured to use TCP as a fallback also bind a TCP socket\r\n                serverSocket = new ServerSocket(dnsServer2.localAddress().getPort());\r\n                serverSocket.setReuseAddress(true);\r\n\r\n", "            resolver = builder.build();\r\n            resolver.resolveAll(\"somehost.netty.io\").syncUninterruptibly().getNow();\r\n        } finally {\r\n            dnsServer2.stop();\r\n            if (resolver != null) {\r\n", "        domains.add(\"host2.sub\");\r\n\r\n        TestDnsServer.MapRecordStoreA store = new TestDnsServer.MapRecordStoreA(domains);\r\n        dnsServer = new TestDnsServer(store);\r\n        dnsServer.start();\r\n", "                domainMap.put(domain, addresses);\r\n            }\r\n        }\r\n\r\n        MapRecordStoreA(Set<String> domains) {\r\n", "            if (resolver != null) {\r\n                resolver.close();\r\n            }\r\n        }\r\n    }\r\n", "            if (resolver != null) {\r\n                resolver.close();\r\n            }\r\n        }\r\n    }\r\n", "            if (resolver != null) {\r\n                resolver.close();\r\n            }\r\n        }\r\n    }\r\n", "\r\n                    tryFailure(\"query via \" + protocol() + \" timed out after \" +\r\n                            queryTimeoutMillis + \" milliseconds\", null, true);\r\n                }\r\n            }, queryTimeoutMillis, TimeUnit.MILLISECONDS);\r\n", "        public void readSetting(int id, int value, boolean persistValue, boolean persisted) {\r\n            delegate.readSetting(id, value, persistValue, persisted);\r\n        }\r\n\r\n        @Override\r\n", "        domains.add(\"host1.foo.com\");\r\n        domains.add(\"host2.foo.com\");\r\n\r\n        TestDnsServer.MapRecordStoreA store = new TestDnsServer.MapRecordStoreA(domains);\r\n        dnsServer = new TestDnsServer(store);\r\n"]], "uris": null, "data": null, "metadatas": [[{"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsResolveContextTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/InflightNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/AuthoritativeDnsServerCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCnameCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverOptions.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheClientCodec.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/package-info.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverOptions.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCnameCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsServerAddressesTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCnameCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsAddressResolverGroupTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/PreferredAddressTypeComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/NameServerComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsResolveContextTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverClientSubnetTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UniSequentialDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/AuthoritativeDnsServerCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/SequentialDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsCnameCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStreamProviders.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/RotationalDnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/SingletonDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NameServerComparator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/RoundRobinDnsAddressResolverGroup.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverTimeoutException.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/MultiDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DatagramDnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/LoggingDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsQueryLifecycleObserverFactory.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/TcpDnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsRecordResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContextManager.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolverGroup.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverException.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverOptions.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCacheEntry.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/LoggingDnsQueryLifeCycleObserverFactory.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/SingletonDnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStream.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/SequentialDnsServerAddressStream.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/AuthoritativeDnsServerCacheAdapter.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryLifecycleObserverFactory.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/InflightNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/BiDnsQueryLifecycleObserverFactory.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopAuthoritativeDnsServerCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/ShuffledDnsServerAddressStream.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DirContextUtils.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/package-info.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCnameCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/BiDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCnameCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/PreferredAddressTypeComparator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheEncoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequestTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/FullMemcacheMessageRequestTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponseTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessageTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/FullMemcacheMessageResponseTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/FullMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObject.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheObject.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequestDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/FullBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheClientCodec.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequestEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/FullBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/package-info.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheOpcodes.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheServerCodec.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseStatus.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/LastMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/package-info.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectAggregator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultLastMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/SequentialDnsServerAddressStream.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStream.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverOptions.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsCnameCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheOpcodes.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/FullMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopAuthoritativeDnsServerCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/ShuffledDnsServerAddressStream.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCnameCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/AuthoritativeDnsServerCacheAdapter.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequestDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/AuthoritativeDnsServerCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverException.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NameServerComparator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsCnameCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/NameServerComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/RoundRobinDnsAddressResolverGroup.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectAggregator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCnameCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/AuthoritativeDnsServerCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/AuthoritativeDnsServerCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheEncoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheEncoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/FullMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObject.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheObject.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequestDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/FullBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheClientCodec.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequestEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/FullBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/package-info.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheOpcodes.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheServerCodec.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseStatus.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/LastMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/package-info.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectAggregator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultLastMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStream.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverClientSubnetTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCnameCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsServerAddressStreamProvidersTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolverGroup.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsServerAddressesTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolverGroup.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/package-info.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStreamProviders.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopAuthoritativeDnsServerCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UniSequentialDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/SequentialDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStreamProviders.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/SingletonDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverTimeoutException.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/MultiDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/LoggingDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsQueryLifecycleObserverFactory.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCacheEntry.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryLifecycleObserverFactory.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/BiDnsQueryLifecycleObserverFactory.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/BiDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStreamProviders.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/RotationalDnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContextManager.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverException.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/SingletonDnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStream.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/SequentialDnsServerAddressStream.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/ShuffledDnsServerAddressStream.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/RoundRobinDnsAddressResolverGroup.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/LoggingDnsQueryLifeCycleObserverFactory.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/PreferredAddressTypeComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DatagramDnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/TcpDnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/PreferredAddressTypeComparator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequestTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponseTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverClientSubnetTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/RoundRobinDnsAddressResolverGroup.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/InflightNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/FullMemcacheMessageRequestTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessageTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/FullMemcacheMessageResponseTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NameServerComparator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCnameCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequestTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCnameCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCnameCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCnameCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/NameServerComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/AuthoritativeDnsServerCacheAdapter.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCnameCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/NameServerComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/AuthoritativeDnsServerCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsCnameCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NameServerComparator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsRecordResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/AuthoritativeDnsServerCacheAdapter.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopAuthoritativeDnsServerCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DirContextUtils.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCnameCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCnameCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/PreferredAddressTypeComparator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsAddressResolverGroupTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsResolveContextTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/SequentialDnsServerAddressStream.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCnameCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCnameCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessageTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/FullMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheEncoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequestTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponseTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContextManager.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessageTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsServerAddressesTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverOptions.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCnameCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsAddressResolverGroupTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsResolveContextTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsServerAddressStreamProvidersTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverOptions.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/LoggingDnsQueryLifeCycleObserverFactory.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponseTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/ShuffledDnsServerAddressStream.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCnameCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopAuthoritativeDnsServerCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCnameCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/RotationalDnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/PreferredAddressTypeComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequestTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsCnameCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/FullMemcacheMessageResponseTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCnameCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStreamProviders.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverOptions.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverException.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/BiDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/LoggingDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/SingletonDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCnameCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/AuthoritativeDnsServerCacheAdapter.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCnameCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessageTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/NameServerComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/NameServerComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessageTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/LastMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessageTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectAggregator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NameServerComparator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/PreferredAddressTypeComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/MultiDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequestTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCacheEntry.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverOptions.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/FullMemcacheMessageRequestTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/FullMemcacheMessageResponseTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCnameCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectAggregator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheOpcodes.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/LoggingDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/FullMemcacheMessageResponseTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DirContextUtils.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/AuthoritativeDnsServerCacheAdapter.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverOptions.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverClientSubnetTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/PreferredAddressTypeComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/ShuffledDnsServerAddressStream.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStream.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/NameServerComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/InflightNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverClientSubnetTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponseTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseStatus.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolverGroup.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStreamProviders.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCnameCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/NameServerComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCacheEntry.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequestTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponseTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/SequentialDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessageTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DirContextUtils.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCacheEntry.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/package-info.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/NameServerComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsAddressResolverGroupTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsServerAddressesTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/SequentialDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsAddressResolverGroupTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheEncoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/NameServerComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectAggregator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/FullBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/RoundRobinDnsAddressResolverGroup.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/AuthoritativeDnsServerCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopAuthoritativeDnsServerCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/FullMemcacheMessageRequestTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultLastMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheEncoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsResolveContextTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContextManager.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/PreferredAddressTypeComparator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NameServerComparator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheClientCodec.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/NameServerComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryLifecycleObserverFactory.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/TcpDnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheOpcodes.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheClientCodec.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/TcpDnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/LastMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsCnameCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsResolveContextTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/SingletonDnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStream.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/RoundRobinDnsAddressResolverGroup.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverClientSubnetTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCnameCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/AuthoritativeDnsServerCacheAdapter.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverException.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/RoundRobinDnsAddressResolverGroup.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolverGroup.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UniSequentialDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContextManager.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/NameServerComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/NameServerComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverOptions.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DirContextUtils.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequestEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolverGroup.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectAggregator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/SequentialDnsServerAddressStream.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheEncoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolverGroup.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverTimeoutException.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectAggregator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverTimeoutException.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/LoggingDnsQueryLifeCycleObserverFactory.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheClientCodec.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequestDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/RotationalDnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/SequentialDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/BiDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopAuthoritativeDnsServerCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/SequentialDnsServerAddressStream.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/BiDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/SequentialDnsServerAddressStream.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCnameCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/NameServerComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/FullMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DatagramDnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCnameCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCnameCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/LoggingDnsQueryLifeCycleObserverFactory.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStream.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObject.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/SequentialDnsServerAddressStream.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/SequentialDnsServerAddressStream.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCnameCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/SequentialDnsServerAddressStream.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/FullBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCnameCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStreamProviders.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStreamProviders.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolverGroup.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponseTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessageTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/AuthoritativeDnsServerCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessageTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/AuthoritativeDnsServerCacheAdapter.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCnameCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCnameCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsResolveContextTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequestTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponseTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessageTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/MultiDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCnameCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/AuthoritativeDnsServerCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/ShuffledDnsServerAddressStream.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsRecordResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/AuthoritativeDnsServerCacheAdapter.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsServerAddressesTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/RoundRobinDnsAddressResolverGroup.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/InflightNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverException.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverTimeoutException.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/SequentialDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessageTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/NameServerComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/LoggingDnsQueryLifeCycleObserverFactory.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsRecordResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DatagramDnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContextManager.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DirContextUtils.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsServerAddressesTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsQueryLifecycleObserverFactory.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/LastMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsAddressResolverGroupTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/NameServerComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/ShuffledDnsServerAddressStream.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/FullMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStreamProviders.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessageTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequestTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/PreferredAddressTypeComparator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/BiDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DatagramDnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStreamProviders.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCnameCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheEncoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContextManager.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/FullBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/LoggingDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/BiDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverOptions.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/LoggingDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/AuthoritativeDnsServerCacheAdapter.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/InflightNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheOpcodes.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/PreferredAddressTypeComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/PreferredAddressTypeComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/PreferredAddressTypeComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContextManager.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/FullBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NameServerComparator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/NameServerComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectAggregator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/NameServerComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheEncoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/LoggingDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsRecordResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/PreferredAddressTypeComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContextManager.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsAddressResolverGroupTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/LastMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStreamProviders.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsServerAddressesTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/FullMemcacheMessageResponseTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/LoggingDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheClientCodec.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsServerAddressStreamProvidersTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCnameCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/FullMemcacheMessageRequestTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NameServerComparator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/InflightNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheEncoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/LastMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCnameCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsServerAddressesTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/NameServerComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/LastMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCacheEntry.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsServerAddressesTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/LoggingDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/PreferredAddressTypeComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/BiDnsQueryLifecycleObserverFactory.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/ShuffledDnsServerAddressStream.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/InflightNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheOpcodes.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DirContextUtils.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsResolveContextTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/PreferredAddressTypeComparator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DirContextUtils.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObject.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/FullMemcacheMessageRequestTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/LoggingDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStreamProviders.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/FullBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/FullBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsServerAddressesTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultLastMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolverGroup.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectAggregator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/LoggingDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/package-info.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsServerAddressesTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/AuthoritativeDnsServerCacheAdapter.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/FullMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCnameCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/NameServerComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/LoggingDnsQueryLifeCycleObserverFactory.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/PreferredAddressTypeComparator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/NameServerComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsResolveContextTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverClientSubnetTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/LastMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/FullMemcacheMessageResponseTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheOpcodes.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/LoggingDnsQueryLifeCycleObserverFactory.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultLastMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DirContextUtils.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsRecordResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/InflightNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/SingletonDnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/BiDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/BiDnsQueryLifecycleObserverFactory.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverException.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCnameCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolverGroup.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/LastMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultLastMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/SequentialDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultLastMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectAggregator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseStatus.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/NameServerComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/InflightNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheEncoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/InflightNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/InflightNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsAddressResolverGroupTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsServerAddressesTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCnameCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/MultiDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/AuthoritativeDnsServerCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverException.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultLastMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheClientCodec.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/PreferredAddressTypeComparator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsAddressResolverGroupTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCnameCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/ShuffledDnsServerAddressStream.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DatagramDnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/TcpDnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/NameServerComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheEncoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/FullMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolverGroup.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultLastMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/InflightNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsRecordResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStreamProviders.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/RoundRobinDnsAddressResolverGroup.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCnameCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolverGroup.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/NameServerComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/BiDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStreamProviders.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContextManager.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverClientSubnetTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheEncoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/FullMemcacheMessageRequestTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/FullMemcacheMessageResponseTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequestDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsServerAddressesTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCnameCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsAddressResolverGroupTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/PreferredAddressTypeComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/NameServerComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsResolveContextTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverClientSubnetTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsServerAddressStreamProvidersTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UniSequentialDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/AuthoritativeDnsServerCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/SequentialDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsCnameCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStreamProviders.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/RotationalDnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/SingletonDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NameServerComparator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/RoundRobinDnsAddressResolverGroup.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverTimeoutException.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/MultiDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DatagramDnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/LoggingDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsQueryLifecycleObserverFactory.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/TcpDnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsRecordResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContextManager.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolverGroup.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverException.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverOptions.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCacheEntry.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/LoggingDnsQueryLifeCycleObserverFactory.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/SingletonDnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStream.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/SequentialDnsServerAddressStream.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/AuthoritativeDnsServerCacheAdapter.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryLifecycleObserverFactory.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/InflightNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/BiDnsQueryLifecycleObserverFactory.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopAuthoritativeDnsServerCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/ShuffledDnsServerAddressStream.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DirContextUtils.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/package-info.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCnameCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/BiDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCnameCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/PreferredAddressTypeComparator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheEncoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequestTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/FullMemcacheMessageRequestTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponseTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessageTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/FullMemcacheMessageResponseTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/FullMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObject.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheObject.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequestDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/FullBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheClientCodec.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequestEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/FullBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/package-info.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheOpcodes.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheServerCodec.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseStatus.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/LastMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/package-info.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectAggregator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultLastMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/LoggingDnsQueryLifeCycleObserverFactory.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UniSequentialDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/LoggingDnsQueryLifeCycleObserverFactory.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/SequentialDnsServerAddressStream.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/FullMemcacheMessageRequestTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/NameServerComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStreamProviders.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/NameServerComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverException.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/RoundRobinDnsAddressResolverGroup.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsResolveContextTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/MultiDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContextManager.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/LoggingDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheEncoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolverGroup.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheClientCodec.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheOpcodes.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseStatus.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/FullMemcacheMessageResponseTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequestTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolverGroup.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverClientSubnetTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsServerAddressStreamProvidersTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverClientSubnetTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/LoggingDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsAddressResolverGroupTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsServerAddressesTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheEncoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequestEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/ShuffledDnsServerAddressStream.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequestTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/SingletonDnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/LoggingDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/LoggingDnsQueryLifeCycleObserverFactory.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/TcpDnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DirContextUtils.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/BiDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequestTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsQueryLifecycleObserverFactory.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverException.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/AuthoritativeDnsServerCacheAdapter.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/NameServerComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContextManager.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/FullBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheEncoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsServerAddressesTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequestTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsServerAddressesTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/SequentialDnsServerAddressStream.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/LastMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/BiDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequestTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponseTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/LastMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectAggregator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheEncoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/LastMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/InflightNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/ShuffledDnsServerAddressStream.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverOptions.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/ShuffledDnsServerAddressStream.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsServerAddressesTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/RoundRobinDnsAddressResolverGroup.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/SingletonDnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheObject.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/NameServerComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStreamProviders.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/NameServerComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequestEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/FullBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverOptions.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/PreferredAddressTypeComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolverGroup.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultLastMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/RoundRobinDnsAddressResolverGroup.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolverGroup.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/TcpDnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/PreferredAddressTypeComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponseTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolverGroup.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverOptions.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCnameCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverException.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsServerAddressesTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolverGroup.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/BiDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/RotationalDnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheOpcodes.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/AuthoritativeDnsServerCacheAdapter.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DatagramDnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheEncoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/BiDnsQueryLifecycleObserverFactory.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponseTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/FullMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContextManager.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/BiDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/LastMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsServerAddressesTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequestEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/LoggingDnsQueryLifeCycleObserverFactory.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/ShuffledDnsServerAddressStream.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStreamProviders.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/BiDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheClientCodec.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverClientSubnetTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/LoggingDnsQueryLifeCycleObserverFactory.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContextManager.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/BiDnsQueryLifecycleObserverFactory.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheEncoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequestTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsRecordResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContextManager.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/InflightNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsServerAddressesTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCnameCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverException.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/LastMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStreamProviders.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsServerAddressesTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectAggregator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessageTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsRecordResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/InflightNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponseTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessageTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCnameCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObject.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/ShuffledDnsServerAddressStream.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsServerAddressesTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/LastMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheOpcodes.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UniSequentialDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheEncoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/AuthoritativeDnsServerCacheAdapter.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponseTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessageTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/SingletonDnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequestTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/FullBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/AuthoritativeDnsServerCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/InflightNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/LastMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/BiDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsServerAddressesTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolverGroup.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessageTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStreamProviders.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/LastMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCnameCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCnameCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessageTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolverGroup.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheClientCodec.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/InflightNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/TcpDnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessageTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultLastMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/NameServerComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsServerAddressesTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/FullBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/LastMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponseTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryLifecycleObserverFactory.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheEncoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheClientCodec.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheClientCodec.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStreamProviders.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/FullBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultLastMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessageTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheEncoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheEncoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessageTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/SequentialDnsServerAddressStream.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/SingletonDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponseTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/FullMemcacheMessageResponseTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/LoggingDnsQueryLifeCycleObserverFactory.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponseTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseStatus.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/FullMemcacheMessageRequestTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/LoggingDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheEncoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheClientCodec.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCnameCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheClientCodec.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContextManager.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCnameCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/LastMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolverGroup.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/NameServerComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/BiDnsQueryLifecycleObserverFactory.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheServerCodec.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheClientCodec.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/FullMemcacheMessageRequestTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/SingletonDnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/FullBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DatagramDnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheOpcodes.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheEncoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCnameCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/LastMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContextManager.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/InflightNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectAggregator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/InflightNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverOptions.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/LoggingDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverOptions.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheEncoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/InflightNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsRecordResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/PreferredAddressTypeComparator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/BiDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolverGroup.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/InflightNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheEncoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessageTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObject.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/NameServerComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequestDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsServerAddressesTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/MultiDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverException.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NameServerComparator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/BiDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/RotationalDnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsRecordResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolverGroup.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DirContextUtils.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequestDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectAggregator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/SingletonDnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsCnameCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/SingletonDnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequestDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverClientSubnetTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponseTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/BiDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheClientCodec.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/FullBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequestTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheEncoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheEncoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheClientCodec.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStreamProviders.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/RotationalDnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheClientCodec.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCnameCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/FullBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheServerCodec.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseStatus.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsRecordResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/TcpDnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultLastMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheEncoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessageTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/LastMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultLastMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolverGroup.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStreamProviders.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCnameCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultAuthoritativeDnsServerCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/LoggingDnsQueryLifeCycleObserverFactory.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/SingletonDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheClientCodec.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/NameServerComparatorTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsRecordResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/FullMemcacheMessageRequestTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsRecordResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/LastMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequestDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsAddressResolverGroupTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DirContextUtils.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsRecordResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequestTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponseTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContextManager.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCacheTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsRecordResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequestEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/BiDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectAggregator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheEncoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStreamProviders.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStreamProviders.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectEncoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContextManager.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContextManager.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContextManager.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/FullMemcacheMessageResponseTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheClientCodec.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/InflightNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NoopAuthoritativeDnsServerCache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/RotationalDnsServerAddresses.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/BiDnsQueryLifecycleObserver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NameServerComparator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObject.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheServerCodec.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DirContextUtils.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/MultiDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStreamProviders.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/NameServerComparator.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsRecordResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheServerCodec.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStreamProviders.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DirContextUtils.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/LastMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheClientCodec.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStreamProviders.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultMemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheContent.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/MultiDnsServerAddressStreamProvider.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DatagramDnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContextManager.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContextManager.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContextManager.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/InflightNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContextManager.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsAddressResolverGroupTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheClientCodec.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheRequest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContextManager.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/Cache.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContextManager.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContextManager.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/InflightNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheResponse.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequestDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseDecoder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/TestDnsServer.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java", "type": "snippet"}, {"language": "Java", "repo": "netty/netty/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java", "type": "snippet"}]], "distances": [[1.0812897682189941, 1.1865390539169312, 1.2233211994171143, 1.3514609336853027, 1.3592873811721802, 1.3676941394805908, 1.4116415977478027, 1.4394938945770264, 1.4458258152008057, 1.4675906896591187, 1.4685968160629272, 1.5047099590301514, 1.5100030899047852, 1.5131210088729858, 1.5191638469696045, 1.520798683166504, 1.537754774093628, 1.5412368774414062, 1.5426563024520874, 1.5429784059524536, 1.5442918539047241, 1.5583114624023438, 1.5584025382995605, 1.567014217376709, 1.5766289234161377, 1.579486608505249, 1.580831527709961, 1.5984108448028564, 1.6096620559692383, 1.610314130783081, 1.617293357849121, 1.6237434148788452, 1.6242859363555908, 1.624940276145935, 1.6284959316253662, 1.6405246257781982, 1.6410880088806152, 1.6418172121047974, 1.6421490907669067, 1.6472935676574707, 1.6551822423934937, 1.6553138494491577, 1.6570520401000977, 1.6589643955230713, 1.6635198593139648, 1.664713978767395, 1.667471170425415, 1.6684800386428833, 1.6691970825195312, 1.6696728467941284, 1.6698027849197388, 1.6702522039413452, 1.6708852052688599, 1.6709394454956055, 1.674559473991394, 1.6748205423355103, 1.6748205423355103, 1.6879180669784546, 1.6911036968231201, 1.6920918226242065, 1.6922104358673096, 1.6927824020385742, 1.6942377090454102, 1.6942377090454102, 1.6946172714233398, 1.6985032558441162, 1.6985687017440796, 1.6994373798370361, 1.7015786170959473, 1.702877402305603, 1.7053463459014893, 1.7074624300003052, 1.7082912921905518, 1.7104761600494385, 1.7133561372756958, 1.7135119438171387, 1.7169125080108643, 1.7173349857330322, 1.7173885107040405, 1.7193493843078613, 1.7196240425109863, 1.7205190658569336, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.7228057384490967, 1.723381519317627, 1.723549723625183, 1.7256338596343994, 1.7256600856781006, 1.7261950969696045, 1.726565957069397, 1.7277370691299438, 1.7287893295288086, 1.7319660186767578, 1.7322590351104736, 1.7322590351104736, 1.7328717708587646, 1.7331583499908447, 1.7339684963226318, 1.7346956729888916, 1.735047698020935, 1.736894965171814, 1.7382087707519531, 1.7385025024414062, 1.7408511638641357, 1.7410448789596558, 1.7410553693771362, 1.7410553693771362, 1.7411631345748901, 1.7424330711364746, 1.743535041809082, 1.7473396062850952, 1.7475041151046753, 1.748755693435669, 1.7488384246826172, 1.7489874362945557, 1.7493181228637695, 1.749638557434082, 1.7517063617706299, 1.753417730331421, 1.7547215223312378, 1.755263090133667, 1.7553998231887817, 1.7560367584228516, 1.7577208280563354, 1.7592246532440186, 1.75971257686615, 1.760481357574463, 1.7607593536376953, 1.7644789218902588, 1.7658941745758057, 1.7669041156768799, 1.7677398920059204, 1.7709574699401855, 1.7715420722961426, 1.7732295989990234, 1.7733979225158691, 1.7740459442138672, 1.7759044170379639, 1.7770684957504272, 1.7773818969726562, 1.777550220489502, 1.7776371240615845, 1.7781407833099365, 1.7783020734786987, 1.7784450054168701, 1.7826496362686157, 1.783088207244873, 1.7834596633911133, 1.7835973501205444, 1.7844005823135376, 1.7859559059143066, 1.786013126373291, 1.7867074012756348, 1.7874531745910645, 1.7875577211380005, 1.7883570194244385, 1.7887705564498901, 1.7888050079345703, 1.7890069484710693, 1.7892645597457886, 1.7898744344711304, 1.7900886535644531, 1.7902764081954956, 1.7904467582702637, 1.7907499074935913, 1.7908620834350586, 1.790949821472168, 1.7909785509109497, 1.7911127805709839, 1.791317343711853, 1.7922601699829102, 1.7924983501434326, 1.7926621437072754, 1.7933827638626099, 1.794365406036377, 1.7952845096588135, 1.7957698106765747, 1.7960026264190674, 1.7965283393859863, 1.796679139137268, 1.7969952821731567, 1.7972904443740845, 1.7972904443740845, 1.7972904443740845, 1.7972904443740845, 1.7972904443740845, 1.7972904443740845, 1.7972904443740845, 1.7972904443740845, 1.7972904443740845, 1.7972904443740845, 1.7972904443740845, 1.7972904443740845, 1.7972904443740845, 1.7972904443740845, 1.7972904443740845, 1.7972904443740845, 1.7972904443740845, 1.7972904443740845, 1.7972904443740845, 1.7972904443740845, 1.7972904443740845, 1.7972904443740845, 1.7972904443740845, 1.7972904443740845, 1.7972904443740845, 1.7972904443740845, 1.7972904443740845, 1.7972904443740845, 1.7972904443740845, 1.7972904443740845, 1.7972904443740845, 1.7972904443740845, 1.7972904443740845, 1.7972904443740845, 1.7972904443740845, 1.7972904443740845, 1.7972904443740845, 1.7974607944488525, 1.797492265701294, 1.7978607416152954, 1.7984507083892822, 1.7988964319229126, 1.7992130517959595, 1.7994062900543213, 1.7996989488601685, 1.7996989488601685, 1.8001883029937744, 1.8006536960601807, 1.8020970821380615, 1.8024286031723022, 1.8025059700012207, 1.8025062084197998, 1.8027557134628296, 1.8043749332427979, 1.8046598434448242, 1.8047971725463867, 1.8048700094223022, 1.8055994510650635, 1.8058475255966187, 1.8059269189834595, 1.8059269189834595, 1.8059269189834595, 1.8059269189834595, 1.8059269189834595, 1.8059269189834595, 1.8059269189834595, 1.8059269189834595, 1.8059269189834595, 1.8059548139572144, 1.8062191009521484, 1.8065364360809326, 1.8068230152130127, 1.8070605993270874, 1.8073844909667969, 1.8079402446746826, 1.808000087738037, 1.8087539672851562, 1.8087984323501587, 1.8089829683303833, 1.8090360164642334, 1.8090360164642334, 1.8091529607772827, 1.809468150138855, 1.8095145225524902, 1.8096767663955688, 1.8096767663955688, 1.8096767663955688, 1.8096767663955688, 1.8096767663955688, 1.8096767663955688, 1.8096767663955688, 1.8096767663955688, 1.8096767663955688, 1.8096767663955688, 1.8096767663955688, 1.8096767663955688, 1.8096767663955688, 1.8096767663955688, 1.8096767663955688, 1.8096767663955688, 1.8096767663955688, 1.8096767663955688, 1.8101009130477905, 1.8105063438415527, 1.8106939792633057, 1.8111138343811035, 1.8116600513458252, 1.8120172023773193, 1.8123948574066162, 1.8128219842910767, 1.8130329847335815, 1.8130329847335815, 1.8130329847335815, 1.8130329847335815, 1.8130329847335815, 1.8130329847335815, 1.8130329847335815, 1.8130329847335815, 1.8130329847335815, 1.8130329847335815, 1.813389539718628, 1.8134896755218506, 1.8136757612228394, 1.8140841722488403, 1.8143091201782227, 1.815234661102295, 1.8152797222137451, 1.8153156042099, 1.8154985904693604, 1.8158701658248901, 1.8158701658248901, 1.8158701658248901, 1.8158701658248901, 1.8158701658248901, 1.8158701658248901, 1.8160425424575806, 1.8161861896514893, 1.817121982574463, 1.8171367645263672, 1.8174151182174683, 1.8174151182174683, 1.8174151182174683, 1.8174151182174683, 1.8174151182174683, 1.8174151182174683, 1.8174151182174683, 1.8174151182174683, 1.8174151182174683, 1.8174151182174683, 1.8174151182174683, 1.8176450729370117, 1.817704200744629, 1.8190007209777832, 1.819434642791748, 1.8195478916168213, 1.8200420141220093, 1.8201178312301636, 1.8201178312301636, 1.8201178312301636, 1.820210337638855, 1.820499300956726, 1.8205878734588623, 1.8206803798675537, 1.8206839561462402, 1.8211491107940674, 1.821184754371643, 1.821287751197815, 1.821366786956787, 1.8222033977508545, 1.8223150968551636, 1.8227403163909912, 1.8228609561920166, 1.8233076333999634, 1.8239216804504395, 1.8241937160491943, 1.8245512247085571, 1.8248363733291626, 1.8250536918640137, 1.8250536918640137, 1.8252310752868652, 1.8255369663238525, 1.8259598016738892, 1.8260208368301392, 1.8260208368301392, 1.8260208368301392, 1.8260208368301392, 1.8260208368301392, 1.8260208368301392, 1.8260208368301392, 1.8260208368301392, 1.8260208368301392, 1.8260208368301392, 1.8260208368301392, 1.8260208368301392, 1.8260208368301392, 1.8260208368301392, 1.8260208368301392, 1.8260208368301392, 1.8260208368301392, 1.8261518478393555, 1.8262804746627808, 1.8268935680389404, 1.8270007371902466, 1.827156901359558, 1.8278887271881104, 1.828000783920288, 1.8280887603759766, 1.8281254768371582, 1.8284225463867188, 1.8288116455078125, 1.8288497924804688, 1.8288497924804688, 1.8288947343826294, 1.8289227485656738, 1.8289886713027954, 1.8297151327133179, 1.8300585746765137, 1.8301416635513306, 1.8305035829544067, 1.8305885791778564, 1.8305997848510742, 1.8307602405548096, 1.8307795524597168, 1.830906629562378, 1.830906629562378, 1.8309569358825684, 1.831383466720581, 1.8316378593444824, 1.8316586017608643, 1.831812858581543, 1.8319040536880493, 1.8319066762924194, 1.8323159217834473, 1.832457423210144, 1.8325855731964111, 1.832898736000061, 1.8329908847808838, 1.833305835723877, 1.8333076238632202, 1.8342702388763428, 1.8348793983459473, 1.8350136280059814, 1.8350313901901245, 1.8350356817245483, 1.835408091545105, 1.83573317527771, 1.83573317527771, 1.8358010053634644, 1.8361108303070068, 1.836119532585144, 1.8361353874206543, 1.8365585803985596, 1.836716651916504, 1.8368818759918213, 1.8372395038604736, 1.8380807638168335, 1.838151216506958, 1.8383740186691284, 1.8383822441101074, 1.838423490524292, 1.8384466171264648, 1.8384466171264648, 1.8384466171264648, 1.8384673595428467, 1.8385597467422485, 1.8385597467422485, 1.8386828899383545, 1.8390612602233887, 1.8391444683074951, 1.8392183780670166, 1.8392183780670166, 1.8392183780670166, 1.8392183780670166, 1.8392183780670166, 1.8392306566238403, 1.8392460346221924, 1.839394211769104, 1.8397340774536133, 1.839791178703308, 1.839846134185791, 1.8405547142028809, 1.8409055471420288, 1.8411211967468262, 1.841172218322754, 1.8414781093597412, 1.8415604829788208, 1.841609001159668, 1.8423961400985718, 1.8426305055618286, 1.8430545330047607, 1.8435527086257935, 1.8438212871551514, 1.843919277191162, 1.8439881801605225, 1.8441373109817505, 1.8442158699035645, 1.844681739807129, 1.8448047637939453, 1.8448132276535034, 1.8449592590332031, 1.8449592590332031, 1.8449592590332031, 1.8451106548309326, 1.8452003002166748, 1.8452200889587402, 1.8452683687210083, 1.8454028367996216, 1.8456165790557861, 1.8456265926361084, 1.8459811210632324, 1.8460304737091064, 1.8461991548538208, 1.846374750137329, 1.8463834524154663, 1.8466302156448364, 1.846856951713562, 1.8468773365020752, 1.84696364402771, 1.8471630811691284, 1.8472189903259277, 1.8472251892089844, 1.847712755203247, 1.8478190898895264, 1.848073959350586, 1.8483396768569946, 1.8485181331634521, 1.8486546277999878, 1.8487069606781006, 1.849289059638977, 1.849413275718689, 1.849495768547058, 1.8495635986328125, 1.850386381149292, 1.8509161472320557, 1.8511531352996826, 1.8513635396957397, 1.8517506122589111, 1.8517911434173584, 1.8519508838653564, 1.8522526025772095, 1.8523595333099365, 1.85239839553833, 1.8525493144989014, 1.8525543212890625, 1.85262131690979, 1.8526959419250488, 1.8528317213058472, 1.8532719612121582, 1.8534399271011353, 1.8534427881240845, 1.8535170555114746, 1.85395348072052, 1.8539825677871704, 1.8543466329574585, 1.8543466329574585, 1.854537010192871, 1.8548601865768433, 1.8548814058303833, 1.8549168109893799, 1.8551266193389893, 1.8551616668701172, 1.8551928997039795, 1.855276346206665, 1.8554434776306152, 1.855445146560669, 1.8554553985595703, 1.855487585067749, 1.8555293083190918, 1.8555293083190918, 1.8555431365966797, 1.8556816577911377, 1.8558101654052734, 1.8558595180511475, 1.855947732925415, 1.8559596538543701, 1.8560283184051514, 1.8561508655548096, 1.856445074081421, 1.8564692735671997, 1.8566648960113525, 1.8566967248916626, 1.8567695617675781, 1.8567695617675781, 1.8568296432495117, 1.8572115898132324, 1.8575472831726074, 1.8578336238861084, 1.8578981161117554, 1.8579401969909668, 1.857971429824829, 1.8580548763275146, 1.8582109212875366, 1.8583930730819702, 1.8585463762283325, 1.8585872650146484, 1.858797311782837, 1.8593090772628784, 1.8593153953552246, 1.8593745231628418, 1.8595092296600342, 1.8596490621566772, 1.8596524000167847, 1.8597866296768188, 1.8598146438598633, 1.8600428104400635, 1.8601406812667847, 1.8607501983642578, 1.860949993133545, 1.8609864711761475, 1.8611629009246826, 1.8611656427383423, 1.861413836479187, 1.8615245819091797, 1.8615443706512451, 1.8616163730621338, 1.8616163730621338, 1.8619072437286377, 1.8619699478149414, 1.8621578216552734, 1.8621892929077148, 1.8622053861618042, 1.8622398376464844, 1.8623101711273193, 1.862412452697754, 1.8628926277160645, 1.8630388975143433, 1.8631759881973267, 1.863243579864502, 1.8633685111999512, 1.8639662265777588, 1.8643275499343872, 1.8645439147949219, 1.86464262008667, 1.864749789237976, 1.8647546768188477, 1.8647758960723877, 1.8648436069488525, 1.8648767471313477, 1.864922046661377, 1.865005612373352, 1.8652000427246094, 1.8652803897857666, 1.8653509616851807, 1.8655122518539429, 1.8655667304992676, 1.8655674457550049, 1.8657095432281494, 1.8657171726226807, 1.8661102056503296, 1.8661277294158936, 1.86619234085083, 1.866292119026184, 1.8664500713348389, 1.8664822578430176, 1.8669674396514893, 1.8669743537902832, 1.8670384883880615, 1.867267370223999, 1.8674139976501465, 1.8674771785736084, 1.8676027059555054, 1.8676364421844482, 1.8678295612335205, 1.8678892850875854, 1.8679325580596924, 1.8684968948364258, 1.8685290813446045, 1.8685510158538818, 1.8685588836669922, 1.8686028718948364, 1.8687834739685059, 1.8688669204711914, 1.8689934015274048, 1.869127869606018, 1.8692314624786377, 1.86924147605896, 1.869588017463684, 1.8696403503417969, 1.869642972946167, 1.8696520328521729, 1.8696954250335693, 1.8697843551635742, 1.8698171377182007, 1.870091438293457, 1.8701519966125488, 1.870226263999939, 1.8704299926757812, 1.8704428672790527, 1.870531439781189, 1.870641827583313, 1.870643138885498, 1.8706461191177368, 1.870682716369629, 1.8710633516311646, 1.871241807937622, 1.8713099956512451, 1.8713126182556152, 1.87144136428833, 1.8714731931686401, 1.8716907501220703, 1.8717178106307983, 1.8717788457870483, 1.8719565868377686, 1.8720139265060425, 1.8721635341644287, 1.8723994493484497, 1.8724496364593506, 1.8725911378860474, 1.8727015256881714, 1.872838020324707, 1.8728611469268799, 1.8729920387268066, 1.873319149017334, 1.8735600709915161, 1.8736205101013184, 1.8737473487854004, 1.873948335647583, 1.8740870952606201, 1.8742327690124512, 1.8744792938232422, 1.874687910079956, 1.8749297857284546, 1.8750836849212646, 1.8750836849212646, 1.8750848770141602, 1.8756065368652344, 1.8757038116455078, 1.875767707824707, 1.8757963180541992, 1.8760178089141846, 1.8761928081512451, 1.8764748573303223, 1.8765228986740112, 1.8767132759094238, 1.8768222332000732, 1.8769123554229736, 1.876970887184143, 1.8770533800125122, 1.8772395849227905, 1.8773971796035767, 1.87742018699646, 1.8774296045303345, 1.8776801824569702, 1.8777179718017578, 1.8777637481689453, 1.8777717351913452, 1.8777804374694824, 1.8779492378234863, 1.8779726028442383, 1.8779726028442383, 1.8781113624572754, 1.8782479763031006, 1.8783726692199707, 1.878435730934143, 1.878476858139038, 1.8786163330078125, 1.8787420988082886, 1.8789674043655396, 1.8791030645370483, 1.8791108131408691, 1.879426121711731, 1.8797450065612793, 1.8802299499511719, 1.880232334136963, 1.8803619146347046, 1.8804686069488525, 1.880610704421997, 1.8806304931640625, 1.8806841373443604, 1.8808611631393433, 1.8811068534851074, 1.8812146186828613, 1.8817195892333984, 1.8817471265792847, 1.8817509412765503, 1.8817782402038574, 1.8822001218795776, 1.8823952674865723, 1.8830069303512573, 1.8830108642578125, 1.8830150365829468, 1.8830528259277344, 1.8830528259277344, 1.8832813501358032, 1.8833844661712646, 1.8833844661712646, 1.8833903074264526, 1.883609414100647, 1.883634090423584, 1.8837229013442993, 1.8837487697601318, 1.8837682008743286, 1.8837909698486328, 1.8837932348251343, 1.8837965726852417, 1.8838648796081543, 1.8841345310211182, 1.8841345310211182, 1.884153962135315, 1.884371042251587, 1.8843778371810913, 1.8843778371810913, 1.884399652481079, 1.8846508264541626, 1.8846776485443115, 1.8848659992218018, 1.8856110572814941, 1.8856322765350342, 1.88578200340271, 1.8858929872512817, 1.8859766721725464, 1.8860695362091064, 1.8863333463668823, 1.8863548040390015, 1.8863670825958252, 1.886436939239502, 1.8865880966186523, 1.8868416547775269, 1.887232780456543, 1.887384057044983, 1.8875247240066528, 1.8878827095031738, 1.8878942728042603, 1.8879708051681519, 1.88839590549469, 1.8884549140930176, 1.8884775638580322, 1.888681173324585, 1.8888626098632812, 1.8893070220947266, 1.8893671035766602, 1.8894473314285278, 1.8894495964050293, 1.8895223140716553, 1.8895344734191895, 1.8895412683486938, 1.889541506767273, 1.8896058797836304, 1.8896095752716064, 1.8896169662475586, 1.8897278308868408, 1.8898367881774902, 1.8899285793304443, 1.8901734352111816, 1.890197515487671, 1.8903099298477173, 1.8904616832733154, 1.890483021736145, 1.890486240386963, 1.8905506134033203, 1.8906943798065186, 1.890856146812439, 1.890856146812439, 1.8911677598953247, 1.8911824226379395, 1.8911833763122559, 1.891244888305664, 1.891256332397461, 1.8913073539733887, 1.8913217782974243, 1.8914763927459717, 1.891538381576538, 1.8915538787841797, 1.8915783166885376, 1.8917818069458008, 1.891942024230957, 1.8921804428100586, 1.8925292491912842, 1.8925782442092896, 1.8926348686218262, 1.8926942348480225, 1.8926942348480225, 1.8927788734436035, 1.8927806615829468, 1.892857313156128, 1.8929128646850586, 1.893062949180603, 1.893092393875122, 1.8932104110717773, 1.893248438835144, 1.8933377265930176, 1.8934307098388672, 1.8934307098388672, 1.893522024154663, 1.8936121463775635, 1.8936121463775635, 1.8937091827392578, 1.893729329109192, 1.8938360214233398, 1.8939197063446045, 1.8939231634140015, 1.8940670490264893, 1.8945969343185425, 1.8946454524993896, 1.8946505784988403, 1.8947196006774902, 1.8947677612304688, 1.8948252201080322, 1.8948588371276855, 1.8949612379074097, 1.8950598239898682, 1.8951075077056885, 1.895119071006775, 1.8951339721679688, 1.895134449005127, 1.895241379737854, 1.8954410552978516, 1.895593523979187, 1.8956286907196045, 1.8956825733184814, 1.8956832885742188, 1.8957252502441406, 1.8957815170288086, 1.8958964347839355, 1.896000623703003, 1.8960485458374023, 1.8960485458374023, 1.8961248397827148, 1.8962560892105103, 1.896428108215332, 1.8964564800262451, 1.8965051174163818, 1.8966840505599976, 1.8968520164489746, 1.8968546390533447, 1.8969757556915283, 1.8971699476242065, 1.8973265886306763, 1.8974201679229736, 1.8974262475967407, 1.8976272344589233, 1.8978614807128906, 1.8980600833892822, 1.8981764316558838, 1.898277759552002, 1.8983376026153564, 1.8984516859054565, 1.898521065711975, 1.898678183555603, 1.8986878395080566, 1.8988157510757446, 1.8988306522369385, 1.8990504741668701, 1.8991209268569946, 1.8991878032684326, 1.8992499113082886, 1.8992502689361572, 1.899381160736084, 1.8994265794754028, 1.8994896411895752, 1.8995037078857422, 1.8995568752288818, 1.899574875831604, 1.8997955322265625, 1.8998134136199951, 1.9000062942504883, 1.9000511169433594, 1.9002411365509033, 1.9005889892578125, 1.9006388187408447, 1.9007468223571777, 1.9009003639221191, 1.9009325504302979, 1.9011163711547852, 1.9011433124542236, 1.901151180267334, 1.9011926651000977, 1.9013649225234985, 1.9013649225234985, 1.901399850845337, 1.9014703035354614, 1.9014703035354614, 1.9014766216278076, 1.9015872478485107, 1.9016813039779663, 1.901825189590454, 1.9018663167953491, 1.9019850492477417, 1.9021127223968506, 1.9021434783935547, 1.9022128582000732, 1.9024285078048706, 1.9026460647583008, 1.902681589126587, 1.9027330875396729, 1.9028239250183105, 1.9028990268707275, 1.902928113937378, 1.9030145406723022, 1.9030933380126953, 1.9032189846038818, 1.9034267663955688, 1.9035794734954834, 1.9035935401916504, 1.9036067724227905, 1.9037977457046509, 1.9038236141204834, 1.903965711593628, 1.9039835929870605, 1.9040353298187256, 1.904055118560791, 1.9042197465896606, 1.9042612314224243, 1.9042761325836182, 1.904423713684082, 1.9044791460037231, 1.9045161008834839, 1.9045252799987793, 1.9045429229736328, 1.904588222503662, 1.9046292304992676, 1.9046401977539062, 1.9046406745910645, 1.904676914215088, 1.9047303199768066, 1.9047315120697021, 1.9047489166259766, 1.9049171209335327, 1.9049352407455444, 1.905190348625183, 1.9051973819732666, 1.905379295349121, 1.9053869247436523, 1.9054045677185059, 1.9055736064910889, 1.905580759048462, 1.9056190252304077, 1.9056851863861084, 1.9058029651641846, 1.9058728218078613, 1.9061148166656494, 1.906142234802246, 1.90618896484375, 1.906283974647522, 1.9063857793807983, 1.906480312347412, 1.9065393209457397, 1.9066729545593262, 1.9067262411117554, 1.9067978858947754, 1.9068245887756348, 1.907135009765625, 1.9071424007415771, 1.9071801900863647, 1.9072680473327637, 1.9072809219360352, 1.907379150390625, 1.9073805809020996, 1.907745599746704, 1.9078094959259033, 1.907892107963562, 1.9079244136810303, 1.9083142280578613, 1.908675193786621, 1.9088125228881836, 1.908994197845459, 1.9090667963027954, 1.9090993404388428, 1.909247875213623, 1.909334421157837, 1.90934419631958, 1.9093518257141113, 1.9094188213348389, 1.9095147848129272, 1.9095557928085327, 1.9095687866210938, 1.9096823930740356, 1.9097012281417847, 1.9099478721618652, 1.9099912643432617, 1.9100942611694336, 1.9101099967956543, 1.9102158546447754, 1.9102158546447754, 1.9102191925048828, 1.9104703664779663, 1.9105273485183716, 1.910631775856018, 1.910658597946167, 1.9106926918029785, 1.9106967449188232, 1.9107238054275513, 1.910801649093628, 1.9108085632324219, 1.9108343124389648, 1.910893201828003, 1.911017656326294, 1.911017656326294, 1.9110502004623413, 1.9110889434814453, 1.9111367464065552, 1.9112811088562012, 1.9113013744354248, 1.911436676979065, 1.9118744134902954, 1.912230134010315, 1.9127514362335205, 1.9128575325012207, 1.9128913879394531, 1.9130785465240479, 1.9130785465240479, 1.9130785465240479, 1.9131141901016235, 1.9132097959518433, 1.9132251739501953, 1.9132744073867798, 1.913499355316162, 1.9135496616363525, 1.9136161804199219, 1.9137241840362549, 1.9137381315231323, 1.9138493537902832, 1.9139964580535889, 1.9140427112579346, 1.9140774011611938, 1.9140774011611938, 1.9140774011611938, 1.9141846895217896, 1.9141910076141357, 1.9142165184020996, 1.9142746925354004, 1.9143736362457275, 1.9144234657287598, 1.9144816398620605, 1.9144866466522217, 1.9145996570587158, 1.914650797843933, 1.9147043228149414, 1.9149324893951416, 1.9150848388671875, 1.915086030960083, 1.9152368307113647, 1.915244698524475, 1.9152965545654297, 1.9153119325637817, 1.9153386354446411, 1.9157538414001465, 1.915871500968933, 1.9160723686218262, 1.9160927534103394, 1.9161350727081299, 1.9162828922271729, 1.9163634777069092, 1.9164741039276123, 1.9165453910827637, 1.9167354106903076, 1.9167864322662354, 1.9167938232421875, 1.9169275760650635, 1.9170750379562378, 1.9171032905578613, 1.9178653955459595, 1.917872667312622, 1.9180305004119873, 1.918273687362671, 1.9183857440948486, 1.9183859825134277, 1.918472409248352, 1.9185587167739868, 1.9185659885406494, 1.918600082397461, 1.9186400175094604, 1.9187239408493042, 1.9187756776809692, 1.9190387725830078, 1.9193216562271118, 1.919419527053833, 1.9195119142532349, 1.9195128679275513, 1.9196665287017822, 1.919826865196228, 1.919861078262329, 1.919935941696167, 1.920332908630371, 1.9203953742980957, 1.9204555749893188, 1.920632243156433, 1.9206581115722656, 1.9207600355148315, 1.9208431243896484, 1.9209413528442383, 1.9210582971572876, 1.9210699796676636, 1.9210989475250244, 1.921128273010254, 1.9212199449539185, 1.921262502670288, 1.9212629795074463, 1.9214441776275635, 1.9215812683105469, 1.921842098236084, 1.922008752822876, 1.9221407175064087, 1.9221454858779907, 1.9221748113632202, 1.9221866130828857, 1.9222328662872314, 1.9223933219909668, 1.9229223728179932, 1.9229387044906616, 1.9229618310928345, 1.9231605529785156, 1.9231863021850586, 1.9233818054199219, 1.9234094619750977, 1.9236153364181519, 1.9236291646957397, 1.923675775527954, 1.923769474029541, 1.923816204071045, 1.9238379001617432, 1.9239253997802734, 1.923997402191162, 1.9241739511489868, 1.9241852760314941, 1.9242268800735474, 1.9242366552352905, 1.9242647886276245, 1.9242969751358032, 1.924336314201355, 1.9246656894683838, 1.9249866008758545, 1.9249869585037231, 1.9249911308288574, 1.9250237941741943, 1.925074815750122, 1.9251362085342407, 1.925228238105774, 1.9255688190460205, 1.9256266355514526, 1.9256374835968018, 1.9257612228393555, 1.9257752895355225, 1.9257752895355225, 1.925809383392334, 1.9258610010147095, 1.9261810779571533, 1.9262465238571167, 1.9264018535614014, 1.9266464710235596, 1.926802635192871, 1.926969289779663, 1.9269869327545166, 1.9271106719970703, 1.927159309387207, 1.927171230316162, 1.9271975755691528, 1.9272215366363525, 1.9272215366363525, 1.9272499084472656, 1.9272900819778442, 1.9273006916046143, 1.9273658990859985, 1.9274048805236816, 1.9275519847869873, 1.9276065826416016, 1.9276409149169922, 1.9277228116989136, 1.9277654886245728, 1.9277725219726562, 1.9278351068496704, 1.9278897047042847, 1.9278907775878906, 1.92789888381958, 1.92789888381958, 1.92789888381958, 1.9279165267944336, 1.9280426502227783, 1.9280946254730225, 1.9281549453735352, 1.9283277988433838, 1.928332805633545, 1.928332805633545, 1.9283888339996338, 1.928483247756958, 1.9285529851913452, 1.9286179542541504, 1.9288172721862793, 1.9288208484649658, 1.9289240837097168, 1.9291759729385376, 1.929226279258728, 1.9293787479400635, 1.9294981956481934, 1.929502010345459, 1.9295302629470825, 1.9295755624771118, 1.9296447038650513, 1.9296855926513672, 1.9296996593475342, 1.929771900177002, 1.9298126697540283, 1.9303942918777466, 1.9304957389831543, 1.9305524826049805, 1.9306440353393555, 1.93095064163208, 1.931044101715088, 1.9311156272888184, 1.931221604347229, 1.9313753843307495, 1.931439995765686, 1.9314554929733276, 1.9314849376678467, 1.9316868782043457, 1.9316990375518799, 1.9317735433578491, 1.9317753314971924, 1.9318089485168457, 1.9318945407867432, 1.9319074153900146, 1.9321444034576416, 1.9321545362472534, 1.9321545362472534, 1.932323694229126, 1.9323714971542358, 1.9324076175689697, 1.9324246644973755, 1.9324630498886108, 1.9326000213623047, 1.9327661991119385, 1.9330224990844727, 1.933029294013977, 1.9330309629440308, 1.9330960512161255, 1.9331257343292236, 1.933152437210083, 1.9332091808319092, 1.9332300424575806, 1.9332542419433594, 1.9332752227783203, 1.9333869218826294, 1.933414340019226, 1.933517336845398, 1.9336116313934326, 1.9336810111999512, 1.9337230920791626, 1.9338139295578003, 1.933821439743042, 1.93405020236969, 1.934230923652649, 1.9345680475234985, 1.9345688819885254, 1.9347707033157349, 1.9350855350494385, 1.9351251125335693, 1.9351906776428223, 1.935254693031311, 1.9353388547897339, 1.9353437423706055, 1.935349941253662, 1.935410499572754, 1.9355100393295288, 1.9355719089508057, 1.9356545209884644, 1.9356741905212402, 1.9357327222824097, 1.9358429908752441, 1.9358487129211426, 1.9359047412872314, 1.9359047412872314, 1.9359047412872314, 1.9360673427581787, 1.9361646175384521, 1.9362198114395142, 1.9363800287246704, 1.9367644786834717, 1.9369301795959473, 1.937145709991455, 1.937394618988037, 1.9374151229858398, 1.9374289512634277, 1.9374874830245972, 1.9374947547912598, 1.9375234842300415, 1.9375808238983154, 1.9376928806304932, 1.9376970529556274, 1.9379713535308838, 1.938042163848877, 1.9380446672439575, 1.938156247138977, 1.9381566047668457, 1.938164472579956, 1.9383498430252075, 1.938371181488037, 1.9386762380599976, 1.9387543201446533, 1.9388368129730225, 1.9389393329620361, 1.9389393329620361, 1.9389675855636597, 1.9389841556549072, 1.9389854669570923, 1.9390755891799927, 1.9390898942947388, 1.939152717590332, 1.9391742944717407, 1.939186453819275, 1.9392198324203491, 1.9392427206039429, 1.939257025718689, 1.9392917156219482, 1.9392975568771362, 1.9393744468688965, 1.939387321472168, 1.9394493103027344, 1.9395508766174316, 1.9395672082901, 1.939846396446228, 1.9399198293685913, 1.9399363994598389, 1.9401429891586304, 1.9401617050170898, 1.9402732849121094, 1.9403245449066162, 1.9404571056365967, 1.9407135248184204, 1.9407455921173096, 1.940794825553894, 1.9408167600631714, 1.940843939781189, 1.9408882856369019, 1.9410078525543213, 1.941172480583191, 1.9412596225738525, 1.9414710998535156, 1.9415397644042969, 1.9416424036026, 1.9416837692260742, 1.941796898841858, 1.941802740097046, 1.9418593645095825, 1.9418704509735107, 1.9418811798095703, 1.9418811798095703, 1.9419496059417725, 1.942091464996338, 1.942124605178833, 1.942156434059143, 1.9422004222869873, 1.9422224760055542, 1.9422824382781982, 1.942333698272705, 1.942363977432251, 1.9425195455551147, 1.9426133632659912, 1.942635178565979, 1.9426735639572144, 1.9426894187927246, 1.942702054977417, 1.9427103996276855, 1.9427742958068848, 1.9427776336669922, 1.9428056478500366, 1.942834496498108, 1.9429746866226196, 1.9431215524673462, 1.9431376457214355, 1.943159818649292, 1.9431679248809814, 1.9433166980743408, 1.943385124206543, 1.943587064743042, 1.94368314743042, 1.9437638521194458, 1.9437931776046753, 1.9438010454177856, 1.943880558013916, 1.9439116716384888, 1.9439631700515747, 1.9440503120422363, 1.9441050291061401, 1.9442092180252075, 1.9442092180252075, 1.944295883178711, 1.944326400756836, 1.9443354606628418, 1.944439172744751, 1.9444653987884521, 1.9445438385009766, 1.9446189403533936, 1.944767713546753, 1.9447802305221558, 1.9447803497314453, 1.9447907209396362, 1.9448492527008057, 1.9448572397232056, 1.9449657201766968, 1.9451744556427002, 1.9451771974563599, 1.9454326629638672, 1.9454811811447144, 1.9455924034118652, 1.9456707239151, 1.9457398653030396, 1.945806860923767, 1.945806860923767, 1.9458568096160889, 1.9459834098815918, 1.9460035562515259, 1.9460253715515137, 1.946326494216919, 1.9463622570037842, 1.9463965892791748, 1.9464999437332153, 1.9466397762298584, 1.9468252658843994, 1.9468252658843994, 1.9468276500701904, 1.9468717575073242, 1.9469190835952759, 1.9469268321990967, 1.9469327926635742, 1.947033405303955, 1.947099208831787, 1.947171688079834, 1.9472392797470093, 1.9472897052764893, 1.9474642276763916, 1.9474962949752808, 1.9474962949752808, 1.947497844696045, 1.947546124458313, 1.9475979804992676, 1.9476039409637451, 1.9477425813674927, 1.9478323459625244, 1.9478704929351807, 1.9478944540023804, 1.9479053020477295, 1.9480159282684326, 1.9480781555175781, 1.948196291923523, 1.9482479095458984, 1.9483230113983154, 1.9483332633972168, 1.9483357667922974, 1.948358178138733, 1.948484182357788, 1.948490858078003, 1.9485074281692505, 1.948779821395874, 1.94889497756958, 1.9489201307296753, 1.9489332437515259, 1.9489721059799194, 1.9489871263504028, 1.9490188360214233, 1.949143648147583, 1.949159860610962, 1.949182391166687, 1.9492995738983154, 1.9495468139648438, 1.949582815170288, 1.9496757984161377, 1.9497309923171997, 1.9497352838516235, 1.949803352355957, 1.9498333930969238, 1.9498440027236938, 1.9499003887176514, 1.949916958808899, 1.9502663612365723, 1.950325608253479, 1.9504410028457642, 1.950487732887268, 1.950513482093811, 1.9505202770233154, 1.950620412826538, 1.9506523609161377, 1.9506689310073853, 1.9506783485412598, 1.9508187770843506, 1.9508908987045288, 1.9509302377700806, 1.9511953592300415, 1.9512012004852295, 1.9513493776321411, 1.951385736465454, 1.9514565467834473, 1.9514740705490112, 1.9515427350997925, 1.951566219329834, 1.9516150951385498, 1.9516245126724243, 1.9516799449920654, 1.9517977237701416, 1.9518013000488281, 1.951884388923645, 1.9519658088684082, 1.9520337581634521, 1.9520454406738281, 1.9521098136901855, 1.9521280527114868, 1.9521280527114868, 1.9521280527114868, 1.9521280527114868, 1.9521926641464233, 1.9522273540496826, 1.9522974491119385, 1.9524002075195312, 1.9526429176330566, 1.9526875019073486, 1.9528239965438843, 1.9529651403427124, 1.9530490636825562, 1.9530905485153198, 1.9531340599060059, 1.9531368017196655, 1.9533095359802246, 1.9533095359802246, 1.9534924030303955, 1.9535599946975708, 1.95369291305542, 1.953751564025879, 1.9537568092346191, 1.9537992477416992, 1.9540700912475586, 1.9541714191436768, 1.9541939496994019, 1.954249620437622, 1.9543476104736328, 1.9543509483337402, 1.9545378684997559, 1.9545388221740723, 1.9545459747314453, 1.954581379890442, 1.9546425342559814, 1.9547005891799927, 1.9548523426055908, 1.9548977613449097, 1.9549553394317627, 1.9549553394317627, 1.9549847841262817, 1.955021858215332, 1.9553149938583374, 1.955357551574707, 1.9553861618041992, 1.9554212093353271, 1.95542311668396, 1.9554412364959717, 1.9555332660675049, 1.9555909633636475, 1.9556797742843628, 1.9556797742843628, 1.9557459354400635, 1.955752968788147, 1.9557641744613647, 1.9557898044586182, 1.9558026790618896, 1.9558051824569702, 1.9561350345611572, 1.9561506509780884, 1.956299901008606, 1.9563246965408325, 1.9563381671905518, 1.956387996673584, 1.9565184116363525, 1.9566032886505127, 1.9566214084625244, 1.9566237926483154, 1.956631064414978, 1.9567248821258545, 1.9567660093307495, 1.9569056034088135, 1.9570345878601074, 1.9571542739868164, 1.957239031791687, 1.9573379755020142, 1.9573402404785156, 1.9576659202575684, 1.9577381610870361, 1.9577393531799316, 1.9578332901000977, 1.957930088043213, 1.9580811262130737, 1.9581480026245117, 1.9581576585769653, 1.9581968784332275, 1.9582277536392212, 1.9585022926330566, 1.958533763885498, 1.9586186408996582, 1.9586544036865234, 1.9587353467941284, 1.9587477445602417, 1.958796501159668, 1.9589136838912964, 1.9589312076568604, 1.9591305255889893, 1.959152102470398, 1.9592229127883911, 1.959374189376831, 1.959374189376831, 1.9593766927719116, 1.9593766927719116, 1.9594894647598267, 1.95950186252594, 1.95950186252594, 1.9596524238586426, 1.9596948623657227, 1.9597481489181519, 1.9598150253295898, 1.9599193334579468, 1.959952473640442, 1.9599781036376953, 1.9599933624267578, 1.9600896835327148, 1.9601666927337646, 1.9601829051971436, 1.9602084159851074, 1.9602446556091309, 1.960270643234253, 1.9603102207183838, 1.9603242874145508, 1.9604401588439941, 1.9604427814483643, 1.9605368375778198, 1.960649013519287, 1.9607350826263428, 1.960831642150879, 1.9608458280563354, 1.9609696865081787, 1.9609904289245605, 1.9610908031463623, 1.961130142211914, 1.9611790180206299, 1.9612641334533691, 1.9613101482391357, 1.9613251686096191, 1.9613535404205322, 1.9613783359527588, 1.9614819288253784, 1.9617010354995728, 1.9617054462432861, 1.9617788791656494, 1.9617788791656494, 1.961874008178711, 1.9618840217590332, 1.961890697479248, 1.9619474411010742, 1.961949348449707, 1.9620070457458496, 1.9620239734649658, 1.9620592594146729, 1.9620774984359741, 1.962181568145752, 1.962315320968628, 1.962348222732544, 1.9624172449111938, 1.962615966796875, 1.9628381729125977, 1.9628381729125977, 1.9628381729125977, 1.9628381729125977, 1.9628381729125977, 1.9628381729125977, 1.9628381729125977, 1.9628381729125977, 1.9628583192825317, 1.9628790616989136, 1.9629325866699219, 1.962953805923462, 1.9631569385528564, 1.9632339477539062, 1.9632631540298462, 1.963275671005249, 1.963301420211792, 1.9633193016052246, 1.9633677005767822, 1.9636354446411133, 1.9637179374694824, 1.9637526273727417, 1.9638535976409912, 1.9639029502868652, 1.9639079570770264, 1.9639393091201782, 1.9639614820480347, 1.963991641998291, 1.9640929698944092, 1.964154601097107, 1.9641703367233276, 1.9642173051834106, 1.9642221927642822, 1.9642369747161865, 1.9642369747161865, 1.96426260471344, 1.9646482467651367, 1.9646494388580322, 1.9647157192230225, 1.9647774696350098, 1.9649226665496826, 1.9649955034255981, 1.9651026725769043, 1.9651026725769043, 1.9651026725769043, 1.9651026725769043, 1.9651026725769043, 1.965173363685608, 1.965173363685608, 1.9654481410980225, 1.9656212329864502, 1.9657025337219238, 1.965798020362854, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658193588256836, 1.9658761024475098, 1.9659652709960938, 1.966001272201538, 1.966018557548523, 1.9660261869430542, 1.9661083221435547, 1.9661450386047363, 1.9661478996276855, 1.9661731719970703, 1.9663463830947876, 1.966365098953247, 1.9665006399154663, 1.9665722846984863, 1.9665780067443848, 1.9668490886688232, 1.9669184684753418, 1.966947078704834, 1.966951608657837, 1.9669551849365234, 1.9670510292053223, 1.9672353267669678, 1.967437505722046, 1.967451572418213, 1.967453956604004, 1.967473030090332, 1.9677338600158691, 1.967828631401062, 1.9678449630737305, 1.967977523803711, 1.9680368900299072, 1.968056082725525, 1.9680628776550293, 1.9681591987609863, 1.9682111740112305, 1.9682612419128418, 1.9683876037597656, 1.9684933423995972, 1.96852445602417, 1.968552827835083, 1.9685648679733276, 1.9685676097869873, 1.968815565109253, 1.968817949295044, 1.9688448905944824, 1.96885085105896, 1.9689157009124756, 1.9689661264419556, 1.9691110849380493, 1.9691143035888672, 1.9691827297210693, 1.9692150354385376, 1.9692336320877075, 1.9693608283996582, 1.9694616794586182, 1.9694807529449463, 1.9694820642471313, 1.9695099592208862, 1.9696168899536133, 1.969760537147522, 1.96987783908844, 1.970077633857727, 1.9701368808746338, 1.9702378511428833, 1.9702664613723755, 1.9702805280685425, 1.9702913761138916, 1.9703259468078613, 1.9704325199127197, 1.970479130744934, 1.9704983234405518, 1.9705162048339844, 1.9705630540847778, 1.9706306457519531, 1.9709186553955078, 1.970944881439209, 1.971008062362671, 1.971060872077942, 1.9712547063827515, 1.9712892770767212, 1.9713596105575562, 1.971513032913208, 1.9715771675109863, 1.9716472625732422, 1.9716472625732422, 1.9717259407043457, 1.9717674255371094, 1.971818208694458, 1.971832275390625, 1.9720462560653687, 1.972161889076233, 1.9722036123275757, 1.9722310304641724, 1.972280740737915, 1.9723345041275024, 1.9724063873291016, 1.972509503364563, 1.9725556373596191, 1.9725556373596191, 1.9725556373596191, 1.9725556373596191, 1.9729219675064087, 1.9730989933013916, 1.9731324911117554, 1.9732351303100586, 1.9732470512390137, 1.9733586311340332, 1.9734752178192139, 1.9736155271530151, 1.9736638069152832, 1.9736716747283936, 1.9736723899841309, 1.973724126815796, 1.9737367630004883, 1.9737672805786133, 1.9738091230392456, 1.9738093614578247, 1.9738366603851318, 1.9738428592681885, 1.973852515220642, 1.9739012718200684, 1.9739305973052979, 1.9739863872528076, 1.9740262031555176, 1.974339485168457, 1.9743635654449463, 1.9743773937225342, 1.9744269847869873, 1.9744820594787598, 1.9745599031448364, 1.9746042490005493, 1.9746770858764648, 1.9746824502944946, 1.9747394323349, 1.9747496843338013, 1.9747772216796875, 1.9748013019561768, 1.9751689434051514, 1.9752020835876465, 1.9752044677734375, 1.975315809249878, 1.975365400314331, 1.9753690958023071, 1.9754329919815063, 1.9754711389541626, 1.9754892587661743, 1.9756128787994385, 1.9756364822387695, 1.9756581783294678, 1.9756669998168945, 1.9756910800933838, 1.9757038354873657, 1.9757091999053955, 1.9757307767868042, 1.9757307767868042, 1.9757307767868042, 1.9757307767868042, 1.9757591485977173, 1.975760817527771, 1.9757721424102783, 1.975854754447937, 1.9758927822113037, 1.9759347438812256, 1.9759454727172852, 1.9760477542877197, 1.9762035608291626, 1.9762754440307617, 1.9763424396514893, 1.976353645324707, 1.9764118194580078, 1.9764515161514282, 1.9764697551727295, 1.9765666723251343, 1.9766048192977905, 1.9767001867294312, 1.9769117832183838, 1.9770071506500244, 1.9771416187286377, 1.977148175239563, 1.9772772789001465, 1.9773521423339844, 1.9773718118667603, 1.9774951934814453, 1.9775511026382446, 1.97757887840271, 1.9776004552841187, 1.9776065349578857, 1.9776235818862915, 1.977650761604309, 1.9778168201446533, 1.9778251647949219, 1.9779188632965088, 1.9780125617980957, 1.9781255722045898, 1.978168249130249, 1.9781752824783325, 1.9781767129898071, 1.9782088994979858, 1.9782376289367676, 1.9782791137695312, 1.9782835245132446, 1.9784929752349854, 1.9785301685333252, 1.9786522388458252, 1.9786700010299683, 1.978670597076416, 1.978677749633789, 1.9787095785140991, 1.9787107706069946, 1.9789149761199951, 1.9789490699768066, 1.978988528251648, 1.9790523052215576, 1.9790654182434082, 1.9791412353515625, 1.9791982173919678, 1.979211449623108, 1.9792671203613281, 1.9793038368225098, 1.9793190956115723, 1.9794180393218994, 1.9794343709945679, 1.9794862270355225, 1.9795138835906982, 1.9795801639556885, 1.9795844554901123, 1.9798170328140259, 1.979963779449463, 1.9800419807434082, 1.980163335800171, 1.9801738262176514, 1.9802448749542236, 1.9802496433258057, 1.9803012609481812, 1.980605959892273, 1.9807894229888916, 1.9810669422149658, 1.9811456203460693, 1.981182336807251, 1.9811962842941284, 1.9813652038574219, 1.981367588043213, 1.9817612171173096, 1.9819270372390747, 1.9819989204406738, 1.9820294380187988, 1.9820353984832764, 1.9820632934570312, 1.9820857048034668, 1.9821432828903198, 1.9821432828903198, 1.9822767972946167, 1.9822940826416016, 1.9822945594787598, 1.9823638200759888, 1.9825270175933838, 1.9825270175933838, 1.9825767278671265, 1.982689619064331, 1.9827244281768799, 1.982919454574585, 1.9830929040908813, 1.9831132888793945, 1.9831284284591675, 1.983156442642212, 1.983185887336731, 1.9832085371017456, 1.9832558631896973, 1.9832748174667358, 1.9833972454071045, 1.983419418334961, 1.9834649562835693, 1.9836513996124268, 1.9836739301681519, 1.983769416809082, 1.9838073253631592, 1.9838112592697144, 1.9839046001434326, 1.9839290380477905, 1.983931541442871, 1.9839621782302856, 1.9840929508209229, 1.984116792678833, 1.984130620956421, 1.984148621559143, 1.9841725826263428, 1.9842817783355713, 1.984283208847046, 1.9844028949737549, 1.9844125509262085, 1.9844125509262085, 1.9844125509262085, 1.9844125509262085, 1.984613299369812, 1.9846258163452148, 1.9847427606582642, 1.9848079681396484, 1.9848257303237915, 1.9849516153335571, 1.9849848747253418, 1.9850635528564453, 1.9852333068847656, 1.9852641820907593, 1.9852839708328247, 1.9854977130889893, 1.985526204109192, 1.9856842756271362, 1.9856915473937988, 1.9858570098876953, 1.9859766960144043, 1.9859800338745117, 1.9860812425613403, 1.9860827922821045, 1.986100435256958, 1.9861682653427124, 1.9862780570983887, 1.9862874746322632, 1.9863688945770264, 1.986440658569336, 1.9864447116851807, 1.9864568710327148, 1.986457109451294, 1.986511468887329, 1.9865227937698364, 1.986574649810791, 1.986696481704712, 1.9868825674057007, 1.9869720935821533, 1.9869804382324219, 1.9870525598526, 1.9870834350585938, 1.9874043464660645, 1.9875097274780273, 1.9875874519348145, 1.9877108335494995, 1.987766981124878, 1.9877828359603882, 1.9878398180007935, 1.987868309020996, 1.987868309020996, 1.987868309020996, 1.987917184829712, 1.9879283905029297, 1.9879542589187622, 1.9879658222198486, 1.9879910945892334, 1.9881150722503662, 1.988133430480957, 1.988145112991333, 1.988146424293518, 1.9883737564086914, 1.9885883331298828, 1.9886910915374756, 1.9887566566467285, 1.9888169765472412, 1.9888372421264648, 1.9888776540756226, 1.9889119863510132, 1.9889564514160156, 1.9890094995498657, 1.9890637397766113, 1.9890953302383423, 1.9891104698181152, 1.9891170263290405, 1.9891177415847778, 1.9892075061798096, 1.9892256259918213, 1.9892815351486206, 1.9892909526824951, 1.989436149597168, 1.9895213842391968, 1.989586353302002, 1.9896352291107178, 1.9896963834762573, 1.9897541999816895, 1.9898619651794434, 1.9899189472198486, 1.9899840354919434, 1.9900500774383545, 1.9901727437973022, 1.9903547763824463, 1.9904351234436035, 1.9905319213867188, 1.9905383586883545, 1.9907009601593018, 1.9907029867172241, 1.9908676147460938, 1.9908980131149292, 1.9910184144973755, 1.9910266399383545, 1.991225004196167, 1.9912351369857788, 1.991260290145874, 1.9914571046829224, 1.9915192127227783, 1.991629958152771, 1.9916647672653198, 1.991694688796997, 1.9917552471160889, 1.991875410079956, 1.9919750690460205, 1.9920023679733276, 1.9921150207519531, 1.992124319076538, 1.9922523498535156, 1.9923052787780762, 1.992383599281311, 1.9923996925354004, 1.9926447868347168, 1.992688536643982, 1.9926948547363281, 1.9930145740509033, 1.993038296699524, 1.9931457042694092, 1.9932379722595215, 1.993311882019043, 1.9933338165283203, 1.993340015411377, 1.9933431148529053, 1.9934732913970947, 1.9936413764953613, 1.9937189817428589, 1.9937288761138916, 1.993735671043396, 1.993849754333496, 1.9941906929016113, 1.994246482849121, 1.9943221807479858, 1.9944671392440796, 1.994499921798706, 1.9947946071624756, 1.9947960376739502, 1.9948039054870605, 1.9948980808258057, 1.9949638843536377, 1.9951021671295166, 1.995177984237671, 1.995255470275879, 1.9953168630599976, 1.995404839515686, 1.995410442352295, 1.9954285621643066, 1.9954440593719482, 1.9954445362091064, 1.9954490661621094, 1.9955145120620728, 1.9955196380615234, 1.9956471920013428, 1.9957088232040405, 1.995772361755371, 1.9958244562149048, 1.9958398342132568, 1.9959065914154053, 1.9959163665771484, 1.9959863424301147, 1.9960013628005981, 1.9961028099060059, 1.9961292743682861, 1.9961776733398438, 1.9962120056152344, 1.9962385892868042, 1.9963068962097168, 1.9963538646697998, 1.9964492321014404, 1.9965922832489014, 1.9966398477554321, 1.9967316389083862, 1.9968205690383911, 1.9969629049301147, 1.996969223022461, 1.99717378616333, 1.9972878694534302, 1.9974589347839355, 1.9975398778915405, 1.9975430965423584, 1.9976338148117065, 1.9977047443389893, 1.99773108959198, 1.9978786706924438, 1.9979732036590576, 1.9980661869049072, 1.998077154159546, 1.9981279373168945, 1.9981775283813477, 1.9983515739440918, 1.9983712434768677, 1.9983712434768677, 1.9983712434768677, 1.9983712434768677, 1.998384714126587, 1.998491883277893, 1.9985065460205078, 1.998558759689331, 1.9986746311187744, 1.9991806745529175, 1.9992353916168213, 1.9992804527282715, 1.9993202686309814, 1.9994597434997559, 1.999479055404663, 1.999482274055481, 1.9996130466461182, 1.9996252059936523, 1.9996296167373657, 1.9996764659881592, 1.999717354774475, 1.9997321367263794, 1.9998012781143188, 1.9998562335968018, 1.9998984336853027, 1.9999209642410278, 1.999955177307129, 2.000032424926758, 2.000303030014038, 2.000316619873047, 2.0003955364227295, 2.000448703765869, 2.000452756881714, 2.0006086826324463, 2.0006442070007324, 2.0006566047668457, 2.0006580352783203, 2.0007429122924805, 2.0007526874542236, 2.000910758972168, 2.000948667526245, 2.000960350036621, 2.001049041748047, 2.0011165142059326, 2.0011866092681885, 2.0012619495391846, 2.0012993812561035, 2.0013439655303955, 2.001358985900879, 2.001505136489868, 2.001582622528076, 2.0016753673553467, 2.001725196838379, 2.001810312271118, 2.001810312271118, 2.001810312271118, 2.001810312271118, 2.001845359802246, 2.001877546310425, 2.0019068717956543, 2.002023220062256, 2.0022377967834473, 2.0023932456970215, 2.002408027648926, 2.002455711364746, 2.0026228427886963, 2.0027337074279785, 2.0029003620147705, 2.0029690265655518, 2.003004550933838, 2.0031232833862305, 2.0033278465270996, 2.0034782886505127, 2.0035176277160645, 2.0035855770111084, 2.003589153289795, 2.003614902496338, 2.003629684448242, 2.0036704540252686, 2.0036799907684326, 2.0037128925323486, 2.003819465637207, 2.0038280487060547, 2.003829002380371, 2.0039782524108887, 2.004054546356201, 2.004143476486206, 2.0041615962982178, 2.0042145252227783, 2.0042457580566406, 2.0042800903320312, 2.0043535232543945, 2.004467725753784, 2.004467725753784, 2.004470109939575, 2.004483699798584, 2.004511833190918, 2.004570484161377, 2.00457501411438, 2.004636764526367, 2.004695415496826, 2.0048673152923584, 2.004887819290161, 2.0050339698791504, 2.0051376819610596, 2.005171060562134, 2.0052549839019775, 2.0054731369018555, 2.005520820617676, 2.005580425262451, 2.0056023597717285, 2.0057260990142822, 2.0057663917541504, 2.005770444869995, 2.005786418914795, 2.0058445930480957, 2.005922555923462, 2.006096601486206, 2.006286382675171, 2.006467342376709, 2.0065197944641113, 2.0065367221832275, 2.006554365158081, 2.0065853595733643, 2.006687641143799, 2.0069098472595215, 2.0070137977600098, 2.0070674419403076, 2.0071964263916016, 2.0073482990264893, 2.0073843002319336, 2.0073940753936768, 2.0074474811553955, 2.0074565410614014, 2.0075063705444336, 2.0076870918273926, 2.0077569484710693, 2.0079822540283203, 2.0080928802490234, 2.0081393718719482, 2.0081520080566406, 2.008329153060913, 2.0083565711975098, 2.0083582401275635, 2.0084898471832275, 2.008507490158081, 2.008549213409424, 2.0085606575012207, 2.0085785388946533, 2.0086166858673096, 2.008636951446533, 2.008758783340454, 2.0087742805480957, 2.008787155151367, 2.008871555328369, 2.0090224742889404, 2.009059429168701, 2.009188413619995, 2.0094380378723145, 2.009455919265747, 2.009544849395752, 2.009584426879883, 2.009636163711548, 2.009650945663452, 2.009657859802246, 2.0097007751464844, 2.0097174644470215, 2.0097811222076416, 2.0098204612731934, 2.0098495483398438, 2.0099399089813232, 2.009984016418457, 2.010002851486206, 2.0100152492523193, 2.0100667476654053, 2.010150671005249, 2.0101518630981445, 2.010178565979004, 2.010190010070801, 2.010251760482788, 2.0103507041931152, 2.01039981842041, 2.010418176651001, 2.0105202198028564, 2.0105695724487305, 2.0106046199798584, 2.010688543319702, 2.0107004642486572, 2.0107805728912354, 2.010850667953491, 2.0108776092529297, 2.0109550952911377, 2.0109925270080566, 2.0110349655151367, 2.011115789413452, 2.0111560821533203, 2.011232376098633, 2.0112850666046143, 2.011307954788208, 2.0113348960876465, 2.0113937854766846, 2.0115127563476562, 2.0115246772766113, 2.01164174079895, 2.011643171310425, 2.0116493701934814, 2.011674404144287, 2.011690139770508, 2.0117599964141846, 2.0117733478546143, 2.011812686920166, 2.011812686920166, 2.011861801147461, 2.0119986534118652, 2.012024402618408, 2.0120348930358887, 2.012101888656616, 2.012151002883911, 2.0122861862182617, 2.012354850769043, 2.012371063232422, 2.012460947036743, 2.012479782104492, 2.012550115585327, 2.0125961303710938, 2.0126171112060547, 2.012798309326172, 2.012887477874756, 2.012941837310791, 2.013026714324951, 2.0130271911621094, 2.013169050216675, 2.0131773948669434, 2.013282537460327, 2.0133233070373535, 2.0133609771728516, 2.0134127140045166, 2.01345157623291, 2.0134541988372803, 2.01346755027771, 2.0136325359344482, 2.0136325359344482, 2.013660430908203, 2.0136680603027344, 2.013701915740967, 2.014005661010742, 2.014078140258789, 2.0140819549560547, 2.01419734954834, 2.0142269134521484, 2.014280319213867, 2.0143110752105713, 2.014373302459717, 2.0147061347961426, 2.0147061347961426, 2.0147061347961426, 2.0147147178649902, 2.0148415565490723, 2.0152571201324463, 2.015366315841675, 2.0154809951782227, 2.0155434608459473, 2.0155811309814453, 2.015615940093994, 2.015784978866577, 2.0158026218414307, 2.015911102294922, 2.015949249267578, 2.0159530639648438, 2.01607608795166, 2.0160880088806152, 2.0161004066467285, 2.0164573192596436, 2.0165786743164062, 2.0166187286376953, 2.0166306495666504, 2.0166451930999756, 2.0166707038879395, 2.016728639602661, 2.016806125640869, 2.0170187950134277, 2.0171170234680176, 2.01715350151062, 2.0171847343444824, 2.0172276496887207, 2.017235279083252, 2.0173447132110596, 2.0173466205596924, 2.0173490047454834, 2.0173842906951904, 2.0174143314361572, 2.0174849033355713, 2.0175554752349854, 2.017561912536621, 2.017582416534424, 2.0175936222076416, 2.01760196685791, 2.017611265182495, 2.0176684856414795, 2.0177273750305176, 2.0182065963745117, 2.018428087234497, 2.0184988975524902, 2.0186150074005127, 2.0186288356781006, 2.018636703491211, 2.0188305377960205, 2.0188827514648438, 2.0190231800079346, 2.019031524658203, 2.019031524658203, 2.0195422172546387, 2.0196714401245117, 2.0196714401245117, 2.0197978019714355, 2.019819736480713, 2.0198726654052734, 2.019911766052246, 2.020005702972412, 2.0200958251953125, 2.020102024078369, 2.02011775970459, 2.0201802253723145, 2.0202865600585938, 2.0203189849853516, 2.0204248428344727, 2.0204265117645264, 2.0204708576202393, 2.0205447673797607, 2.0205447673797607, 2.020564079284668, 2.020592451095581, 2.0206217765808105, 2.020761489868164, 2.020787239074707, 2.020798683166504, 2.020890235900879, 2.021050453186035, 2.021090269088745, 2.021373748779297, 2.0214309692382812, 2.0214409828186035, 2.0217442512512207, 2.02179217338562, 2.0217998027801514, 2.0218377113342285, 2.0219483375549316, 2.022031784057617, 2.0220696926116943, 2.022174119949341, 2.0222506523132324, 2.0223264694213867, 2.0225532054901123, 2.0226056575775146, 2.022613763809204, 2.022664785385132, 2.0227434635162354, 2.0227444171905518, 2.022782802581787, 2.022897958755493, 2.0229852199554443, 2.023037910461426, 2.0231058597564697, 2.023245096206665, 2.023282289505005, 2.023318290710449, 2.0234134197235107, 2.023561954498291, 2.0235824584960938, 2.0236082077026367, 2.023623466491699, 2.023623466491699, 2.0237314701080322, 2.023803949356079, 2.0238564014434814, 2.0238614082336426, 2.023932695388794, 2.023932695388794, 2.0239903926849365, 2.024096965789795, 2.0241811275482178, 2.0242929458618164, 2.0244836807250977, 2.024515151977539, 2.0245471000671387, 2.0245604515075684, 2.024780750274658, 2.024780750274658, 2.024822473526001, 2.025052070617676, 2.0250704288482666, 2.025123119354248, 2.0251660346984863, 2.0251994132995605, 2.0252466201782227, 2.025261878967285, 2.0254411697387695, 2.0255126953125, 2.025707483291626, 2.0257856845855713, 2.025879383087158, 2.025959014892578, 2.026026487350464, 2.026144504547119, 2.026219606399536, 2.0263054370880127, 2.0264413356781006, 2.0264527797698975, 2.026581287384033, 2.026637315750122, 2.0268454551696777, 2.0268843173980713, 2.0269277095794678, 2.02700138092041, 2.027097225189209, 2.0271828174591064, 2.027294874191284, 2.0273542404174805, 2.0273873805999756, 2.0273983478546143, 2.0276217460632324, 2.027954578399658, 2.0281167030334473, 2.0284533500671387, 2.0285987854003906, 2.0287296772003174, 2.0287435054779053, 2.028748035430908, 2.028839349746704, 2.028963804244995, 2.029008626937866, 2.02913236618042, 2.0293004512786865, 2.0296216011047363, 2.0296247005462646, 2.0296614170074463, 2.0296683311462402, 2.0298876762390137, 2.029942512512207, 2.029981851577759, 2.0300345420837402, 2.0300707817077637, 2.030095338821411, 2.030196189880371, 2.0302653312683105, 2.030360221862793, 2.0304179191589355, 2.0305800437927246, 2.030663251876831, 2.030789613723755, 2.03088116645813, 2.0310709476470947, 2.0312886238098145, 2.0313117504119873, 2.031348943710327, 2.0313940048217773, 2.0314133167266846, 2.03145432472229, 2.0316925048828125, 2.0318243503570557, 2.0318424701690674, 2.0318543910980225, 2.031951427459717, 2.031970262527466, 2.032130241394043, 2.0321412086486816, 2.0322537422180176, 2.032280445098877, 2.032327175140381, 2.032336950302124, 2.0324411392211914, 2.0324676036834717, 2.0324907302856445, 2.032641649246216, 2.0330557823181152, 2.033064842224121, 2.0330889225006104, 2.0331408977508545, 2.0331788063049316, 2.033334255218506, 2.033482074737549, 2.033496379852295, 2.0335898399353027, 2.033663511276245, 2.0338053703308105, 2.034001350402832, 2.034147024154663, 2.0342607498168945, 2.034396171569824, 2.034419059753418, 2.034454345703125, 2.0345261096954346, 2.0347237586975098, 2.034911632537842, 2.0349576473236084, 2.034959316253662, 2.0352232456207275, 2.0353167057037354, 2.0353169441223145, 2.0353457927703857, 2.0353777408599854, 2.0353779792785645, 2.035414218902588, 2.035421133041382, 2.0355236530303955, 2.035583972930908, 2.0357894897460938, 2.03586483001709, 2.0359461307525635, 2.035980463027954, 2.0361979007720947, 2.0362091064453125, 2.0362749099731445, 2.0363826751708984, 2.0364813804626465, 2.036708354949951, 2.036708354949951, 2.036731243133545, 2.036801815032959, 2.036818504333496, 2.036818504333496, 2.036818504333496, 2.036865234375, 2.036957263946533, 2.0371851921081543, 2.0371954441070557, 2.0371954441070557, 2.0371954441070557, 2.037358045578003, 2.037358045578003, 2.0374011993408203, 2.03745698928833, 2.0375099182128906, 2.0375123023986816, 2.037527561187744, 2.0376508235931396, 2.0376970767974854, 2.0378737449645996, 2.0378904342651367, 2.037924289703369, 2.0380043983459473, 2.038085460662842, 2.038109064102173, 2.038259506225586, 2.038414478302002, 2.0387985706329346, 2.0389113426208496, 2.0390355587005615, 2.0390772819519043, 2.0392673015594482, 2.0393154621124268, 2.039327383041382, 2.0393385887145996, 2.0394179821014404, 2.0394797325134277, 2.0395455360412598, 2.0398545265197754, 2.0400335788726807, 2.0400474071502686, 2.0401127338409424, 2.040229082107544, 2.040325880050659, 2.040376663208008, 2.040431499481201, 2.040767192840576, 2.0408873558044434, 2.041111469268799, 2.0412909984588623, 2.0414035320281982, 2.041449546813965, 2.0414981842041016, 2.0415802001953125, 2.0415966510772705, 2.041747808456421, 2.041907787322998, 2.042104482650757, 2.042205810546875, 2.042494773864746, 2.0427403450012207, 2.042853832244873, 2.0429182052612305, 2.0429413318634033, 2.043022632598877, 2.0430569648742676, 2.043146848678589, 2.0431976318359375, 2.043227434158325, 2.043445587158203, 2.0435876846313477, 2.04371976852417, 2.043736696243286, 2.0439698696136475, 2.0441739559173584, 2.044273614883423, 2.044273614883423, 2.0443549156188965, 2.044565200805664, 2.0445942878723145, 2.044910192489624, 2.044921398162842, 2.044933795928955, 2.045072555541992, 2.0450832843780518, 2.045119285583496, 2.0451576709747314, 2.0451903343200684, 2.045280933380127, 2.045311689376831, 2.0453338623046875, 2.0453338623046875, 2.0453782081604004, 2.0454530715942383, 2.045494794845581, 2.04549503326416, 2.045544385910034, 2.0456974506378174, 2.0458524227142334, 2.0459182262420654, 2.0460054874420166, 2.0460500717163086, 2.0460517406463623, 2.046083927154541, 2.0461106300354004, 2.046232223510742, 2.0462758541107178, 2.046316623687744, 2.046337127685547, 2.0464556217193604, 2.0466647148132324, 2.046992063522339, 2.047015905380249, 2.0470848083496094, 2.047255277633667, 2.0473921298980713, 2.0475921630859375, 2.0476064682006836, 2.0477511882781982, 2.0478413105010986, 2.0478415489196777, 2.0478928089141846, 2.0480430126190186, 2.0480873584747314, 2.048232078552246, 2.048346519470215, 2.048356533050537, 2.048757314682007, 2.0488369464874268, 2.0488622188568115, 2.0490024089813232, 2.0491726398468018, 2.049576997756958, 2.049778461456299, 2.049936294555664, 2.05005145072937, 2.0500564575195312, 2.0504164695739746, 2.050508975982666, 2.050543785095215, 2.0510635375976562, 2.0511116981506348, 2.0511276721954346, 2.051130771636963, 2.0512447357177734, 2.0513134002685547, 2.051363945007324, 2.0514516830444336, 2.0515408515930176, 2.051636219024658, 2.0516457557678223, 2.051710844039917, 2.0517892837524414, 2.052009344100952, 2.0520877838134766, 2.052100658416748, 2.052121162414551, 2.052227258682251, 2.052277088165283, 2.0523064136505127, 2.0523133277893066, 2.0523858070373535, 2.05241322517395, 2.052494764328003, 2.0525619983673096, 2.052568197250366, 2.052700996398926, 2.052835702896118, 2.0531225204467773, 2.053163528442383, 2.053255796432495, 2.0533881187438965, 2.053443193435669, 2.053450345993042, 2.0534534454345703, 2.0534749031066895, 2.0536224842071533, 2.0536251068115234, 2.054062604904175, 2.05409574508667, 2.05429744720459, 2.054323434829712, 2.054353713989258, 2.054424285888672, 2.054443597793579, 2.0545494556427, 2.054626226425171, 2.054626226425171, 2.054772138595581, 2.05480694770813, 2.0548815727233887, 2.0549731254577637, 2.0550718307495117, 2.055131673812866, 2.0552563667297363, 2.0552892684936523, 2.0553009510040283, 2.055584669113159, 2.0556271076202393, 2.055774688720703, 2.0558152198791504, 2.056140184402466, 2.05617094039917, 2.0565061569213867, 2.056709051132202, 2.056730270385742, 2.056732654571533, 2.0567498207092285, 2.0569570064544678, 2.0570271015167236, 2.0570569038391113, 2.0572144985198975, 2.0573458671569824, 2.057370662689209, 2.0576038360595703, 2.0576424598693848, 2.0576632022857666, 2.057663679122925, 2.0576913356781006, 2.057772397994995, 2.057793140411377, 2.057929039001465, 2.0579946041107178, 2.0580761432647705, 2.0580828189849854, 2.0581817626953125, 2.0581910610198975, 2.058349609375, 2.0584471225738525, 2.0585412979125977, 2.0585522651672363, 2.058615207672119, 2.0586841106414795, 2.058889865875244, 2.058906316757202, 2.0590627193450928, 2.0592007637023926, 2.0593760013580322, 2.0594005584716797, 2.059638261795044, 2.0598256587982178, 2.0600087642669678, 2.0601320266723633, 2.0604639053344727, 2.06057071685791, 2.0608320236206055, 2.0611038208007812, 2.061150312423706, 2.061154842376709, 2.061154842376709, 2.0612082481384277, 2.061251401901245, 2.061326503753662, 2.061347484588623, 2.061558246612549, 2.0616726875305176, 2.0617175102233887, 2.061790704727173, 2.0618255138397217, 2.061889171600342, 2.0620803833007812, 2.062314510345459, 2.06243896484375, 2.062473773956299, 2.062502384185791, 2.0625905990600586, 2.062641143798828, 2.0626730918884277, 2.062690258026123, 2.062713146209717, 2.062847137451172, 2.0631752014160156, 2.0631752014160156, 2.063363552093506, 2.0634350776672363, 2.0634655952453613, 2.0636165142059326, 2.063633918762207, 2.063724994659424, 2.063809871673584, 2.063809871673584, 2.0638465881347656, 2.0639336109161377, 2.063974142074585, 2.0641379356384277, 2.0641896724700928, 2.064330577850342, 2.064516305923462, 2.064653158187866, 2.064948558807373, 2.0652031898498535, 2.065363645553589, 2.0653910636901855, 2.0654006004333496, 2.065474033355713, 2.0654897689819336, 2.0656495094299316, 2.066028594970703, 2.0660932064056396, 2.06622052192688, 2.0662801265716553, 2.0663716793060303, 2.066439628601074, 2.0665435791015625, 2.066972017288208, 2.0674190521240234, 2.067483901977539, 2.0674936771392822, 2.0674972534179688, 2.067638874053955, 2.0676729679107666, 2.067692518234253, 2.067774534225464, 2.0677881240844727, 2.067885160446167, 2.067936897277832, 2.0679373741149902, 2.0681114196777344, 2.068145751953125, 2.0682637691497803, 2.068477153778076, 2.0688047409057617, 2.068824529647827, 2.0689797401428223, 2.0692689418792725, 2.069382905960083, 2.0695204734802246, 2.0695204734802246, 2.0696663856506348, 2.069749355316162, 2.0699193477630615, 2.070012092590332, 2.070180892944336, 2.070216417312622, 2.070347785949707, 2.070404529571533, 2.070513963699341, 2.0706088542938232, 2.0707273483276367, 2.0710902214050293, 2.071263074874878, 2.0712931156158447, 2.07135272026062, 2.0714609622955322, 2.0715231895446777, 2.0716283321380615, 2.0716731548309326, 2.0719680786132812, 2.072291612625122, 2.072716236114502, 2.072810173034668, 2.0734355449676514, 2.0735485553741455, 2.0740151405334473, 2.074068069458008, 2.0741117000579834, 2.074178695678711, 2.0745601654052734, 2.0745973587036133, 2.0753674507141113, 2.0754141807556152, 2.0754401683807373, 2.0756497383117676, 2.0757107734680176, 2.0757107734680176, 2.075725793838501, 2.0757367610931396, 2.0757644176483154, 2.0758776664733887, 2.07594633102417, 2.0760912895202637, 2.076162815093994, 2.076354742050171, 2.0763814449310303, 2.0766491889953613, 2.0769288539886475, 2.077178955078125, 2.077803611755371, 2.0782887935638428, 2.078664779663086, 2.078667402267456, 2.078817367553711, 2.079003095626831, 2.0790083408355713, 2.0790083408355713, 2.0790083408355713, 2.079073667526245, 2.0790910720825195, 2.0791866779327393, 2.0794036388397217, 2.079414129257202, 2.079474925994873, 2.079577922821045, 2.079655408859253, 2.0799503326416016, 2.0801897048950195, 2.080293655395508, 2.080413818359375, 2.0806243419647217, 2.08091139793396, 2.080962896347046, 2.0811548233032227, 2.0811660289764404, 2.081238269805908, 2.0818655490875244, 2.081892251968384, 2.0818939208984375, 2.081993579864502, 2.0820770263671875, 2.082078456878662, 2.0822482109069824, 2.082533836364746, 2.0825724601745605, 2.0826833248138428, 2.0829455852508545, 2.083024024963379, 2.08343243598938, 2.0838212966918945, 2.0838277339935303, 2.0838277339935303, 2.083872079849243, 2.083946704864502, 2.084394931793213, 2.0844340324401855, 2.084498405456543, 2.0845093727111816, 2.0845141410827637, 2.084974527359009, 2.0852999687194824, 2.085341215133667, 2.0855305194854736, 2.0855860710144043, 2.0858590602874756, 2.0859158039093018, 2.086158037185669, 2.0861616134643555, 2.0862197875976562, 2.086247444152832, 2.086277723312378, 2.0862863063812256, 2.0864899158477783, 2.0864970684051514, 2.0868659019470215, 2.0869152545928955, 2.0871238708496094, 2.0871787071228027, 2.087289571762085, 2.0874576568603516, 2.0875372886657715, 2.0875625610351562, 2.088391065597534, 2.088654041290283, 2.0888357162475586, 2.0890841484069824, 2.089250326156616, 2.0896081924438477, 2.0900802612304688, 2.090561628341675, 2.090885639190674, 2.0909957885742188, 2.091132402420044, 2.091428756713867, 2.0916149616241455, 2.0916929244995117, 2.092172622680664, 2.092252016067505, 2.092287063598633, 2.092808723449707, 2.0937185287475586, 2.0938737392425537, 2.0950191020965576, 2.0950589179992676, 2.0956051349639893, 2.0958263874053955, 2.095852851867676, 2.0960116386413574, 2.096022129058838, 2.0963683128356934, 2.0965142250061035, 2.0966434478759766, 2.0970442295074463, 2.0971953868865967, 2.09732723236084, 2.097344398498535, 2.097557306289673, 2.097681760787964, 2.0977985858917236, 2.0980722904205322, 2.0982003211975098, 2.098252058029175, 2.0986766815185547, 2.098684310913086, 2.0986855030059814, 2.0988240242004395, 2.0988526344299316, 2.0990512371063232, 2.0994293689727783, 2.099483013153076, 2.0995967388153076, 2.099681854248047, 2.0998435020446777, 2.100302219390869, 2.101365804672241, 2.1022372245788574, 2.1022722721099854, 2.1023385524749756, 2.1024303436279297, 2.1026062965393066, 2.103278160095215, 2.1040518283843994, 2.1041316986083984, 2.1041975021362305, 2.104326009750366, 2.1045310497283936, 2.1052584648132324, 2.1059770584106445, 2.1065642833709717, 2.1068637371063232, 2.1068637371063232, 2.1068637371063232, 2.1072685718536377, 2.1074838638305664, 2.1075587272644043, 2.107792854309082, 2.1080095767974854, 2.1080727577209473, 2.108250379562378, 2.108520746231079, 2.108658790588379, 2.109217405319214, 2.109217405319214, 2.109217405319214, 2.1093344688415527, 2.1099958419799805, 2.110720157623291, 2.1107611656188965, 2.110931634902954, 2.1113784313201904, 2.111621618270874, 2.111638069152832, 2.111698627471924, 2.111931562423706, 2.1122186183929443, 2.1122758388519287, 2.112849235534668, 2.113234758377075, 2.113278865814209, 2.11334228515625, 2.1134486198425293, 2.1140313148498535, 2.1143198013305664, 2.1143243312835693, 2.114325523376465, 2.114699363708496, 2.1147797107696533, 2.116419792175293, 2.116654396057129, 2.116731643676758, 2.1171021461486816, 2.1176533699035645, 2.1178183555603027, 2.117920398712158, 2.1185832023620605, 2.1185832023620605, 2.118771553039551, 2.119091033935547, 2.1191720962524414, 2.1191720962524414, 2.1194112300872803, 2.1202280521392822, 2.121250867843628, 2.121321201324463, 2.121835231781006, 2.1223807334899902, 2.12257719039917, 2.1227049827575684, 2.1228091716766357, 2.1228456497192383, 2.123044490814209, 2.1231257915496826, 2.1233768463134766, 2.1233768463134766, 2.123659133911133, 2.123727321624756, 2.124279499053955, 2.12447452545166, 2.1248316764831543, 2.1259844303131104, 2.126983880996704, 2.127577304840088, 2.127662181854248, 2.1282873153686523, 2.1287100315093994, 2.128983974456787, 2.1291675567626953, 2.12943434715271, 2.130117177963257, 2.130225658416748, 2.1305902004241943, 2.130927562713623, 2.13217830657959, 2.1325488090515137, 2.133368968963623, 2.1338396072387695, 2.134160041809082, 2.134645938873291, 2.1349048614501953, 2.135728359222412, 2.135906219482422, 2.135906219482422, 2.135906219482422, 2.136336088180542, 2.136641502380371, 2.1366541385650635, 2.136706590652466, 2.138312578201294, 2.1389942169189453, 2.1390457153320312, 2.1397476196289062, 2.1397829055786133, 2.1406402587890625, 2.1410279273986816, 2.141362190246582, 2.1415469646453857, 2.1417436599731445, 2.142267942428589, 2.1425604820251465, 2.1427178382873535, 2.1429762840270996, 2.1432061195373535, 2.1446361541748047, 2.1446361541748047, 2.1446361541748047, 2.1447207927703857, 2.14568829536438, 2.14579176902771, 2.146672248840332, 2.1470017433166504, 2.1470017433166504, 2.1471645832061768, 2.14802885055542, 2.14802885055542, 2.14802885055542, 2.1483359336853027, 2.1488616466522217, 2.149352788925171, 2.1497979164123535, 2.1518054008483887, 2.152190685272217, 2.1535377502441406, 2.1539688110351562, 2.1551694869995117, 2.1564979553222656, 2.1565699577331543, 2.157423734664917, 2.1586475372314453, 2.1589183807373047, 2.15954852104187, 2.1602683067321777, 2.1618621349334717, 2.1627750396728516, 2.163194179534912, 2.1638402938842773, 2.1640465259552, 2.1650900840759277, 2.1655640602111816, 2.166236639022827, 2.1667003631591797, 2.1691951751708984, 2.173882246017456, 2.174229621887207, 2.176521062850952, 2.182769298553467, 2.1859214305877686, 2.1873302459716797, 2.190225839614868, 2.192528009414673, 2.2171547412872314, 2.2229163646698, 2.230116605758667, 2.230116605758667, 2.230116605758667, 2.2309999465942383, 2.2369871139526367, 2.249943733215332]], "included": ["distances", "documents", "metadatas"]}